<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[浅谈网络安全--xss、csrf、csp]]></title>
    <url>%2F2018%2F10%2F25%2F%E6%B5%85%E8%B0%88%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8-xss%E3%80%81csrf%E3%80%81csp%2F</url>
    <content type="text"><![CDATA[浅谈网络安全–xss、csrf、csp 一、XSS概念跨网站指令码（英语：Cross-site scripting，通常简称为：XSS）是一种网站应用程式的安全漏洞攻击，是代码注入的一种。它允许恶意使用者将程式码注入到网页上，其他使用者在观看网页时就会受到影响。这类攻击通常包含了HTML以及使用者端脚本语言。 举例我们知道留言板通常的任务就是把用户留言的内容展示出来。正常情况下，用户的留言都是正常的语言文字，留言板显示的内容也就没毛病。然而这个时候如果有人不按套路出牌，在留言内容中丢进去一行： 1&lt;script&gt;alert("hey!you are attacked")&lt;/script&gt; 那么留言板界面的网页代码就会变成形如以下： 12345678910&lt;html&gt; &lt;head&gt; &lt;title&gt;留言板&lt;/title&gt; &lt;/head&gt;&lt;body&gt;&lt;div id="board"&gt; &lt;script&gt;alert("hey!you are attacked")&lt;/script&gt;&lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 那么别的用户加载到留言板的时候，就会出现这个弹出框； 其他可以干的事情攻击者当然不会仅仅弹出一个alert框，既然可以插入脚本，那么也可以做一些其他的事情，例如： 1、窃取网页浏览中的cookie值，为接下来的CSRF做准备2、劫持流量实现恶意跳转3、注入脚本获得其他信息 如何绕过一般网站的过滤规则实际应用中web程序往往会通过一些过滤规则来组织代有恶意代码的用户输入被显示，以下是一些常用的xss攻击绕过过滤的一些方法： 1、大小写绕过1http://192.168.1.102/xss/example2.php?name=&lt;sCript&gt;alert(&quot;hey!&quot;)&lt;/scRipt&gt; 2、利用过滤后返回语句再次构成攻击语句来绕过1http://192.168.1.102/xss/example3.php?name=&lt;sCri&lt;script&gt;pt&gt;alert(&quot;hey!&quot;)&lt;/scRi&lt;/script&gt;pt&gt; 发现问题了吧，这个利用原理在于只过滤了一个script标签。3、并不是只有script标签才可以插入代码1http://192.168.1.102/xss/example4.php?name=&lt;img src=&apos;w.123&apos; onerror=&apos;alert(&quot;hey!&quot;)&apos;&gt; 其他绕过方式可以参考知乎用户Snake的专栏文章; 防范手段1、既然是代码注入攻击，那我们可以对敏感字符做转义，如下：12345678910function escape(str) &#123; str = str.replace(/&amp;/g, "&amp;amp;"); str = str.replace(/&lt;/g, "&amp;lt;"); str = str.replace(/&gt;/g, "&amp;gt;"); str = str.replace(/"/g, "&amp;quto;"); str = str.replace(/'/g, "&amp;##39;"); str = str.replace(/`/g, "&amp;##96;"); str = str.replace(/\//g, "&amp;##x2F;"); return str&#125; 2、CSP（接下来会谈到） 3、过滤诸如&lt;script&gt;、&lt;img&gt;、&lt;a&gt; 标签 3、为防止cookie盗用，我们还可以在Http响应头设置HttpOnly 二、CSP上文提到了可以用CSP来防止XSS攻击，那CSP到底是什么呢？ 概念内容安全策略 (CSP) 是一个额外的安全层，用于检测并削弱某些特定类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击等。无论是数据盗取、网站内容污染还是散发恶意软件，这些攻击都是主要的手段； 举例前段时间王二想在知乎控制台下插入一段脚本，如下： 则会提示报错，而在有些网站(百度，Google)不会报错； 这是因为在知乎遵循了CSP,在网站的http头部定义了 Content-Security-Policy： CSP 本质上是建立白名单，规定了浏览器只能够执行特定来源的代码;那么即使发生了xss攻击，也不会加载来源不明的第三方脚本； 三、CSRF概念跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站指令码（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。 举例1、同一个浏览器下假如一家银行用以执行转帐操作的URL地址如下： 1http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName 那么，一个恶意攻击者可以在另一个网站上放置如下代码： 1&lt;img src="http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman"&gt; 如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。 2、结合xss使用上文说了xss可以结合csrf使用； 在通过xss获得目标用户的cookie后，打开目标网站的登录界面，调出Chrome控制台的Application面板，调至cookie选项卡： 再把目标用户的cookie填进去，再把过期时间调长一些， 完成之后再次刷新页面，发现已经不是之前的登录界面了，而是登录后的界面。至此，一个从cookie窃取到利用的过程就已完成。 防范手段对于上面说的第一个例子： 1、检查Referer字段：HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。2、添加校验token 对于上面说的第二个例子，则做好防止xss攻击的相应措施。 参考文章： 知乎用户Snake的专栏文章 wikiwand xss wikiwand csrf InterviewMap ‘Coocier’的开发小记]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爱笑的宝宝]]></title>
    <url>%2F2018%2F10%2F02%2F%E7%88%B1%E7%AC%91%E7%9A%84%E5%AE%9D%E5%AE%9D%2F</url>
    <content type="text"><![CDATA[爱笑的宝宝，心善的宝宝，可爱的宝宝 偶尔也不能快乐的生活着，偶尔也会有木讷，失眠快成常态。 或许生活的本色如此，或许应该静下来沉淀浮杂。 这些都太糟糕，全不是我想要。 我想要每天有所收获，我想要每天生机勃勃，我想要湛蓝的天，…… 慢着，干脆什么都不要，什么都别想，任生命燃烧，任时光流逝，任天气变幻莫测，抓不住的就不去抓，得不到的就不去想，一路走来，花自然会开]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《醉汉的脚步》中有趣的概率问题]]></title>
    <url>%2F2018%2F08%2F06%2F%E3%80%8A%E9%86%89%E6%B1%89%E7%9A%84%E8%84%9A%E6%AD%A5%E3%80%8B%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E6%A6%82%E7%8E%87%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[有些概率上的问题，直觉上不可能，但却切切实实的发生。以下王二将分享一些书中有趣的概率问题。 1、生日问题 如果希望一群人中有某两个人在同一天生日的可能性大于50%，这个群体需要多少人？事实上，只需要23个人就够了。 2、两女儿问题 假设一名母亲怀上了一对双胞胎，则两个小孩都是女孩的概率是多少？概率是1/4。 3、两女儿问题（进阶一） 假设一名母亲怀上了一对双胞胎，其中一名是女孩，则另一名小孩都是女孩的概率是多少？概率是1/3。 4、三门问题 你参加一场活动，面对三张门，一张后面是iPhoneX，另外两张后面是一个西瓜，你有机会选中一张门并获得其背后的东西。当你选定一扇门后，主持人将打开另外两张门的一张门（主持人知道各个门后面是什么东西），门后是一个西瓜，然后问你：“你要更换你的选择，去选另外一张没打开的门吗？” 请问：现在是更换选择获得iPhoneX的概率大，还是不更换选择获得iPhoneX的概率大，还是一样大？答案是更换选择获得iPhoneX的概率大，其概率是2/3； 5、两女儿问题（进阶二） 假设一名母亲怀上了一对双胞胎，其中一名是叫王美丽的女孩，则另一名小孩都是女孩的概率是多少？概率是1/2。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 检测网络带宽]]></title>
    <url>%2F2018%2F07%2F17%2FJS-%E6%A3%80%E6%B5%8B%E7%BD%91%E7%BB%9C%E5%B8%A6%E5%AE%BD%2F</url>
    <content type="text"><![CDATA[最近项目上有需求要检测网络的带宽，网上找了不少解决方案，以下王二来做一个整理 1、方法一第一种思路是 加载一张图片，通过的加载时长和图片的大小来计算出网络带宽 有了这个思路，我们可以参考如下代码（部分参考自 github 上的debloper/bandwidth.js）： 123456789101112131415161718192021222324function measureBW(fn) &#123; var startTime, endTime, fileSize; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = () =&gt; &#123; if(xhr.readyState === 2)&#123; startTime = Date.now(); &#125; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; endTime = Date.now(); fileSize = xhr.responseText.length; var speed = fileSize / ((endTime - startTime)/1000) / 1024; fn &amp;&amp; fn(Math.floor(speed)) &#125; &#125; xhr.open("GET", "https://upload.wikimedia.org/wikipedia/commons/5/51/Google.png", true); xhr.send();&#125;measureBW((speed)=&gt;&#123; console.log(speed + " KB/sec"); //215 KB/sec&#125;) 2、方法二但是考虑到http请求需要建立连接，以及等待响应，这些过程也会消耗一些时间，所以以上的方法可能不会准确的检测出网络带宽。 我们可以同时发出多次请求，来减少http请求建立连接，等待响应的影响，参考如下代码： 12345678910111213141516171819202122232425262728293031323334function measureBW(fn,time) &#123; time = time || 1; var startTime, endTime, fileSize; var count = time ; var _this = this; function measureBWSimple () &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = () =&gt; &#123; if (xhr.readyState === 4 &amp;&amp; xhr.status === 200) &#123; if(!fileSize)&#123; fileSize = xhr.responseText.length; &#125; count --; if(count&lt;=0)&#123; endTime = Date.now(); var speed = fileSize * time / ((endTime - startTime)/1000) / 1024; fn &amp;&amp; fn(Math.floor(speed)); &#125; &#125; &#125; xhr.open("GET", "https://upload.wikimedia.org/wikipedia/commons/5/51/Google.png", true); xhr.send(); &#125; startTime = Date.now(); for(var x = time;x&gt;0;x--)&#123; measureBWSimple() &#125;&#125;measureBW((speed)=&gt;&#123; console.log(speed + " KB/sec"); //913 KB/sec&#125;,10) 经王二测试，第二种方法得到的结果要比方法一得到的结果明显高出不少。 事实上，前两种还要额外设置 http 请求头来禁止使用本地缓存（开发测试下可以在控制台Network面板下点击禁用缓存），要不然图片加载一次后就不会在去服务器加载，自然也测不出网络的带宽. 3、方法三在 Chrome65+ 的版本中，添加了一些原生的方法可以检测有关设备正在使用的连接与网络进行通信的信息。 参考如下代码，我们就可以检测到网络带宽： 1234function measureBW () &#123; return navigator.connection.downlink;&#125;measureBW() ; navigator.connection.downlink 会返回以（兆比特/秒）为单位的有效带宽估计值(参考MDN),这和我们常用的（KB/sec）有所差别，所以我们需要再做一下单位换算，参考如下代码： 1234function measureBW () &#123; return navigator.connection.downlink * 1024 /8; //单位为KB/sec&#125;measureBW() ; 我们还可以通过 navigator.connection 上的 change 事件来监听网络带宽的变化：1navigator.connection.addEventListener('change', measureBW()); 参考文章： MDN NetworkInformationNetwork Information API SampleKbps、KB、Mbps单位换算]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[奥斯本检核表法]]></title>
    <url>%2F2018%2F06%2F03%2F%E5%A5%A5%E6%96%AF%E6%9C%AC%E6%A3%80%E6%A0%B8%E8%A1%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近看到一个很有意思的的思考问题的方法–奥斯本检核表法 奥斯本检核表法是以该方法的发明者奥斯本命名的，它会引导个人在创新的过程中对照9个维度75个问题进行思考，启迪思路，开拓想象空间，打破固有的思维模式。以下是奥斯本的检核表 一、能否他用现有的事物有无其他用途；保持不变能否扩大用途；稍加改变有无其他用途。 包括三个问题： 有无新的用途？ 是否有新的使用方法？ 可否改变现有的使用方法？ 二、能否借用能否引入其他的创造性设想；能否模仿别的东西；能否从其他领域、产品、方案中引入新的元素、材料、造型、原理、工艺、思路。 包括五个问题： 有无类似的东西？ 利用类比能否产生新观念？ 过去有无类似的问题？ 可否模仿？ 能否超越？ 三、能否改变现有事物能否做些改变，如颜色、声音、味道、样式、花色、音响、品种、意义、制造方法；改变后效果如何？ 包括八个问题： 可否改变功能？ 可否改变颜色？ 可否改变形状？ 可否改变运动？ 可否改变气味？ 可否改变音响？ 可否改变外形？ 是否还有其他改变的可能性？ 四、能否扩大1、现有的事物可否扩大适用范围；能否增加使用功能；能否添加零部件，延长它的使用寿命，增加长度、厚度、强度、频率、速度、数量、价值。 包括十二个问题： 可否增加些什么？ 可否附加些什么？ 可否增加使用时间？ 可否增加频率？ 可否增加尺寸？ 可否增加强度？ 可否提高性能？ 可否增加新成分？ 可否加倍？ 可否扩大若干倍？ 可否放大？ 可否夸大？ 五、能否缩小 现有事物能否体积变小、长度变短、重量变轻、厚度变薄以及拆分或省略某些部分（简单化）？能否浓缩化、省力化、方便化。 包括十二个问题： 可否减少些什么？ 可否密集？ 可否压缩？ 可否浓缩？ 可否聚合？ 可否微型化？ 可否缩短？ 可否变窄？ 可否去掉？ 可否分割？ 可否减轻？ 可否变成流线型？ 六、能否代替 现有事物能否用其他材料、元件、结构、力、设备、方法、符号、声音等代替。 包括十个问题： 可否代替？ 用什么代替？ 还有什么其他的排列？ 还有什么其他的成分？ 还有什么其他的材料？ 还有什么其他的过程？ 还有什么其他的能源？ 还有什么其他的颜色？ 还有什么其他的音响？ 还有什么其他的照明？ 七、能否变换 现有事物能否变换排列顺序、位置、时间、速度、计划、型号；内部元件可否交换。 包括八个问题： 可否变换？ 有无可互换的成分？ 可否变换模式？ 可否变换布置顺序？ 可否变换操作工序？ 可否变换因果关系？ 可否变换速度或者频率？ 可否变换工作规范？ 八、能否颠倒现有的事物能否从内外、上下、左右、前后、横竖、主次、正负、因果等相反的角度颠倒过来用。 包括七个问题： 可否颠倒？ 可否颠倒正负？ 可否颠倒正反？ 可否前后颠倒？ 可否上下颠倒？ 可否颠倒位置？ 可否颠倒作用？ 九、能否组合能否进行原理组合、材料组合、部件组合、形状组合、功能组合、目的组合。 包括十个问题： 可否重新组合？ 可否尝试混合？ 可否尝试合成？ 可否尝试配合？ 可否尝试协调？ 可否尝试配套？ 可否把物体组合？ 可否把目的组合？ 可否把特性组合？ 可否把观念组合？ 如何思考问题的方法，这到了元知识的范畴。 就王二自身而言，把现在一些事情套进奥斯本检核表里来思考，脑子里确实能够蹦出不少全新而且巧妙的点子，让王二能够全面的发散的思考一个问题。希望这对你也会有一些帮助。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《你不知道的Javascript中卷》中有趣的知识点一]]></title>
    <url>%2F2018%2F04%2F25%2F%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84javascript%E4%B8%AD%E5%8D%B7%E3%80%8B%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%E4%B8%80%2F</url>
    <content type="text"><![CDATA[最近在看《你不知道的Javascript中卷》，里面有不少有趣的知识点和新鲜货，在这里做一个分享 一、类数组转换一些 DOM 查询操作会返回 DOM 元素列表，它们并非真正意义上的数组，但十分类似。另一个例子是通过 arguments 对象（类数组）将函数的参数,这时候我们可以通过如下方式将这些类数组转换为数组： 1234//通过工具函数slice();var arr = Array.prototype.slice.call( arguments );//或者ES6语法Array.from();var arr = Array.from( arguments ); 二、 . 运算符对于 . 运算符我们需要给予特别注意，因为它是一个有效的数字字符，会被优先识别为数字常量的一部分，然后才是对象属性访问运算符。 1234567// 无效语法：42.toFixed( 3 ); // SyntaxError// 下面的语法都有效：(42).toFixed( 3 ); // "42.000" 0.42.toFixed( 3 ); // "0.420"42..toFixed( 3 ); // "42.000"42 .toFixed(3); // "42.000"（注意其中的空格） 三、0.1 + 0.2 === 0.3 ？在js中: 10.1 + 0.2 === 0.3; // false 关于这个问题，感兴趣的同学可以读读王二的转载的一篇文章抓住数据的小尾巴 - JS浮点数陷阱及解法，由于 JavaScript 中的数字类型是基于 IEEE754 标准来实现的，所以二进制浮点数中的 0.1 和 0.2 相加并不是十分精确，这时候可以使用 Number.EPSILON 来比较两个数字是否相等（在指定的误差范围内）： 123456function numbersCloseEnoughToEqual(n1,n2) &#123; return Math.abs( n1 - n2 ) &lt; Number.EPSILON;&#125;var a = 0.1 + 0.2;var b = 0.3;numbersCloseEnoughToEqual( a, b ); //true 四、null 与 undefinednull 是一个特殊关键字，不是标识符，我们不能将其当作变量来使用和赋值。然而 undefined 却是一个标识符，可以被当作变量来使用和赋值。 五、isNaN()我们可以使用全局工具函数 window.isNaN() 和 ES6中的 Number.isNaN() 来判断一个值是不是 NaN,但这两者也有区别，参考如下代码： 123456789101112131415161718192021Number.isNaN( NaN ); // trueNumber.isNaN( "wanger" ); // false Number.isNaN( 5 ); // falsewindow.isNaN( NaN ); // truewindow.isNaN( "wanger" ); // true window.isNaN( 5 ); // false``` 很明显 "wanger" 不是一个数字 ，它也不是 NaN 。但是 `window.isNaN( "wanger" )`显示为true, 这个 bug自 JavaScript 问世以来就一直存在。### 六、`Object.prototype.toString` 可以查看类型```jsObject.prototype.toString.call( [1,2,3] ); // "[object Array]"Object.prototype.toString.call( /regex-literal/i ); // "[object RegExp]"Object.prototype.toString.call( null ); // "[object Null]"Object.prototype.toString.call( undefined ); //"[object Undefined]"Object.prototype.toString.call( "abc" ); // "[object String]"Object.prototype.toString.call( 42 ); // "[object Number]"Object.prototype.toString.call( true ); // "[object Boolean]" 七、JSON 字符串化undefined 、function 、symbol （ES6+）和包含循环引用（对象之间相互引用，形成一个无限循环）的对象都不符合 JSON 结构标准，支持 JSON 的语言无法处理它们。JSON.stringify(..) 在对象中遇到 undefined 、function 和 symbol 时会自动将其忽略，在数组中则会返回 null（以保证单元位置不变）。 例如： 12JSON.stringify([1,undefined,function()&#123;&#125;,4]); // "[1,null,null,4]"JSON.stringify(&#123; a:2, b:function()&#123;&#125; &#125;); // "&#123;"a":2&#125;" 八、假值对象先看一段代码： 12345console.log(document.all) //会返回页面上的所有元素if(document.all)&#123; console.log("test") //不会答应 "test"&#125; 最常见的假值对象是 document.all ，它是一个类数组对象，包含了页面上的所有元素，由 DOM（而不是 JavaScript 引擎）提供给 JavaScript 程序使用。它以前曾是一个真正意义上的对象，布尔强制类型转换结果为 true ，不过现在它是一个假值对象。 虽然 JavaScript 代码中会出现假值对象，但它实际上并不属于 JavaScript 语言的范畴。但这里仍然有必要注意一下。 需要注意的是，为我们经常通过将 document.all 强制类型转换为布尔值（比如在 if 语句中）来判断浏览器是否是老版本的 IE，如下： 1if(document.all) &#123; /* it's IE */ &#125; 九、显式解析数字字符串解析字符串中的数字和将字符串强制类型转换为数字的返回结果都是数字。但解析和转换两者之间还是有明显的差别，参考如下代码： 1234567var a = "42";var b = "42px";Number( a ); // 42parseInt( a ); // 42Number( b ); // NaNparseInt( b ); // 42 解析允许字符串中含有非数字字符，解析按从左到右的顺序，如果遇到非数字字符就停止。而转换不允许出现非数字字符，否则会失败并返回 NaN 。 需要注意的是 parseInt() 针对的是字符串值。向 parseInt() 传递数字和其他类型的参数是没有用的，比如 true、function(){...} 和 [1,2,3]，因为非字符串参数会首先被强制类型转换为字符串，所以如下的代码就没有问题： 1parseInt( new String( "42") ); // 42 十、|| 和 &amp;&amp;|| 和 &amp;&amp; 运算符的返回值并不一定是布尔类型，而是两个操作数其中一个的值，参考如下代码： 12345678var a = 42;var b = "abc"; var c = null;a || b; // 42 a &amp;&amp; b; // "abc"c || b; // "abc"c &amp;&amp; b; // null 在 C 和 PHP 中，上例的结果是 true 或 false ，在 JavaScript（以及 Python和 Ruby）中却是某个操作数的值。 十一、假值的相等比较== 中的隐式强制类型转换最为人诟病的地方是假值的相等比较。 下面分别列出了常规和非常规的情况： 123456789101112131415161718192021222324"0" == null; // false"0" == undefined; // false "0" == false; // true -- 晕！"0" == NaN; // false"0" == 0; // true "0" == ""; // falsefalse == null; // false false == undefined; // false false == NaN; // falsefalse == 0; // true -- 晕！false == ""; // true -- 晕！false == []; // true -- 晕！false == &#123;&#125;; // false"" == null; // false"" == undefined; // false "" == NaN; // false "" == 0; // true -- 晕！"" == []; // true -- 晕！"" == &#123;&#125;; // false0 == null; // false 0 == undefined; // false 0 == NaN; // false0 == []; // true -- 晕！0 == &#123;&#125;; // false 为了更详尽的展现假值的相等比较的一些特殊情况，github 上的@dorey做了一个JavaScript-Equality-Table如下图： 其中绿色表示为 true ,白色表示为 false; 资源地址戳这里 密码:j9gp]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一次ios9的适配bug]]></title>
    <url>%2F2018%2F04%2F25%2F%E8%AE%B0%E4%B8%80%E6%AC%A1ios9%E7%9A%84%E9%80%82%E9%85%8Dbug%2F</url>
    <content type="text"><![CDATA[最近项目要上线，客户五月初等着要用，然后用ipad的ios9测试兼容性的时候又出了一些问题 然后排查发现是因为项目代码里使用了 es2017 的语法 Object.entries(),而 vue cli 配置的 .babelrc 如下： 123456789101112&#123; "presets": [ ["env", &#123; "modules": false, "targets": &#123; "browsers": ["&gt; 1%", "last 2 versions", "not ie &lt;= 8"] &#125; &#125;], "stage-2" ], "plugins": ["transform-vue-jsx", "transform-runtime"]&#125; 这并不会处理 es2017 的语法。 经过王二一番分析，于是有了如下五种解决方案： 1、改变遍历语法后台给我的数据结构类似如下： 12345&#123; '姓名':'王二', '年龄':23, '爱好':'敲代码'&#125; 我需要将这组对象的 key 和 value 都遍历出来： 我开始在vue里是这样遍历的： 1234&lt;div v-for="i in data"&gt; &lt;div&gt;&#123;&#123;Object.entries(i)[0][0]&#125;&#125;:&lt;/div&gt; &lt;div&gt;&#123;&#123;Object.entries(i)[0][1]&#125;&#125;&lt;/div&gt;&lt;/div&gt; 改成如下遍历： 123456&lt;div v-for="i in data"&gt; &lt;template v-for="(j,k) in i"&gt; &lt;div&gt;&#123;&#123;k&#125;&#125;:&lt;/div&gt; &lt;div&gt;&#123;&#123;j&#125;&#125;&lt;/div&gt; &lt;/template&gt;&lt;/div&gt; 问题也就解决了。 2、让后台改变数据结构王二认为，其实以上的数据结构并不合理，如果改成如下这种写法的话，前端遍历就方便多了： 12345678910[&#123; key: '姓名', value: '王二' &#125;,&#123; key: '年龄', value: 23 &#125;&#123; key: '爱好', value: '敲代码' &#125;] 3、写一个 Object.entries() 的polyfill没有 Object.entries() 这个语法，我们就来创造一个呗，方法如下： 123Object.entries = x =&gt; Object.keys(x).reduce((y, z) =&gt; y.push([z, x[z]]) &amp;&amp; y, []); 此方法参考自 stackoverflow 下 Randy 的回答 4、修改 .babelrc 配置文件听 stackoverflow 里的大神说，我们可以修改 .babelrc 配置文件来解决这个问题，修改如下： 1234&#123; "plugins": ["transform-runtime"], "presets": ["es2017"]&#125; 但是王二尝试了一下，没有成功。后来在github上发现了这个issue，似乎 babel-preset-es2017 也不会支持 Object.entries() ，于是就此打住。 5、引用 core-js/fn/object/entries经 stackoverflow 里的大神提醒，加上 require(&#39;core-js/fn/object/entries&#39;); 就能使用 Object.entries 了，试了试，还真管用。]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过js动态插入js和css代码]]></title>
    <url>%2F2018%2F04%2F23%2Fjs%E5%8A%A8%E6%80%81%E6%8F%92%E5%85%A5js%E5%92%8Ccss%2F</url>
    <content type="text"><![CDATA[最近遇到一个需求，不同的客户需要不同的定制登录页，但是又在同一个域名下。王二想了想，这或许可以通过js动态插入js和css代码来实现 大致思路是这样： 1、在登录页地址栏传一个参数，例如oid（不同客户的oid）不同； 2、js获取这个参数，然后再请求后台接口获得动态的js和css地址； 3、然后再加载相应的地址，加载方法如下： 12345678910111213141516171819202122232425262728293031//url是要加载的js地址，fn是加载完成后的回调函数function insertScript (url,fn) &#123; var heads = document.getElementsByTagName("head"), script = document.createElement('script'); script.setAttribute("type", "text/javascript"); script.setAttribute('src', url); script.onload = script.onreadystatechange = function () &#123; fn &amp;&amp; fn(); &#125; if(heads.length)&#123; heads[0].appendChild(script); &#125;else&#123; document.documentElement.appendChild(script); &#125;&#125;//url是要加载的css地址，fn是加载完成后的回调函数function insertCss (url,fn) &#123; var heads = document.getElementsByTagName("head"), link = document.createElement("link"); link.setAttribute("rel", "stylesheet"); link.setAttribute("type", "text/css"); link.setAttribute("href", url); link.onload = link.onreadystatechange = function () &#123; fn &amp;&amp; fn(); &#125; if(heads.length)&#123; heads[0].appendChild(link); &#125;else&#123; document.documentElement.appendChild(link); &#125;&#125; 4、注意到js和css加载完成后页面会重绘，这时候页面会一闪一下，很不美观。于是我们可以暂时先将页面隐藏起来，然后在加载完成后回调里再将页面显示出来，这样来看是比较好的解决方案。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记一个简单的样式布局二]]></title>
    <url>%2F2018%2F04%2F12%2F%E5%B0%8F%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%B8%83%E5%B1%80%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[开发中遇到一个样式布局，值得留意，王二在这里小计一下 开发时列表显示遇到这样两个需求： 表格的列数是动态的，管理后台设置几列，页面上就显示几列； 每一列的显示文字如果超出这一列则显示点点点 动态设置宽度，可以用弹性盒子 flex 来解决；显示点点点，可以用样式 text-overflow:ellipsis; 来搞定， 但是两个同时使用会出现一些问题，因为用 text-overflow:ellipsis; 显示点点点需要固定盒子的宽度，而恰好这里又是弹性盒子，所以这里用到了绝对定位来固定盒子的宽度， 于是有如下的示例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .main&#123; display: flex; width: 300px; height: 80px; border: 1px dashed gray; &#125; .main&gt;*&#123; border: 1px dashed orange; flex: 1; position: relative; &#125; .aa&#123; position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; &#125; .bb&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; &#125;&lt;/style&gt;&lt;div class="main"&gt; &lt;div&gt; &lt;div class="aa"&gt; &lt;div class="bb"&gt;显示点点点显示点点点显示点点点显示点点点&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class="aa"&gt; &lt;div class="bb"&gt;正常显示&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div&gt; &lt;div class="aa"&gt; &lt;div class="bb"&gt;正常显示&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果图如下： 后来发现以上样式在 Safiri 上显示有一些问题，于是将 aa 的样式修改如下，就兼容了： 12345678910.aa&#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; display: flex; align-items: center; justify-content: center;&#125;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue生产环境清除打印]]></title>
    <url>%2F2018%2F04%2F09%2Fvue%E7%94%9F%E4%BA%A7%E7%8E%AF%E5%A2%83%E6%B8%85%E9%99%A4%E6%89%93%E5%8D%B0%2F</url>
    <content type="text"><![CDATA[在生产环境显示打印很不好，而且会影响性能，那怎么去除生产环境的打印呢？王二这里有两个方法，感兴趣的同学可以进来看看 第一种方法我们可以直接在 src/main.js 里添加如下代码：1234window.log = console.log;if (process.env.NODE_ENV === 'production') &#123; window.log = ()=&gt;&#123;&#125;;&#125; 它会判断当前环境是开发环境还是生产环境，如果是生产环境，则将window.log 赋值给一个空函数。 需要注意的是，为了不影响生产环境原生window.console.log的使用，所以这里定义了一个window.log方法用来打印，所以以后代码里的打印用 log 而不是用 console.log。 第二种方法第二种方法则更加简单，其实在vue的手脚架中可以添加相应的配置项， 在 build/webpack.config.js 的 plugins 的 UglifyJsPlugin 里面添加如下配置项： 123456new webpack.optimize.UglifyJsPlugin(&#123; compress:&#123; warnings: false, drop_console: true //添加这行配置项 &#125;&#125;) 问题就被顺利搞定了]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小记一个简单的样式布局]]></title>
    <url>%2F2018%2F04%2F08%2F%E5%B0%8F%E8%AE%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E7%9A%84%E6%A0%B7%E5%BC%8F%E5%B8%83%E5%B1%80%2F</url>
    <content type="text"><![CDATA[开发中遇到一个样式布局，值得留意，王二在这里小计一下 以下代码的效果是：在一行中，一块的宽度是固定的，剩下的一块的内部是滑动的； 代码如下： 123456789101112131415161718192021222324252627282930313233343536&lt;style&gt; .z&#123; display: flex; box-sizing: border-box; border: 1 dashed gray; height: 100px; width: 200px; &#125; .a&#123; width: 50px; background-color: #ddd; &#125; .b&#123; flex: 1; white-space: nowrap; background-color: orange; overflow-x: auto; display: flex; &#125; .c&#123; margin: 5px; border: 1px dashed gray &#125;&lt;/style&gt;&lt;div class="z"&gt; &lt;div class="a"&gt; 固定宽度 &lt;/div&gt; &lt;div class="b"&gt; &lt;div class="c"&gt;滚动栏1&lt;/div&gt; &lt;div class="c"&gt;滚动栏2&lt;/div&gt; &lt;div class="c"&gt;滚动栏3&lt;/div&gt; &lt;div class="c"&gt;滚动栏4&lt;/div&gt; &lt;div class="c"&gt;滚动栏5&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果图如下：]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设置父元素透明度但不影响子元素透明度]]></title>
    <url>%2F2018%2F04%2F02%2F%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%E7%88%B6%E5%85%83%E7%B4%A0%E9%80%8F%E6%98%8E%E5%BA%A6%E4%BD%86%E4%B8%8D%E5%BD%B1%E5%93%8D%E5%AD%90%E5%85%83%E7%B4%A0%E9%80%8F%E6%98%8E%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[最近要画一个页面，需要设置父盒子有透明度，但是子盒子没有透明度，王二之前遇到过类似的因此遇到了点麻烦 王二一开始是类似下面这样写的： 1234div.father&#123; background-color: black; opacity: 0.75;&#125; 但是这样写的话,子元素会受到父元素 opacity 的影响，也会有0.5的透明度。这时候哪怕子元素的 opacity 设置为一也没有用，因为子元素的 opacity:1 也是在父元素的 opacity:0.5 的基础上设置的，因此子元素的 opacity 还是0.5。 后来的解决的方法如下： 123div.father&#123; background-color: rgba(255,255,255,0.75);&#125;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现复制到粘贴板]]></title>
    <url>%2F2018%2F04%2F02%2FJS%E5%AE%9E%E7%8E%B0%E5%A4%8D%E5%88%B6%E5%88%B0%E7%B2%98%E8%B4%B4%E6%9D%BF%2F</url>
    <content type="text"><![CDATA[最先项目上要实现点击一个按钮要复制一段内容到粘贴板上的功能，之前没有做过，上网查查浏览器还真有这样的API,以下做一个备忘 12345678910&lt;script type="text/javascript"&gt; function copyUrl() &#123; var Url2=document.getElementById("biao"); Url2.select(); // 选择对象 document.execCommand("Copy"); // 执行浏览器复制命令 &#125;&lt;/script&gt;&lt;textarea cols="20" rows="10" id="biao"&gt;用户定义的代码区域&lt;/textarea&gt;&lt;input type="button" onClick="copyUrl()" value="点击复制代码" /&gt;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue-router 实现验证登录]]></title>
    <url>%2F2018%2F04%2F01%2Fvue-router-%E5%AE%9E%E7%8E%B0%E9%AA%8C%E8%AF%81%E7%99%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近改版的项目上有一个需求，如果用户没有登录，则不能跳转到除登录页外的其他页面 刚开始王二打算用 vue-router 的全局前置守卫来判断是否允许用户跳转，如下： 12345const router = new VueRouter(&#123; ... &#125;)router.beforeEach((to, from, next) =&gt; &#123; // ...&#125;) 但用全局前置守卫需要进行很多判断，处理不好还很容易导致递归调用，王二调试了很长时间都没有处理好，很是苦恼。 后来王二试了试 vue-router 的全局后置守卫来进行跳转，处理起来还真他娘的简单，比全局前置守卫好用多了，那么就用它了，代码参考如下： 12345router.afterEach((to, from) =&gt; &#123; //如果未登录，则直接跳转到login页面 if(!store.state.isLogin)&#123; //从vuex里读取登录状态 router.push(&#123;name: 'Login'&#125;) &#125;&#125;)]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解JS中的this]]></title>
    <url>%2F2018%2F03%2F15%2F%E7%90%86%E8%A7%A3JS%E4%B8%AD%E7%9A%84this%2F</url>
    <content type="text"><![CDATA[今天来啃一个硬骨头，this 一、开始最近阅读《你不知道的javascript》，里面有关于 this 的详细介绍，王二受益匪浅，于是在这里做一个分享。 关于JS中的 this 到底是什么，知乎中轮子哥这样说到： this 在js的函数里面只是一个参数，是通过 Fuck.Shit(Bitches) 这种语法来传递的，点号前面的表达式就算 this。 轮子哥说的没错，通常来说，想要确定 this 就是寻找“函数被调用的位置”，但是这做起来并没有这么简单，因为某些编程模式可能会隐藏真正的调用位置。 划分到具体，js中有四条绑定规则来确定 this 的绑定对象。 二、四条绑定规则假设我们已经找到函数的被调用位置，我们还要确定用下面四条绑定规则中的哪一条，来确定 this 的绑定对象。在这里，王二首先会分别解释这四条规则，然后解释多条规则都可用时它们的优先级如何排列。 第一条规则：默认绑定1、默认绑定下 this 会指向全局对象 12345function foo() &#123; console.log( this.a ); &#125; var a = 2; foo(); // 2 2、但是如果使用严格模式（strict mode），那么全局对象将无法使用默认绑定，this 会绑定到 undefined,因此以上的代码会报错： 123456"use strict";function foo() &#123; console.log( this.a ); &#125; var a = 2; foo(); // TypeError: this is undefined 3、但是如果我们显式地用 window 调用 foo 函数，则以上代码不会报错： 123456"use strict";function foo() &#123; console.log( this.a ); &#125; var a = 2; window.foo(); // 2 这是因为我们应用了第二条规则——隐式绑定 第二条规则：隐式绑定如果一个函数中有 this ，这个函数有被上一级的对象所调用，那么 this 指向的就是上一级的对象；this 是在运行时被确定，而不是在定义时被确定。 1、参考如下代码： 12345678function foo() &#123; console.log( this.a ); &#125; var obj = &#123; a: 2, foo: foo &#125;;obj.foo(); // 2 2、this 指向的是被调用方法的上一级对象，而不是它的最外层对象， 参考如下代码： 123456789101112function foo() &#123; console.log( this.a ); &#125; var obj2 = &#123; a: 22, foo: foo &#125;; var obj1 = &#123; a: 12, obj2: obj2 &#125;; obj1.obj2.foo(); // 22 3、this 是在运行时被确定，而不是在定义时被确定， 参考如下代码： 12345678910function foo() &#123; console.log( this.a ); &#125; var obj = &#123; a: 2, foo: foo &#125;; var bar = obj.foo; // 函数别名！ var a = "oops, global"; // a是全局对象的属性bar(); // "oops, global" 4、在方法的参数中传入函数时也需要特别注意，传入函数的 this 也指向其方法被调用的上一级对象 参考如下代码： 123456789101112function foo() &#123; console.log( this.a ); &#125;function doFoo(fn) &#123; // fn其实引用的是foo fn(); // &lt;-- 调用位置！ &#125; var obj = &#123; a: 2, foo: foo &#125;; var a = "oops, global"; // a是全局对象的属性doFoo( obj.foo ); // "oops, global" 再例如： 123456789function foo() &#123; console.log( this.a ); &#125; var obj = &#123; a: 2, foo: foo &#125;; var a = "oops, global"; // a是全局对象的属性setTimeout( obj.foo, 100 ); // "oops, global" 在上面的的代码片段中，有时候我们就想打印 obj 中的 a 属性，这时候我们应该怎么修改呢？ 这就需要我们应用第三条规则——显式绑定 第三条规则：显式绑定以上的代码可以如下修改来访问到 obj 中的 a 属性： 123456789function foo() &#123; console.log( this.a ); &#125; var obj = &#123; a: 2, foo: foo &#125;; var a = "oops, global"; // a是全局对象的属性setTimeout( obj.foo.bind(obj), 100 ); // 2 这个代码片段中用了 bind（） 方法来显式修改 this 的指向，与 bind（） 方法有类似功能的还有 call（） 方法和 apply（） 方法，他们都可以改变 this的指向； 但是它们之间也有重要的区别：bind（） 是返回对应函数，便于稍后调用；call（） 、apply（） 则是立即调用 。关于这三个方法更详细的介绍，感兴趣的同学可以参考王二之前写过的一篇文章——JS中apply、call、bind的用法 第四条规则：new绑定参考如下代码： 12345function foo(a) &#123; this.a = a; &#125; var bar = new foo(2);console.log( bar.a ); // 2 使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。 创建（或者说构造）一个全新的对象。 这个新对象会被执行[[原型]]连接。 这个新对象会绑定到函数调用的 this 上。 如果函数没有返回其他对象，那么 new 表达式中的函数调用会自动返回这个新对象。 其中第二步操作，王二这里暂不讨论。 更具第一步和第三部操作，我们可以知道使用 new 来调用 foo(..) 时，我们会构造一个新对象并把它绑定到 foo(..) 调用中的 this 上。 关于第四步操作，我们需要额外注意，王二接下来提供一些示例代码以供参考（此代码来自‘追梦子’的博客）： 示例代码一: 1234567function fn() &#123; this.user = '追梦子'; return &#123;&#125;; &#125;var a = new fn; console.log(a.user); //undefined 示例代码二: 1234567function fn() &#123; this.user = '追梦子'; return function()&#123;&#125;;&#125;var a = new fn; console.log(a.user); //undefined 示例代码三: 1234567function fn() &#123; this.user = '追梦子'; return 1;&#125;var a = new fn; console.log(a.user); //追梦子 示例代码四: 1234567function fn() &#123; this.user = '追梦子'; return undefined;&#125;var a = new fn; console.log(a.user); //追梦子 也就是说：如果返回值是一个对象，那么 this 指向的就是那个返回的对象，如果返回值不是一个对象那么 this 还是指向函数的实例。 三、四条绑定规则的优先级现在我们可以根据优先级来判断函数在某个调用位置应用的是哪条规则。可以按照下面的顺序来进行判断： 1、 函数是否在 new 中调用（new绑定）？如果是的话this绑定的是新创建的对象。 1var bar = new foo() 2、 函数是否通过 call、apply、bind（显式绑定）调用？如果是的话，this 绑定的是指定的对象。 1var bar = foo.call(obj) 3、函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。 1var bar = obj.foo() 4、如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined ，否则绑定到全局对象。 1var bar = foo() 四、箭头函数里的this箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this 。 参考如下代码： 12345678910111213function foo() &#123; // 返回一个箭头函数 return () =&gt; &#123; //this继承自foo() console.log( this.a ); &#125;&#125; var obj1 = &#123; a:2 &#125;; var obj2 = &#123; a:3 &#125;; var bar = foo.call( obj1 ); bar.call( obj2 ); // 2, 不是3！ 如果将箭头函数换为普通函数，则打印的是3: 12345678910111213function foo() &#123; return function () &#123; console.log( this.a ); &#125;&#125; var obj1 = &#123; a:2 &#125;; var obj2 = &#123; a:3 &#125;; var bar = foo.call( obj1 ); bar.call( obj2 ); // 3 也就是说，箭头函数中的this 是函数在定义时被确定，而不是函数在运行时被确定的; 而普通方法中的 this 是在运行时被确定，而不是在定义时被确定的。 五、参考阅读你不知道的Javascript(上)（中文版） 密码:x7ge 阮一峰 es6tutorial 下的issue “追梦子”的博客 知乎关于this的问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS解出最近比较火的刑侦推理题]]></title>
    <url>%2F2018%2F03%2F15%2FJS%E8%A7%A3%E5%87%BA%E6%9C%80%E8%BF%91%E6%AF%94%E8%BE%83%E7%81%AB%E7%9A%84%E5%88%91%E4%BE%A6%E6%8E%A8%E7%90%86%E9%A2%98%2F</url>
    <content type="text"><![CDATA[晚上闲着无聊，来做一做最近比较火的刑侦推理题 最近网上出了一个比较火的刑侦推理题，王二比较感兴趣，于是抽空做了做。 一、推理题如下 二、遇到的问题刚开始，王二写下了如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199&lt;script&gt; var arr = new Array(10).fill("A"); recursion(); function a1 ()&#123; return true; &#125; function a2 ()&#123; switch(arr[1]) &#123; case "A": return arr[4] === "C" case "B": return arr[4] === "D" case "C": return arr[4] === "A" case "D": return arr[4] === "B" default: return false; &#125; &#125; function a3 ()&#123; switch(arr[2]) &#123; case "A": return arr[5] === arr[1] &amp;&amp; arr[5] === arr[3] case "B": return arr[2] === arr[1] &amp;&amp; arr[2] === arr[3] case "C": return arr[5] === arr[2] &amp;&amp; arr[5] === arr[3] case "D": return arr[5] === arr[1] &amp;&amp; arr[5] === arr[2] default: return false; &#125; &#125; function a4 ()&#123; var f1 = arr[0] === arr[4] , f2 = arr[1] === arr[6] , f3 = arr[0] === arr[8] , f4 = arr[5] === arr[9] ; switch(arr[3]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125; &#125; function a5 ()&#123; switch(arr[4]) &#123; case "A": return arr[7] === "A" case "B": return arr[3] === "B" case "C": return arr[8] === "C" case "D": return arr[6] === "D" default: return false; &#125; &#125; function a6 ()&#123; var f1 = arr[7] === arr[1] &amp;&amp; arr[7] === arr[3] , f2 = arr[7] === arr[0] &amp;&amp; arr[7] === arr[5] , f3 = arr[7] === arr[2] &amp;&amp; arr[7] === arr[9] , f4 = arr[7] === arr[4] &amp;&amp; arr[7] === arr[8] ; switch(arr[5]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125; &#125; function a7 ()&#123; var c1 = arr.filter((i)=&gt;&#123;return i === "A"&#125;).length , c2 = arr.filter((i)=&gt;&#123;return i === "B"&#125;).length , c3 = arr.filter((i)=&gt;&#123;return i === "C"&#125;).length , c4 = arr.filter((i)=&gt;&#123;return i === "D"&#125;).length ; switch(arr[6]) &#123; case "A": return Math.min(c1,c2,c3,c4) === c3 case "B": return Math.min(c1,c2,c3,c4) === c2 case "C": return Math.min(c1,c2,c3,c4) === c1 case "D": return Math.min(c1,c2,c3,c4) === c4 default: return false; &#125; &#125; function a8 ()&#123; switch(arr[7]) &#123; case "A": return Math.abs(arr[0].charCodeAt(0) - arr[6].charCodeAt(0))&gt;=2 case "B": return Math.abs(arr[0].charCodeAt(0) - arr[4].charCodeAt(0))&gt;=2 case "C": return Math.abs(arr[0].charCodeAt(0) - arr[1].charCodeAt(0))&gt;=2 case "D": return Math.abs(arr[0].charCodeAt(0) - arr[9].charCodeAt(0))&gt;=2 default: return false; &#125; &#125; function a9 ()&#123; var flag = arr[0] === arr[5], f1 = (arr[4] === arr[5]) === !flag , f2 = (arr[4] === arr[9]) === !flag , f3 = (arr[4] === arr[1]) === !flag , f4 = (arr[4] === arr[8]) === !flag ; switch(arr[8]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125; &#125; function a10 ()&#123; var c1 = arr.filter((i)=&gt;&#123;return i === "A"&#125;).length , c2 = arr.filter((i)=&gt;&#123;return i === "B"&#125;).length , c3 = arr.filter((i)=&gt;&#123;return i === "C"&#125;).length , c4 = arr.filter((i)=&gt;&#123;return i === "D"&#125;).length ; switch(arr[9]) &#123; case "A": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 3 case "B": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 2 case "C": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 4 case "D": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 1 default: return false; &#125; &#125; function vali () &#123; return a1() &amp;&amp; a2() &amp;&amp; a3() &amp;&amp; a4() &amp;&amp; a5() &amp;&amp; a6() &amp;&amp; a7() &amp;&amp; a8() &amp;&amp; a9() &amp;&amp; a10() ; &#125; //递归遍历arr的所有排列组合 function recursion ()&#123; if(vali())&#123; console.log(arr); &#125; for(var x=0 ; x&lt;arr.length ; x++)&#123; switch(arr[x]) &#123; case "A": arr[x] = "B" ; recursion () ; return ; case "B": arr[x] = "C" recursion () ; return ; case "C": arr[x] = "D" ; recursion () ; return ; case "D": if(x===9) return ; arr[x] = "A" ; continue ; default: return ; &#125; &#125; &#125;&lt;/script&gt; 以上的代码逻辑上没有问题，但是还是报了个错——栈溢出 虽然王二也试着用尾递归优化来尝试解决问题，但依然报错 三、解决方法后来王二躺床上又寻思怎么才能解决这恶心的报错，然后想到try catch 可以捕获错误，或许我们能递归调用 try catch 来解决这个问题。按照这个思路王二又在代码片段中添加了如下的代码： 12345678910111213var flag = true ;function run () &#123; try &#123; if(flag)&#123; flag = false ; recursion() ; &#125; &#125; catch (err) &#123; flag = true; run(); &#125;&#125; 意思是如果栈溢出报错，则在 catch 再次调用 run() 方法 ，直到它不报错为止，不报错也就意味着arr数组所有排列组合的可能性都被遍历完了。 执行后，还真他娘的起作用了。 完整的代码片段如下所示（可以拷贝下来尝试运行）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212&lt;script&gt; var arr = new Array(10).fill("A"); var flag = true ; run(); // ["B", "C", "A", "C", "A", "C", "D", "A", "B", "A"] function run () &#123; try &#123; if(flag)&#123; flag = false ; recursion() ; &#125; &#125; catch (err) &#123; flag = true; run(); &#125; &#125; function a1 ()&#123; return true; &#125; function a2 ()&#123; switch(arr[1]) &#123; case "A": return arr[4] === "C" case "B": return arr[4] === "D" case "C": return arr[4] === "A" case "D": return arr[4] === "B" default: return false; &#125; &#125; function a3 ()&#123; switch(arr[2]) &#123; case "A": return arr[5] === arr[1] &amp;&amp; arr[5] === arr[3] case "B": return arr[2] === arr[1] &amp;&amp; arr[2] === arr[3] case "C": return arr[5] === arr[2] &amp;&amp; arr[5] === arr[3] case "D": return arr[5] === arr[1] &amp;&amp; arr[5] === arr[2] default: return false; &#125; &#125; function a4 ()&#123; var f1 = arr[0] === arr[4] , f2 = arr[1] === arr[6] , f3 = arr[0] === arr[8] , f4 = arr[5] === arr[9] ; switch(arr[3]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125; &#125; function a5 ()&#123; switch(arr[4]) &#123; case "A": return arr[7] === "A" case "B": return arr[3] === "B" case "C": return arr[8] === "C" case "D": return arr[6] === "D" default: return false; &#125; &#125; function a6 ()&#123; var f1 = arr[7] === arr[1] &amp;&amp; arr[7] === arr[3] , f2 = arr[7] === arr[0] &amp;&amp; arr[7] === arr[5] , f3 = arr[7] === arr[2] &amp;&amp; arr[7] === arr[9] , f4 = arr[7] === arr[4] &amp;&amp; arr[7] === arr[8] ; switch(arr[5]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125; &#125; function a7 ()&#123; var c1 = arr.filter((i)=&gt;&#123;return i === "A"&#125;).length , c2 = arr.filter((i)=&gt;&#123;return i === "B"&#125;).length , c3 = arr.filter((i)=&gt;&#123;return i === "C"&#125;).length , c4 = arr.filter((i)=&gt;&#123;return i === "D"&#125;).length ; switch(arr[6]) &#123; case "A": return Math.min(c1,c2,c3,c4) === c3 case "B": return Math.min(c1,c2,c3,c4) === c2 case "C": return Math.min(c1,c2,c3,c4) === c1 case "D": return Math.min(c1,c2,c3,c4) === c4 default: return false; &#125; &#125; function a8 ()&#123; switch(arr[7]) &#123; case "A": return Math.abs(arr[0].charCodeAt(0) - arr[6].charCodeAt(0))&gt;=2 case "B": return Math.abs(arr[0].charCodeAt(0) - arr[4].charCodeAt(0))&gt;=2 case "C": return Math.abs(arr[0].charCodeAt(0) - arr[1].charCodeAt(0))&gt;=2 case "D": return Math.abs(arr[0].charCodeAt(0) - arr[9].charCodeAt(0))&gt;=2 default: return false; &#125; &#125; function a9 ()&#123; var flag = arr[0] === arr[5], f1 = (arr[4] === arr[5]) === !flag , f2 = (arr[4] === arr[9]) === !flag , f3 = (arr[4] === arr[1]) === !flag , f4 = (arr[4] === arr[8]) === !flag ; switch(arr[8]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125; &#125; function a10 ()&#123; var c1 = arr.filter((i)=&gt;&#123;return i === "A"&#125;).length , c2 = arr.filter((i)=&gt;&#123;return i === "B"&#125;).length , c3 = arr.filter((i)=&gt;&#123;return i === "C"&#125;).length , c4 = arr.filter((i)=&gt;&#123;return i === "D"&#125;).length ; switch(arr[9]) &#123; case "A": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 3 case "B": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 2 case "C": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 4 case "D": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 1 default: return false; &#125; &#125; function vali () &#123; return a1() &amp;&amp; a2() &amp;&amp; a3() &amp;&amp; a4() &amp;&amp; a5() &amp;&amp; a6() &amp;&amp; a7() &amp;&amp; a8() &amp;&amp; a9() &amp;&amp; a10() ; &#125; //递归遍历arr的所有排列组合 function recursion ()&#123; if(vali())&#123; console.log(arr); &#125; for(var x=0 ; x&lt;arr.length ; x++)&#123; switch(arr[x]) &#123; case "A": arr[x] = "B" ; recursion () ; return ; case "B": arr[x] = "C" recursion () ; return ; case "C": arr[x] = "D" ; recursion () ; return ; case "D": if(x===9) return ; arr[x] = "A" ; continue ; default: return ; &#125; &#125; &#125;&lt;/script&gt; 这样的写话栈溢出的问题似乎就比较完美的被解决了。 2018年04月27日补充： 其实那天晚上王二脑子进水了，其实这里没有必要用到递归调用，现修改代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193var arr = new Array(10).fill("A");while(recursion(arr)!=='done')&#123; vali() &amp;&amp; console.log(arr)&#125;function a1 ()&#123; return true;&#125;function a2 ()&#123; switch(arr[1]) &#123; case "A": return arr[4] === "C" case "B": return arr[4] === "D" case "C": return arr[4] === "A" case "D": return arr[4] === "B" default: return false; &#125;&#125;function a3 ()&#123; switch(arr[2]) &#123; case "A": return arr[5] === arr[1] &amp;&amp; arr[5] === arr[3] case "B": return arr[2] === arr[1] &amp;&amp; arr[2] === arr[3] case "C": return arr[5] === arr[2] &amp;&amp; arr[5] === arr[3] case "D": return arr[5] === arr[1] &amp;&amp; arr[5] === arr[2] default: return false; &#125;&#125;function a4 ()&#123; var f1 = arr[0] === arr[4] , f2 = arr[1] === arr[6] , f3 = arr[0] === arr[8] , f4 = arr[5] === arr[9] ; switch(arr[3]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125;&#125;function a5 ()&#123; switch(arr[4]) &#123; case "A": return arr[7] === "A" case "B": return arr[3] === "B" case "C": return arr[8] === "C" case "D": return arr[6] === "D" default: return false; &#125;&#125;function a6 ()&#123; var f1 = arr[7] === arr[1] &amp;&amp; arr[7] === arr[3] , f2 = arr[7] === arr[0] &amp;&amp; arr[7] === arr[5] , f3 = arr[7] === arr[2] &amp;&amp; arr[7] === arr[9] , f4 = arr[7] === arr[4] &amp;&amp; arr[7] === arr[8] ; switch(arr[5]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125;&#125;function a7 ()&#123; var c1 = arr.filter((i)=&gt;&#123;return i === "A"&#125;).length , c2 = arr.filter((i)=&gt;&#123;return i === "B"&#125;).length , c3 = arr.filter((i)=&gt;&#123;return i === "C"&#125;).length , c4 = arr.filter((i)=&gt;&#123;return i === "D"&#125;).length ; switch(arr[6]) &#123; case "A": return Math.min(c1,c2,c3,c4) === c3 case "B": return Math.min(c1,c2,c3,c4) === c2 case "C": return Math.min(c1,c2,c3,c4) === c1 case "D": return Math.min(c1,c2,c3,c4) === c4 default: return false; &#125;&#125;function a8 ()&#123; switch(arr[7]) &#123; case "A": return Math.abs(arr[0].charCodeAt(0) - arr[6].charCodeAt(0))&gt;=2 case "B": return Math.abs(arr[0].charCodeAt(0) - arr[4].charCodeAt(0))&gt;=2 case "C": return Math.abs(arr[0].charCodeAt(0) - arr[1].charCodeAt(0))&gt;=2 case "D": return Math.abs(arr[0].charCodeAt(0) - arr[9].charCodeAt(0))&gt;=2 default: return false; &#125;&#125;function a9 ()&#123; var flag = arr[0] === arr[5], f1 = (arr[4] === arr[5]) === !flag , f2 = (arr[4] === arr[9]) === !flag , f3 = (arr[4] === arr[1]) === !flag , f4 = (arr[4] === arr[8]) === !flag ; switch(arr[8]) &#123; case "A": return f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; !f4 case "B": return !f1 &amp;&amp; f2 &amp;&amp; !f3 &amp;&amp; !f4 case "C": return !f1 &amp;&amp; !f2 &amp;&amp; f3 &amp;&amp; !f4 case "D": return !f1 &amp;&amp; !f2 &amp;&amp; !f3 &amp;&amp; f4 default: return false; &#125;&#125;function a10 ()&#123; var c1 = arr.filter((i)=&gt;&#123;return i === "A"&#125;).length , c2 = arr.filter((i)=&gt;&#123;return i === "B"&#125;).length , c3 = arr.filter((i)=&gt;&#123;return i === "C"&#125;).length , c4 = arr.filter((i)=&gt;&#123;return i === "D"&#125;).length ; switch(arr[9]) &#123; case "A": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 3 case "B": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 2 case "C": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 4 case "D": return Math.max(c1,c2,c3,c4) - Math.min(c1,c2,c3,c4) === 1 default: return false; &#125;&#125;function vali () &#123; return a1() &amp;&amp; a2() &amp;&amp; a3() &amp;&amp; a4() &amp;&amp; a5() &amp;&amp; a6() &amp;&amp; a7() &amp;&amp; a8() &amp;&amp; a9() &amp;&amp; a10() ;&#125;function recursion(arr)&#123; for(var x=0 ; x&lt;arr.length ; x++)&#123; switch(arr[x]) &#123; case "A": arr[x] = "B" ; return arr; case "B": arr[x] = "C" return arr; case "C": arr[x] = "D" ; return arr; case "D": if(x===9) return 'done'; arr[x] = "A" ; continue ; default: return 'error'; &#125; &#125;&#125; 如此简单的问题王二那天想的那么复杂，也是醉了。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue单页应用如何在页面刷新时保留状态数据]]></title>
    <url>%2F2018%2F03%2F13%2FVue%E5%8D%95%E9%A1%B5%E5%BA%94%E7%94%A8%E5%A6%82%E4%BD%95%E5%9C%A8%E9%A1%B5%E9%9D%A2%E5%88%B7%E6%96%B0%E6%97%B6%E4%BF%9D%E7%95%99%E7%8A%B6%E6%80%81%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[在Vue单页应用中，如果在某一个具体路由的具体页面下点击刷新，那么刷新后，页面的状态信息可能就会丢失掉。这时候应该怎么处理呢？如果你也有这个疑惑，这篇文章或许能够帮助到你 一、问题现在产品上有个需求：单页应用走到某个具体的页面，然后点击刷新后，刷新的页面要与刷新前的页面要保持一致。 这时候就需要我们保存刷新之前页面的状态。 二、一种解决方案在这个Vue单页应用中，王二是用Vuex作为状态管理的，一开始王二的思路是将Vuex里的数据同步更新到localStorage里。 即：一改变vuex里的数据,便触发localStorage.setItem 方法，参考如下代码： 123456789101112131415161718192021222324252627282930import Vue from "vue"import Vuex from "vuex"Vue.use(Vuex)function storeLocalStore (state) &#123; window.localStorage.setItem("userMsg",JSON.stringify(state));&#125;export default new Vuex.Store(&#123; state: &#123; username: "王二", schedulename: "标题", scheduleid: 0, &#125;, mutations: &#123; storeUsername (state,name) &#123; state.username = name storeLocalStore (state) &#125;, storeSchedulename (state,name) &#123; state.schedulename = name storeLocalStore (state) &#125;, storeScheduleid (state,id) &#123; state.scheduleid = Number(id) storeLocalStore (state) &#125;, &#125;&#125;) 然后在页面加载时再从localStorage里将数据取回来放到vuex里，于是王二在 App.vue 的 created 钩子函数里写下了如下代码： 123localStorage.getItem("userMsg") &amp;&amp; this.$store.replaceState(JSON.parse(localStorage.getItem("userMsg")));//考虑到第一次加载项目时localStorage里没有userMsg的信息，所以在前面要先做判断 这样就能比较圆满的解决问题了。 三、另一种解决方案以上的解决方法由于要频繁地触发 localStorage.setItem 方法，所以对性能很不友好。而且如果一直同步vuex里的数据到localStorage里，我们直接用localStorage做状态管理好了，似乎也没有必要再用vuex。 这时候王二想，如果有什么方法能够监听到页面的刷新事件，然后在那个监听方法里将Vuex里的数据储存到localStorage里，那该多好。 很幸运，还真有这样的监听事件，我们可以用 beforeunload 来达到以上目的，于是王二在 App.vue 的 created 钩子函数里写下了如下代码： 1234567//在页面加载时读取localStorage里的状态信息localStorage.getItem("userMsg") &amp;&amp; this.$store.replaceState(JSON.parse(localStorage.getItem("userMsg")));//在页面刷新时将vuex里的信息保存到localStorage里window.addEventListener("beforeunload",()=&gt;&#123; localStorage.setItem("userMsg",JSON.stringify(this.$store.state))&#125;) 这样的话，似乎就比较完美了。]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单实现函数去抖与函数节流]]></title>
    <url>%2F2018%2F03%2F13%2F%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E5%87%BD%E6%95%B0%E5%8E%BB%E6%8A%96%E4%B8%8E%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[输入框里的值需要事实提交到后台，为了避免频繁发送请求，给服务端压力，王二使用了函数去抖 一、问题以下场景往往由于事件频繁被触发，因而频繁执行DOM操作、资源加载等重行为，导致UI停顿甚至浏览器崩溃。 window对象的 resize、scroll事件 拖拽时的 mousemove事件 射击游戏中的 mousedown、keydown事件 文字输入、自动完成的 keyup 事件 实际上对于 window 的 resize事件，实际需求大多为停止改变大小n毫秒后执行后续处理；而其他事件大多的需求是以一定的频率执行后续处理。针对这两种需求就出现了debounce 和 throttle 两种解决办法。 二、解决方法在函数库 underscore 里有函数去抖的实现方法，但是王二认为没有必要因此引用一个库，于是结合网上资料写了一个简单的函数去抖与函数节流的实现，参考如下代码(可以直接运行)： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;html&gt; &lt;input id="a" type="text"&gt; &lt;input id="b" type="text"&gt;&lt;/html&gt;&lt;script&gt; /** * 空闲控制 返回函数连续调用时，空闲时间必须大于或等于 delay，func 才会执行 * @param delay &#123;number&#125; 空闲时间，单位毫秒 * @param func &#123;function&#125; 请求关联函数，实际应用需要调用的函数 * @return &#123;function&#125; 返回客户调用函数 */ function debounce (func, delay) &#123; var timer return function (...args) &#123; timer &amp;&amp; clearTimeout(timer) timer = setTimeout(() =&gt; &#123; func.apply(this, args) &#125;, delay) &#125; &#125; /** * 频率控制 返回函数连续调用时，func 执行频率限定为 delay 毫秒一次 * @param delay &#123;number&#125; 延迟时间，单位毫秒 * @param func &#123;function&#125; 请求关联函数，实际应用需要调用的函数 * @return &#123;function&#125; 返回客户调用函数 */ function throttle (func,delay) &#123; var last = 0 return function(...args)&#123; var curr = +new Date() if (curr - last &gt; delay)&#123; func.apply(this, args) last = curr &#125; &#125; &#125; document.getElementById("a").addEventListener("input",debounce(() =&gt; &#123; console.log("函数去抖") &#125;, 500)) document.getElementById("b").addEventListener("input",throttle(() =&gt; &#123; console.log("函数节流") &#125;, 500))&lt;/script&gt; 三、参考文章“^_^肥仔John”的博客圆文章“anetin”的segmentfault文章]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《你不知道的Javascript》书中有趣的知识点一]]></title>
    <url>%2F2018%2F03%2F10%2F%E3%80%8A%E4%BD%A0%E4%B8%8D%E7%9F%A5%E9%81%93%E7%9A%84Javascript%E3%80%8B%E4%B9%A6%E4%B8%AD%E6%9C%89%E8%B6%A3%E7%9A%84%E7%9F%A5%E8%AF%86%E7%82%B9%2F</url>
    <content type="text"><![CDATA[最近在看《你不知道的Javascript》，里面有不少有趣的知识点，在这里做一个分享 一、LHS查询与RHS查询1、当变量出现在赋值操作的左侧时进行LHS查询，出现在右侧时进行RHS查询。 讲得更准确一点，RHS查询与简单地查找某个变量的值别无二致，而LHS查询则是试图找到变量的容器本身，从而可以对其赋值。从这个角度说，RHS并不是真正意义上的“赋值操作的右侧”，更准确地说是“非左侧”。 2、例如： 1console.log( a ); 其中对 a 的引用是一个RHS引用，因为这里 a 并没有赋予任何值。相应地，需要查找并取得 a 的值，这样才能将值传递给console.log(..)。 3、再例如： 1a = 2; 这里对 a 的引用则是LHS引用，因为实际上我们并不关心当前的值是什么，只是想要为 = 2 这个赋值操作找到一个目标。 4、LHS和RHS的含义是“赋值操作的左侧或右侧”并不一定意味着就是“=赋值操作符的左侧或右侧”。赋值操作还有其他几种形式，因此在概念上最好将其理解为“赋值操作的目标是谁（LHS）”以及“谁是赋值操作的源头（RHS）” 5、小测试，试试以下代码有几处LHS查询以及RHS查询： 12345function foo(a) &#123; var b = a; return a + b; &#125; var c = foo( 2 ); 答案是有3处LHS查询以及以及有4处RHS查询。 二、块作用域1、参考for循环的例子： 12345for (var i=0; i&lt;10; i++) &#123; console.log( i ); &#125;console.log( i ); //10 这时候在for循环内部使用（至少是应该只在内部使用）的变量i污染到整个函数作用域中了。 2、使用 let 可以避免这种情况： 1234for (let i=0; i&lt;10; i++) &#123; console.log( i ); &#125; console.log( i ); // ReferenceError 三、函数声明提升1、参考如下代码： 1234foo(); // hellofunction foo() &#123; console.log("hello")&#125;; 由于变量提升，以上函数能够正常运行。 2、再参考如下代码： 1234foo(); // 不是ReferenceError, 而是TypeError! var foo = function bar() &#123; console.log("hello")&#125;; 由于变量提升，foo在刚开始运行代码时便被申明，因此 foo() 不会导致 ReferenceError 。但是 foo 此时并没有赋值，因此抛出TypeError异常。 3、再参考如下代码： 12345foo(); // TypeError bar(); // ReferenceError var foo = function bar() &#123; console.log("hello")&#125;; 这里 bar() 报 ReferenceError 错是因为函数表达式不会被提升，即使是具名的函数表达式也是如此。 4、另外，一个普通块内部的函数声明通常会被提升到所在作用域的顶部，这个过程不会像下面的代码暗示的那样可以被条件判断所控制： 1234567foo(); // "b" var a = true; if (a) &#123; function foo() &#123; console.log("a"); &#125; &#125; else &#123; function foo() &#123; console.log("b"); &#125; &#125; 四、参考资料github’You-Dont-Know-JS’ 你不知道的Javascript(上)（中文版） 密码:x7ge]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>模块加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS模块加载简单实现]]></title>
    <url>%2F2018%2F03%2F10%2F%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[最近在看《你不知道的Javascript》，里面介绍了现代的JS模块机制，比较有趣，以下做一个分享 现在模块化加载常用的有三种书写规范 AMD,CMD,CommonJS, 今天暂不介绍这三种规范的差异, 而是通过代码简单介绍一下JS模块加载的实现原理。 代码如下（本代码大部分参考自《你不知道的Javascript》5.5.1）： 12345678910111213141516171819202122232425262728293031323334var MyModules = (function Manager() &#123; var modules = &#123;&#125;; function define(name, deps, impl) &#123; for (var i = 0; i &lt; deps.length; i++) &#123; deps[i] = modules[deps[i]]; &#125; modules[name] = impl.apply(impl, deps); &#125; function get(name) &#123; return modules[name]; &#125; return &#123; define: define, get: get &#125;;&#125;)();MyModules.define("bar", [], function () &#123; function hello(who) &#123; console.log("Let me introduce: " + who); &#125; return &#123; hello: hello &#125;;&#125;);MyModules.define("foo", ["bar"], function (bar) &#123; function world(who) &#123; bar.hello(who.toUpperCase()); &#125; return &#123; world: world &#125;;&#125;);MyModules.get( "bar" ).hello("wanger");MyModules.get( "foo" ).world("wanger"); 其中 MyModules 是实现模块加载的关键，它的核心是 modules[name] = impl.apply(impl, deps)。这样的话，我们就可以通过一个返回公共API的函数来定义 foo 和 bar 模块,foo 模块甚至接受 bar 的示例作为依赖参数，并能相应地使用它。 参考资料： github’You-Dont-Know-JS’ 你不知道的Javascript(上)（中文版） 密码:x7ge]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>模块加载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于scss的网页换肤实现]]></title>
    <url>%2F2018%2F03%2F09%2F%E4%BD%BF%E7%94%A8scss%E5%AE%9E%E7%8E%B0%E6%8D%A2%E8%82%A4%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[一直以为scss很强大，但是想不到会如此强大，在scss中可以进行一些逻辑判断，依据这个思路,基于这个思路，我们可以实现换肤 需要注意的是，这里的换肤指的是开发阶段的换肤。而不是在前端页面点击某个按钮，触发一些事件然后实现换肤。如果要在网页中实现换肤，我们需要事先需要的准备多套 CSS 样式表文件，当点击换肤按钮的是，使用 JS 来切换对应的 CSS 样式表。对于这种情况，王二在这里暂不讨论。 在这里，王二主要简单讨论 scss 逻辑判断的一些用法。 1、类似于在js中，在scss中也可以进行逻辑判断，代码如下： 1234567891011121314//定义主题颜色$theme-type : "boc"; //$theme-type : "other"; $theme:#0383ff; //这里$theme要提前申明，否则会报错@if $theme-type == "default" &#123; $theme:#0383ff;&#125;@if $theme-type == "other" &#123; $theme:#B6012E;&#125; 然后主题颜色可以直接引用这个 $theme 变量。 2、对于不同皮肤要用不同的背景图片，可以参考如下代码： 123456div.test&#123; height: 250px; @if $theme-type == "default" &#123; background:url("~@/assets/images/default/logo_login.png") no-repeat 50% 50% &#125;; @if $theme-type == "other" &#123; background:url("~@/assets/images/other/logo_login.png") no-repeat 50% 50% &#125;; background-size: contain;&#125; 3、再比如，我们想要通过不同的 $theme-type 显示不同的文字提示，这也不是什么大问题，参考如下代码： 12345678&lt;div class="test"&gt; &lt;div class="default"&gt; &lt;div&gt;默认文字&lt;/div&gt; &lt;/div&gt; &lt;div class="other"&gt; &lt;div&gt;其他文字&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; scss可以这样写： 123456789101112div.test&#123; &amp;&gt;div&#123; display: none; &amp;&gt;div&#123; text-align: center; padding-bottom: 12px; &#125; &#125; &amp;&gt;div.#&#123;$theme-type&#125; &#123; display: block; &#125;&#125; 这里可以用scss的插值语句 #{} 来动态的命名要显示的 class。 4、scss不仅可以 if 判断，还可以加减乘除、for循环，真滴很强大，感兴趣的同学可以参考scss文档。]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax加载动画弹出策略（后续）]]></title>
    <url>%2F2018%2F03%2F07%2Fajax%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%BC%B9%E5%87%BA%E7%AD%96%E7%95%A5%EF%BC%88%E5%90%8E%E7%BB%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[之前写过一篇文章ajax加载动画弹出策略,结合实际开发,还有一点没有考虑到,现在做补充说明 现在还需要注意到：多个ajax函数的请求方法时加载动画在第一个回调中就会被关闭掉，这样不符合逻辑，加载框需要在最后一个回调中再被关闭掉； 基于如上的考虑， 王二使用了 Promise.all() 方法，Promise.all()允许异步函数都返回结果后再触发相应的回调函数。Promise.all() 的用法可以参考如下代码： 123456789101112131415161718let p1 = ()=&gt;&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;let p2 = ()=&gt;&#123; return new Promise((resolve, reject)=&gt;&#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;// 同时执行p1和p2，并在它们都完成后执行thenlet start = ()=&gt;&#123; Promise.all([p1(), p2()]).then(results=&gt;&#123; console.log(results); // 获得一个Array: ['P1', 'P2'] &#125;);&#125; ;start(); 于是在项目中，王二又在Vue的原型链上修改了 _ajax 方法并添加了 _allAjax 方法，代码如下（不可以直接运行，但是可以参考其逻辑）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165/** 最小加载时长，如果请求时间过快，页面的加载动画会一闪一下很不美观。* * 用法参考以下 Vue.prototype._ajax 的用方法* */Vue.prototype._loadingMinTime = function (min=400) &#123; let now = Date.now(); return &#123; extraTime : ()=&gt;Math.max(min-(Date.now()-now),0), loadingTime : ()=&gt;Math.max(Date.now()-now,min) &#125;;&#125;/** axios的请求头配置* */Vue.prototype._axios = axios.create(&#123; headers: &#123; 'Content-Type': 'application/json', timeout: 3000, &#125;,&#125;)/** ajax函数的请求方法（对axios的简单封装）* * 封装目的：加入加载动画以及加载动画的最小加载时长，* 因为如果不加最小加载时长，如果请求速度过快，页面的加载动画会一闪一下很不美观。* * 需要注意到，方法中有一个startLoadingTime变量，* startLoadingTime 出现的原因是因为我们认为如果请求时间过短，就没有必要弹出加载动画，* 于是我们规定：如果ajax请求在一定时间内未完成（现在规定150毫秒），则出现最少显示400毫秒的加载框；** 用法参考如下：* this._ajax(&#123;* url : '/apis/evaluation/schedules',* datas : &#123;* type : type* &#125;,* success : (data)=&gt;&#123;* console.log(data);* &#125;,* fail : (err)=&gt;&#123;* console.log(err);* &#125;* &#125;)* */Vue.prototype._ajax = function (&#123; url='' , datas = &#123;&#125; , success = ()=&gt;&#123;&#125; , //含有一个data参数，为返回数据 fail = ()=&gt;&#123;&#125;, //含有一个error参数，为出错提示 method = 'get', //请求type，默认为 'get' 类型 showLoading = true, //是否显示加载框，默认显示 showLoadingClose = true,//显示框加载后是否自动关闭，默认自动关闭 testDelay = 0, //测试延迟，默认不传&#125;) &#123; let loading , loadingFlag = true, loadingTime = this._loadingMinTime(), // startLoadingTime 出现的原因是因为我们认为没有必要每次请求都带上加载动画，于是我们规定： // 如果ajax请求在一定时间内未完成（现在规定100毫秒），则出现最少显示400毫秒的加载框 startLoadingTime = 100 , actualAjaxTime = this._loadingMinTime(startLoadingTime); setTimeout(()=&gt;&#123; showLoading &amp;&amp; loadingFlag &amp;&amp; (loading = this._loading()); &#125;,startLoadingTime) this._axios(&#123; method: method, [method==='get' ? "params" : "data"]: datas, url: url, &#125;) .then(function (response) &#123; setTimeout(()=&gt;&#123; loadingFlag = false; if(actualAjaxTime.loadingTime()&gt;startLoadingTime)&#123; setTimeout(()=&gt;&#123; success(response.data,loading); showLoading &amp;&amp; showLoadingClose &amp;&amp; loading &amp;&amp; loading.close(); &#125;,loadingTime.extraTime()) &#125; else &#123; success(response.data,loading); &#125; &#125;,testDelay) &#125;) .catch(function (error) &#123; setTimeout(()=&gt;&#123; loadingFlag = false; if(actualAjaxTime.loadingTime()&gt;startLoadingTime)&#123; setTimeout(()=&gt;&#123; fail(error,loading); showLoading &amp;&amp; showLoadingClose &amp;&amp; loading &amp;&amp; loading.close(); &#125;,loadingTime.extraTime()) &#125; else &#123; fail(error,loading); &#125; &#125;,testDelay) &#125;)&#125;/** 多个ajax函数的请求方法（对Vue.prototype._ajax的简单封装）* * 封装目的：多个ajax函数的请求方法时加载动画会在第一个回调中被关闭掉。* 这样不符合逻辑，加载框需要在最后一个回调中被关闭掉，未了实现这个目的，我使用了Promise.all()方法；* ** 用法参考如下：* this._allAjax([&#123;* url : '/apis/evaluation/schedules',* params : &#123;* &#125;,* success : (data)=&gt;&#123;* console.log(data);* &#125;,* fail : (err)=&gt;&#123;* console.log(err);* &#125;,* &#125;,&#123;* url : '/apis/evaluation/schedules',* params : &#123;* &#125;,* success : (data)=&gt;&#123;* console.log(data);* &#125;,* fail : (err)=&gt;&#123;* console.log(err);* &#125;,* &#125;])* */Vue.prototype._allAjax = function (arr) &#123; Promise.all(arr.map(i=&gt;&#123; return new Promise( function (resolve, reject) &#123; Vue.prototype._ajax(&#123; url : i.url, params : i.params, success : (data,loading)=&gt;&#123; i.success(data); resolve(loading); &#125;, fail : (err,loading)=&gt;&#123; i.fail(err); resolve(loading); &#125;, testDelay : i.testDelay, showLoadingClose :false, &#125;) &#125;) &#125;) ).then(function (results) &#123; for (var x=0; x&lt;results.length; x++) &#123; if(results[x])&#123; results[x].close(); return &#125; &#125; &#125;);&#125;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Mock.js模拟数据请求]]></title>
    <url>%2F2018%2F03%2F06%2F%E4%BD%BF%E7%94%A8Mock-js%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[最近用vue重构公司项目，为了让前端独立于后端进行开发，王二尝试使用了 Mock.js 一、有什么用？Mock.js 可以生成随机数据，拦截 Ajax 请求 二、如何安装？1、在前端工程中，我们可以通过如下命令安装 1npm install mockjs 2、如果想在浏览器中测试，可以在自己的html中引用如下代码： 1&lt;script src="http://mockjs.com/dist/mock.js"&gt;&lt;/script&gt; 三、为什么能拦截 Ajax 请求对这个问题感兴趣的同学可以参考这个链接 四、生成随机数据Mock.js 的语法规范包括两部分： 数据模板定义（Data Temaplte Definition，DTD） 数据占位符定义（Data Placeholder Definition，DPD） 咱们不玩这些虚的，先看一些简单的例子： 说明：如果在自己的html中引用如下代码：&lt;script src=&quot;http://mockjs.com/dist/mock.js&quot;&gt;&lt;/script&gt;，以下测试代码可以直接运行 1、将一个字符串随机重复1到10遍 1234567Mock.mock(&#123; "string|1-10": "★"&#125;)// &#123;// "string": "★★★"// &#125; 2、将一个字符串随机重复5遍 1234567Mock.mock(&#123; "string|5": "★"&#125;)// &#123;// "string": "★★★★★"// &#125; 3、 随机生成一个布尔值，值为 true 的概率是 1/2，值为 false 的概率是 1/2 1234567Mock.mock(&#123; "boolean|1": true&#125;)// &#123;// "boolean": true// &#125; 4、从属性值 {} 中随机选取 2 个属性 123456789101112131415Mock.mock(&#123; "object|2": &#123; "310000": "上海市", "320000": "江苏省", "330000": "浙江省", "340000": "安徽省" &#125;&#125;)// &#123;// "object": &#123;// "310000": "上海市",// "330000": "浙江省"// &#125;// &#125; 5、从属性值 {} 中随机选取 2 到 4 个属性 1234567891011121314151617Mock.mock(&#123; "object|2-4": &#123; "110000": "北京市", "120000": "天津市", "130000": "河北省", "140000": "山西省" &#125;&#125;)// &#123;// "object": &#123;// "110000": "北京市",// "120000": "天津市",// "130000": "河北省",// "140000": "山西省"// &#125;// &#125; 6、从属性值 [{}, {} …] 中随机选取 1 个元素，作为最终值 12345678910111213Mock.mock(&#123; "array|1": [ &#123;title:"AMD"&#125;, &#123;title:"CMD"&#125;, &#123;title:"UMD"&#125;, ]&#125;)// &#123;// "array": &#123;// title:"CMD"// &#125;// &#125; 7、通过重复属性值 [{}, {} …] 生成一个新数组，重复次数大于等于 2，小于等于 3 123456789101112131415161718192021222324252627282930Mock.mock(&#123; "array|2-3": [ &#123;title:"AMD"&#125;, &#123;title:"CMD"&#125;, &#123;title:"UMD"&#125;, ]&#125;)// &#123;// "array": [// &#123;// "title": "AMD"// &#125;,// &#123;// "title": "CMD"// &#125;,// &#123;// "title": "UMD"// &#125;,// &#123;// "title": "AMD"// &#125;,// &#123;// "title": "CMD"// &#125;,// &#123;// "title": "UMD"// &#125;// ]// &#125; 8、传入一个正则，返回符合正则的字符串 1234567Mock.mock(&#123; 'regexp': /[a-z][A-Z][0-9]/&#125;)// &#123;// "regexp": "uD2"// &#125; 9、Mock对象中有一个 Random 方法，利用 Random 方法我们可以做很多事情： 12345678910111213141516var Random = Mock.RandomRandom.integer(20,100) //随机返回20到100的数字Random.float(60, 100, 3, 5) //随机返回60到100的带有3到5位小数的数字Random.string() //随机返回一个字符串Random.string(5) //随机返回一个长度为5的字符串Random.string(7, 10)//随机返回一个长度为5到7位的字符串Random.date()//随机返回一个日期Random.date('yyyy-MM-dd')//随机返回一个格式化日期Random.image()//随机返回一张图片Random.image('200x100')//随机返回一张带尺寸的图片Random.image('200x100', '#FF6600')//随机返回一张带尺寸和颜色的图片Random.paragraph()//随机返回一段文字Random.cparagraph()//随机返回一段中文文字Random.cparagraph(1, 3)//随机返回1到3段中文文字Random.csentence()//随机返回一句中文Random.ctitle()//随机返回一个中文标题 关于其更多的用法，感兴趣的同学可以参考官方示例代码； 五、拦截 ajax 请求的代码细节以jQuery为例： 123456789101112131415161718Mock.mock('http://test/api', &#123; 'name' : '[@name](/user/name)()', 'age|1-100': 100, 'color' : '[@color](/user/color)'&#125;);$.ajax(&#123; url: 'http://test/api', success: function(data)&#123; console.log(JSON.stringify(data, null, 4) )&#125;&#125;)// &#123;// "name": "Elizabeth Hall",// "age": 91,// "color": "#0e64ea"// &#125; 语法如下：Mock.mock( rurl, template ),其中的参数 rurl 还可以传入正则表达式。 关于其更多的用法，感兴趣的同学可以参考官方文档； 六、王二遇到的问题有了以上的各种方法，再加上嵌套，可以满足绝大多数我们想要的数据格式。但是因为使用姿势不正确，王二也遇到了一点小小的的问题， 例如如下代码： 123456789101112131415161718192021222324252627Mock.mock(&#123; 'list|2-10': [&#123; 'id': Random.integer(20,100), 'name':Random.ctitle(), 'date':Random.date("yyyy-MM-dd") &#125;]&#125;);// &#123;// "list": [// &#123;// "id": 57,// "name": "边且反认",// "date": "1989-08-12"// &#125;,// &#123;// "id": 57,// "name": "边且反认",// "date": "1989-08-12"// &#125;,// &#123;// "id": 57,// "name": "边且反认",// "date": "1989-08-12"// &#125;// ]// &#125; 王二原本的目的是想在 list 里返回数据不同的数组,但是用以上的写法数组里每个对象的数据都一样。 经过查阅文档，发现在 Mock 模板里属性的值可以是 Function,于是修改如下： 123456789101112131415161718192021222324252627Mock.mock(&#123; 'list|2-10': [&#123; 'id': ()=&gt;Random.integer(20,100), 'name': ()=&gt;Random.ctitle(), 'date':()=&gt;Random.date("yyyy-MM-dd") &#125;]&#125;);// &#123;// "list": [// &#123;// "id": 74,// "name": "但称青气",// "date": "2004-10-31"// &#125;,// &#123;// "id": 32,// "name": "三六属集",// "date": "2008-06-28"// &#125;,// &#123;// "id": 28,// "name": "装造始",// "date": "1975-04-29"// &#125;// ]// &#125; 这样就符合王二的预期了。 七、参考文章Mock官方网站Mock官方示例代码Mock官方文档‘think2011’的博客]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
        <tag>模拟数据</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ajax加载动画弹出策略]]></title>
    <url>%2F2018%2F03%2F05%2Fajax%E5%8A%A0%E8%BD%BD%E5%8A%A8%E7%94%BB%E5%BC%B9%E5%87%BA%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[最近用vue重构公司项目，遇到ajax加载动画弹出策略问题，以下做一个小记录 第一种策略：一般情况下，我们可以ajax发出请求前执行加载动画，再在回调中再关闭加载动画。但是这样做会有一个问题：如果请求速度过快，页面的加载动画会一闪一下，这样很不美观。 于是就有了第二种策略：我们可以设置一个最小的加载时长（例如400毫秒），假如ajax在400毫秒之内完成请求（假设278毫秒），则用 setTimeout() 延迟122毫秒再执行代码。 但是这种策略也有问题，就是：这样做的话每次请求都会有弹出框出现，我们认为，如果请求时间过短，就没有必要弹出加载动画。 于是就有了第三种策略：如果ajax请求在一定时间内未完成（例如150毫秒），则出现最少显示400毫秒的加载框； 根据第三种策略，王二写下了逻辑如下的代码（不可以直接运行，但是可以参考其逻辑）： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293/** 最小加载时长，如果请求时间过快，页面的加载动画会一闪一下很不美观。* * 用法参考以下 Vue.prototype._ajax 的用方法* */Vue.prototype._loadingMinTime = function (min=400) &#123; let now = Date.now(); return &#123; extraTime : ()=&gt;Math.max(min-(Date.now()-now),0), loadingTime : ()=&gt;Math.max(Date.now()-now,min) &#125;;&#125;,/** axios的请求头配置* */Vue.prototype._axios = axios.create(&#123; headers: &#123; 'Content-Type': 'application/json', timeout: 3000, &#125;&#125;),/** ajax函数的请求方法（对axios的简单封装）* * 封装目的：加入加载动画以及加载动画的最小加载时长，* 因为如果不加最小加载时长，如果请求速度过快，页面的加载动画会一闪一下很不美观。* * 需要注意到，方法中有一个startLoadingTime变量，* startLoadingTime 出现的原因是因为我们认为如果请求时间过短，就没有必要弹出加载动画，* 于是我们规定：如果ajax请求在一定时间内未完成（现在规定150毫秒），则出现最少显示400毫秒的加载框；** 用法参考如下：* this._ajax(&#123;* url : '/apis/evaluation/schedules',* datas : &#123;* type : type* &#125;,* success : (data)=&gt;&#123;* console.log(data);* &#125;,* fail : (err)=&gt;&#123;* console.log(err);* &#125;* &#125;)* */Vue.prototype._ajax = function (&#123; url='' , datas = &#123;&#125; , success = ()=&gt;&#123;&#125; , //含有一个data参数，为返回数据 fail = ()=&gt;&#123;&#125;, //含有一个error参数，为出错提示 method = 'get', testDelay = 0, //测试延迟，默认不传&#125;) &#123; let loading , loadingFlag = true, loadingTime = this._loadingMinTime(), // startLoadingTime 出现的原因是因为我们认为没有必要每次请求都带上加载动画，于是我们规定： // 如果ajax请求在一定时间内未完成（现在规定150毫秒），则出现最少显示400毫秒的加载框 startLoadingTime = 150 , actualAjaxTime = this._loadingMinTime(startLoadingTime); setTimeout(()=&gt;&#123; if(loadingFlag) loading = this._loading(); &#125;,startLoadingTime) this._axios(&#123; method: method, [method==='get' ? "params" : "data"]: datas, url: url, &#125;) .then(function (response) &#123; setTimeout(()=&gt;&#123; loadingFlag = false; if(actualAjaxTime.loadingTime()&gt;startLoadingTime)&#123; setTimeout(()=&gt;&#123; success(response.data); loading &amp;&amp; loading.close(); &#125;,loadingTime.extraTime()) &#125; else &#123; success(response.data); &#125; &#125;,testDelay) &#125;) .catch(function (error) &#123; fail(error); loading &amp;&amp; loading.close(); &#125;);&#125;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>易面打分端重构</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人情、面子与权利的再生产》读后感三]]></title>
    <url>%2F2018%2F03%2F04%2F%E3%80%8A%E4%BA%BA%E6%83%85%E3%80%81%E9%9D%A2%E5%AD%90%E4%B8%8E%E6%9D%83%E5%88%A9%E7%9A%84%E5%86%8D%E7%94%9F%E4%BA%A7%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B8%89%2F</url>
    <content type="text"><![CDATA[王二最近在读一本不错的书，它系统地、理论化的阐述了人情、面子以及中国式的人际关系 《人情、面子与权利的再生产》之情理社会中的社会交换方式作者提到：在情理社会中，人情的运作期待的不是直接利益最大化,里面还有许多非(直接)利益上的考虑。直接利益最大化是以“理性人”和“经济人”为假设的社会所追求的目标,而以“性情中人”和“社会人”为假设的社会追求的是另种目标。 比较理性人和性情人这两种假设的不同点,作者发现,经济人所要的最大利益是可以预期的,它从一个人的精力、技能和资本的投入中就可以预计获得多少回报;情理社会中的人情往来虽能预期应该会得到回报(这是理的含义),否则这在伦理和道理上是说不过去的。可复杂性在于,一个人无论如何投入,也不能预计会获得多少回报(这是情的含义)。 然而值得注意的是,情理社会的人虽不直接追求利益的最大化,但不能把人情交换理解成非理性,以为他们的人情交换中没有利益。其实,人情交换过程的委婉和迂回可能使人情的施予者获得比用理性预算出来的结果更大,也比赤裸裸(没有人情味)的利益谈判好处更多。否则中国市场中出现的大量人情投资便没有必要。当然由于它不可预计,也不排除得到回报较小或一无所获的可能。中国社会中的人情交往之所以发生这样的不确定性,是因为人们在根本上认为“情义”是无价的(但也可以根据情况定价),中国人不希望就事论事,而希望受惠者能理解这一件事的意味和用心，回报也不过是一种心意而已,而不能被理解成一般性的交易。 从理性上讲,资源交易总是倾向于最终能够在价值上得到衡量,甚至于诉诸法律来解决,包括精神赔偿费、人身保险费等都可以换算成价格。但人情来往上的互惠失败,却不是通过什么赔偿费来解决的。比如一个人对另一个人背信弃义,在传统中国人看来这些行同价格实在没有什么关系。因为中国人认为生活中有些东西是不能以价格来计算的,只能诉诸道德或生命来解决,以便让这个无情无义的人在舆论和道德谴责中一辈子感到良心不安,丢一辈子的脸。 另外，作者提到：通常情况下,中国人的人情交换有三种类型,一种是“感恩戴德型”的,即某人在遇到危难或紧急关头得到了他人的帮助,这在人情交往中属于“恩情”的范畴,对此困难提供帮助的人叫做“恩人”。另一种是比较有目的的“人情投资型”的,通常叫“送人情”。“送人情”的功能会导致接受的对方有亏欠或愧疚(也就是中国老百姓常讲的“不好意思”)感,造成双方构成一种“人情债”关系,结果在对方提出要求的时候不得不按对方的要求回报对方。第三种是一般性的“礼尚往来”型,也就是有来有往的互相走动、请客或过节时的送礼行为,以加强彼此的感情联络。 大体说来,中国人如此看重人情是因为人情可以给个人生活带来正向便利和改变,比如个人的成长和发迹、家族的兴旺和发达等都需要人情来打点和疏通。其中扯不清的就是人情与权力之间的关系。权力被理解为(或被赋予)可以在一特定位置上对其所管辖资源做任意控制和分配。在日程生活中，由于和掌权者有扯不清的人情关系，会导致掌权者义务性地介入某些事情，因此就可能在这些事情上获得权利的转让，从而实现权利的再生产。 另外需要注意的是,在中国社会,人情和面子同权力的勾连是有差异的。人情是在报和欠的过程中获得的权力,是交换的结果(比如送礼),具有封闭性的特点；而面子是在关系的关联中获得的权力,可以是无交换发生的结果,比如沾亲带故,如果一个人做的事业符合家族众人的期待,那么他不但自己感到非常荣耀,他的家人也会为他感到骄傲,并因此能分享他的荣誉和资源。 中国台湾社会学家文崇一也提到过：“有权的人,除了自己享受特权外,还会把权力分享给关系密切的家族和姻亲,由近及远;家族和姻亲也会联合起来分享权力,或要求分享权力。这已经变成一种习俗或社会规范,因为有些法律条文也承认这种分赃式的瓜分权力。这种透过家族和姻亲关系获取或保障既得利益的手段,是权力关系中种非常奇特的现象,我们通常把这种情形叫做裙带关系。中国人做了官或发了财,如果不给亲戚朋友一点好处,那才叫不懂人情世故,不会做人。 但它们彼此之间的共通之处是,无论它们如何运作,其效果都是为了建立与他人的特殊关系(有私交和交情)。就这一点而言,我们可以笼统地认为,中国人在情理社会中借助人情和面子的运作,放弃的是规则、理性和制度,得到的却是不可估量的社会资源、非制度性的社会支持和庇护及以势压人的日常权威。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人情、面子与权利的再生产》读后感二]]></title>
    <url>%2F2018%2F03%2F04%2F%E3%80%8A%E4%BA%BA%E6%83%85%E3%80%81%E9%9D%A2%E5%AD%90%E4%B8%8E%E6%9D%83%E5%88%A9%E7%9A%84%E5%86%8D%E7%94%9F%E4%BA%A7%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%BA%8C%2F</url>
    <content type="text"><![CDATA[王二最近在读一本不错的书，它系统地、理论化的阐述了人情、面子以及中国式的人际关系 《人情、面子与权利的再生产》之脸和面子的同质性以及异质性“面子”一直是任何一个在中国生活过的人或接触过中国人的人都能感受到的一种文化心理现象。19世纪末,自美国传教士明恩溥(A.Smith)在其轰动西方一时的《中国人的特征》一书中把它看做是中国人性格上的第一特征起,关于面子的研究由此拉开了序幕。1935年,林语堂在他的成名作《吾国与吾民》一书中以极为相似的观点认为,“面子”是统治中国人的三位女神中最有力量的一个,中国人正是为它而活着云云。 现在，我们都认识到了面子的重要性，然而,面子到底是什么东西，应该怎么去定义，中外学者没有一致的答案。例如，鲁迅认为,它是中国人的一种做戏的本领,是中国人的精神纲领。轮到林语堂界定时,他却一再声称面子这个东西,举例容易,下定义太难,只能说它是中国人社会交往中最细腻的标准。直至20世纪40年代,中国早期留美人类学家胡先晋开始从学理上对脸面分别施予了学术上的定义,认为“脸”和“面子”应该指两种不同的心理和行为。其中“脸”涉及的是中国人的道德品质，“面子”指的是由社会成就而获得的声誉。所以说有脸是自己挣的，面子是别人给的这一说法。 作者提到：“在他人取向下,传统中国人对别人对自己的批评与意见特别敏感,老是要顾全“面子”,要有“脸”,希望在他人的心目中保有良好的印象。同时,也希望与其他的个人(不限于家族以内的亲属)维持和谐而良好的关系,而不愿意得罪任何人。为了达到此一目的,同一个人可以在不同的社会情境下对不同的人讲不同的话即使前后的言谈不相一致,甚或互相矛盾,也在所不惜。换句话说,为了在不同的情况下与不同的人都能保持和谐的关系,常不得不说有违自已真实意见或感受的话。”这段话虽然没有区分脸和面子的含义,但实质上已表现了中国人在社会互动中对脸(自我形象)的放弃。 为了更加完整准确地理解脸和面子的区别和联系,作者制作了一个四分图来将中国人性格类型都包含其中： 象限一是儒家力图塑造的君子理想，它体现为“修身、齐家、治国、平天下”和“内圣外王”的统一以及对“人皆可以为尧舜”的希冀。理想同现实的巨大落差,导致了第四象限人的出现，他们懂得面子的带有圆滑和痞性,善于变通和交际，但是往往也会有违自己的真实意见去迎合他人。与第四类人相反的是第二类人，他们坚守传统儒家思想,刚正、讲原则、充满正义。但是在现实当中，却常常被讥讽为“不通人情事故”、“太正经”、“不会做人”等。 作者认为，很多人中国人“脸”与“面子”的分离,实质是儒家价值文化和中国现实文化之间的重大差距造成的。儒家在理想上想把人塑造成脸面观上的第一类人,但它在更大的程度上只成为一种人格理想,而其实际作用却是造就了接受或固守这一价值体系的人在现实社会中成为第二类人,并造成了中国人在价值观上强烈排斥第三、四类人(如小人和伪君子)。由于中国人情关系结构上的影响,中国人对价值层次上的认同回到行为层次上后却转向了第四类人,以此来获得更多的社会资源。结果,从价值观上看中国人的脸面观,中国人对第二类人作正面评价对第四类人作负面评价。但从现实社会上看中国人的脸面观,中国人反而对第二类人作负面评价,对第四类人作正面评价,由此造成第二类人在社会行动中的失落或边缘化,进而也出现他们中间一些人的痞化的倾向,以求得第四类人的社会优势。这同时也表明了第四类人是社会、政治、经济、文化及日常生活的最大受益者和实利者。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《人情、面子与权利的再生产》读后感一]]></title>
    <url>%2F2018%2F03%2F01%2F%E3%80%8A%E4%BA%BA%E6%83%85%E3%80%81%E9%9D%A2%E5%AD%90%E4%B8%8E%E6%9D%83%E5%88%A9%E7%9A%84%E5%86%8D%E7%94%9F%E4%BA%A7%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%E4%B8%80-%E4%B8%AD%E5%9B%BD%E4%BA%BA%E9%99%85%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[王二最近在读一本不错的书，它系统地、理论化的阐述了人情、面子以及中国式的人际关系 第一次听说《人情、面子与权利的再生产》是在大学时候，每当知乎上有一些好的书单推荐时，往往也不缺乏它的身影。可惜穷学生穷学生，大学时期王二不止一次找过这本书的电子版，可惜一直没有找到，图书馆里也找过，也没有这本书。现在毕业了，发了点工资，便买了一本纸质版的书。 这本书应该算是翟学伟先生的论文集，如果说当代中国有谁还在认真地做社会科学，翟学伟先生算一个。举例翔实、论点充分、旁征博引是这本书的特点，让王二一读起来就觉得作者是个社会学经历丰富、认真做学问的人。上一次有这种感觉，还是王二读费孝通老先生《江村经济》的时候。 但是本书也有一个缺点，就是太啰嗦。一个观点要被作者反复说个七八遍，就好像再程序里写了七八遍功能一样只是命名不同的方法，这谁会受得了。而且，阅读本书时王二似乎右回到了高中背政治课本的时候 – 一个论点下面有三个加粗的分论点，每个分论点下面有长长的一坨内容，我们要做的仅仅是在加粗的分论点下面画上横线，表示这是考试要考的内容，是需要着重记忆背诵的。至于下面那一坨里面讲的是什么，没人会在意。 虽然槽点不少，但是不能掩盖这本书充满创见的内容。王二认为本书有一下三点需要了解，第一、中国式人际关系模式；第二，脸和面子的同质性以及异质性；第三，情理社会中的社会交换方式。 对于以上三个方面的内容，除了第二个可能不太懂王二要说什么，对于其他两种，同学们多多少少都会有自己的答案。生活在中国这个大的环境下，生活在人情面子的关系往下，有时候，我们不得不考虑这些问题。结合本书，王二会尝试将每个同学结合自己特定场景经历得到的答案理论化学术化，以便未来能更加得心应手的处理人情面子相关的问题，这也是王二写这篇读后感的初衷。 需要注意的是，本书除了讲述中国式的人情、面子以及人际关系模式，还有一些偏政治方面的内容，例如中国式官僚作风的形成、中国地方与组织领导的权利游戏等等，对于这些内容，王二不太感兴趣，所以没有仔细阅读，也不打算写相关感想，所以这不是一篇完整的读后感。严谨一点的话，将文章标题改成《人情、面子与权利的再生产》选读后感似乎更合适。话又说回来，如有同学对这些感兴趣，想阅读本书的，可以随时联系王二。 由于内容比较多，王二会分三篇写出来，以下是第一篇。 《人情、面子与权利的再生产》之中国人际关系模式首先作者提到了中国人际关系的构成基础，作者认为有三点：中国人的天命观、家族主义、以儒家为中心的伦理思想。就像背政治一样，每一点下面都有一大段解释的内容，这里就不展开细讲了。 作者还提到：中国人际关系的基本模式是人缘、人情和人伦构成的三位一体,它们彼此包含又各有自身的功能。一般来说,人情是其核心,它表现了传统中国人以亲亲(家)为基本的心理和行为样式。人伦是这一基本样式的制度化,它为这一样式提供一套原则和规范,使人们在社会互动中遵守一定的秩序。而人缘是对这一样式的解释框架,它把人与人的一切关系都定在一种表示最终的而无须进一步探究的总体本源框架中。 我们需要着重注意的是作者提出的人际关系中的平衡性模式。 在文中，作者讲述了一个老师（我们称为甲）手术住院的案例，作者发现，甲在住院期间，当得知自己病房的其他病友给主刀医生和麻醉师塞红包时，自己也迫不及待的想给医生、麻醉师塞红包，甲一方面认为这样做是错误的，因为这种行为在医院制度上是被禁止的；但是另一方面认为这样做在维持平衡性上是必须的，甲要确保她能和病友在主刀医生和麻醉师的关系上保持相同的关系。对于主刀医生（我们称为乙）而言，如果乙没有收到红包或者拒绝收红包这一行为，那么他和甲的互动标准只是医院制度或者医德。但是当他接受了红包，那么他和甲之前的平衡性就会被打破，新的标准就变成了红包。这时候乙就需要对甲额外的关怀或者待遇以达到这一新的平衡。 作者认为,所谓讲究人情的策略之一正是在关系网络中对平衡性的维持。它表现为个体在某种标准压力之下而发生的要面子行为，同时也表现在关系结构上的给面子行为。维持住各人的面子正是维持住了平衡的关系,也就是讲了人情。而一且出现了失衡现象,就会意味着其中有人丢了脸或没有给面子。这同西方人所讲的情感有本质上的区别。例如这一个案中的病人就因自己没有给医生送红包而感到没有面子。因此,人情和面子的社会心理机就在于维系人际关系中的平衡性模式。 作者提到，以上所建立的人际关系平衡模式存在于中国社会的各个方面，正因为如此，它同时也是做人和做群体领导的一项重要策略。 在中国式人际交往过程中，还有两个显著的特点，一是在交往过程中的重情轻理的倾向；二是在礼尚往来中讲究的形式主义。 上面提到，人情是中国式人际交往的核心，它实际上是一种带有社会交换性的社会行为。由于农业社会的土地不能移以及以家庭为单位的自给自足经济,造成中国人在社会生活中的第一要务是要考虑怎样来保证人际关系的稳定和和谐。而这一保证又因人情中的血缘关系和儒家伦理的影响而倒向重情抑理。因为“情”字的内涵是义是适宜,是和气,而非利而“理”字往往包含利益、是非、章程、真假和道理等。所以“有了清官难断家务事”的说法，因为家庭范围之内用讲理的方式是不适宜的。说某人不近情理，也是“情”字在前，“理”字在后。说服某人也会常说“动之以情，晓之以理”。在我国法律中，也有“合情合理合法”这样的说法。 “情”的另一重要特点是他还受传统儒家“礼”的引导和规范，这一特点带来的结果是在礼貌客套上的相互牵制，并导致情面上的形式主义化。例如过节给有头绪的人送人情，过年给亲戚朋友相互发网络祝福语。这使得交往双方并不顾及对方是否真心还是假意，而仅需要体现人际交往方式上的必须和礼仪。构成了有中国特色的社会交换方式。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《寒冬夜行人》读后感--探寻生活的无限可能性]]></title>
    <url>%2F2018%2F02%2F26%2F%E3%80%8A%E5%AF%92%E5%86%AC%E5%A4%9C%E8%A1%8C%E4%BA%BA%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[探寻生活的无限可能性 前两天读完卡尔维诺的《寒冬夜行人》，一直想写点什么，但是迟迟下不了手。今天王二躺在床上，来了一些灵感，索性就随便写点什么。 首先来说，这本书很‘难读’，倒不是因为它烂（豆瓣评分8.7），而是在于它独特的叙事结构，这位意大利佬竟然给我们设置了十个小说的开头。 如果把每一篇都单独抽出来看，绝对一个个都是好的小说，可是作者却又在小说的最精彩的部分就停止了，因为印刷错误或者其他什么奇葩原因，小说的下文不见了，王二只能‘被迫’与作者一起去寻找每个小说的下半部分。每当找到线索，翻开书页时，却发现是一本于之前完全没关系的书，没办法，就先看着呗，可是当再次看到最精彩的部分，小说的下文又没了，然后又继续寻找。就这样，王二被来回‘折磨’了十次。 更要命每个故事里又会出现很多人物名称，所以你会发现王二会不停的前后翻阅小说，只是为了理清不同人物名称的人物关系。还好王二读的是电子版，看到没印象的人物名称可以全局搜索，读纸质版书的同学估计要比王二惨多了。 回归正题，读完整本书，王二能隐约感受到作者贯穿整个小说的主题–探寻小说的无限可能性，即探索文字之外的东西。就像作者在《在月光照耀的落叶上》片段里写到：“小说中未言明的东西比言明的东西更加丰富，只有让言明的东西发生折射才能想像出那些未言明的东西。” 作者在小说片段《向着黑魆魆的下边观看》里还写到：“那段故事我早晚会讲出来的，不过得在讲述其他故事时顺便讲出来，既不特别突出它，也不带有特殊的感情色彩，不过是愉快地去回忆它与讲述它。” 这种点儿不破的叙事技巧，其实是最能激发读者想象的。读完之后王二感叹原来小说还能这么写，故事情节还能这样展开。 之前在大学里度过王小波的《万寿寺》，也有过这种感觉。一个故事有无数种开始，无数个过程，像是进入一个迷宫，无数个十字路口，有如薛定谔状态的故事，让人找不到结局，然而到最后终究一个完整的故事。这个故事可以是这样，也可以是那样，拥有无限的可能性。就好似在平行世界里，亿万个王二也在上演不同的故事。 问题的关键在于，你是否能想象出生活还能有那样的可能性，关键在于你自己。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在sass中使用calc包含变量遇到的问题]]></title>
    <url>%2F2018%2F02%2F26%2F%E5%9C%A8sass%E4%B8%AD%E4%BD%BF%E7%94%A8calc%E5%8C%85%E5%90%AB%E5%8F%98%E9%87%8F%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[开工第一天，遇到一个小问题，在这里记录一下 问题描述今天重构项目写scss的时候,发现如果在 calc 包含变量，那么scss就不会正确的编译，例如下面这样的代码： 1234$bar-height:80px;.main&#123; height: calc(100% - $bar-height);&#125; sass最后并不会解析calc中的 $bar-height。 解决方法后来王二上网查资料在scss的官方文档里找到了解决方法（第6.7节） 这里需要用到scss的插值语句 #{} (Interpolation: #{}),例如上面的代码可以修改如下： 1234$bar-height:80px;.main&#123; height: calc(100% - #&#123;$bar-height&#125;);&#125; 文档中这样说到：‘#{} 插值语句也可以在属性值中插入 SassScript，大多数情况下，这样可能还不如使用变量方便，但是使用 #{} 可以避免 Sass 运行运算表达式，直接编译 CSS。’]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端备忘</tag>
        <tag>SCSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《穷爸爸富爸爸》读后感]]></title>
    <url>%2F2018%2F02%2F19%2F%E3%80%8A%E7%A9%B7%E7%88%B8%E7%88%B8%E5%AF%8C%E7%88%B8%E7%88%B8%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这本书给王二观念上比较大的改变 一、现金流游戏大学时候，王二玩过一款游戏–现金流游戏，游戏板上有两条路：一条在内部，一条在外部。游戏的目标是走出内部的路–我们称之为“老鼠赛跑”，进入到外面的路上，或叫“快车道”，并最终以投资获得的收益实现自己的“人生梦想”。和其他类似“大富翁”一样的游戏一样，在大多数玩家在实际生活中没有成为富人之前，这些游戏除了增加人们不切实际的财富梦想和纯粹的娱乐之外，似乎不能对人们的经济生活有任何帮组或者指导。但是当游戏的组织者向我们解释“老鼠赛跑”的含义时，王二被吸引住了： 如果你看看一般受过教育的、努力工作的人的生活，就会看到一条十分相似的道路。孩子出生了，然后去上学，自豪的父母十分兴奋，因为他们的孩子成绩十分出色，而且进了名牌大学。之后这孩子毕业了，也许继续深造，然后像编好的程序一样做下面的事：找个安全、稳定的工作，也许是个医生或律师，或参了军或进了政府部门。他开始挣钱了，信用卡开始蜂拥而至，而且开始购物，如果以前他还没有这样做过的话。 手里有了钱，这孩子去了其他年轻人喜欢去的地方。在那儿他开始结交女友，他们约会，不久结婚。现在生活一片大好，因为现代的社会里丈夫和妻子都工作，两份收入真是天堂。他们觉得获得了成功，前途光明，于是决定买房、买车、度假并且生孩子。这样一来问题就来了：需要大量的钱。那对幸福的夫妇认定他们的职业是最重要的，并且开始更加努力地工作，寻求升迁和加薪。加薪实现了，而另一个孩子的出生使他们需要一个更大的房子，他们不得不更努力地工作。他们成为了模范雇员，甚至于可以说有为公司献身的精神。他们又进了学校接受更多的培训以便让他们能赚更多的钱，也许他们干了两份工作。他们的收入上升了，但同时对他们的收入征的税和对他们新房子征的财产税也上升了，他们的社会保障税和其他税也上升了。他们得到了大额的工资单但迷惑于钱都到哪儿去了。他们买了些基金，而且用信用卡买了些杂货。孩子们长大了，为供他们上大学和为他们自己退休需要准备的钱也越来越多。 这对快乐夫妇，在35岁后陷入了‘老鼠赛跑’的陷阱。他们不停地为公司老板工作，通过缴税为政府工作，通过付住房贷款和信用卡贷款为银行工作，但等待他们的只是越来越多的债务和催款单，于是他们再加倍努力工作，再更多地获取债务，陷于财务紧张的怪圈不能自拔。 接着，他们建议他们的孩子努力学习，取得好成绩，找个安全的工作或职业。而对于钱，除了从那些想利用他们，从他们的天真中获得好处的人那儿学到点东西外，他们什么也没学。他们终生努力工作，然而随后这个过程又将在他们的下一代中重复了，这就叫‘老鼠赛跑’ 游戏的发明者罗伯特・T・清崎刚好也是《穷爸爸富爸爸》的作者，在本书中，作者详细介绍了如何跳出‘老鼠赛跑’圈的方法。 二、摘录以下是王二整理的一些摘录： 1、资产与负债书中作者区分资产与负债的方法相当与众不同，作者也提到，大部分会计师与财务专业人员不会同意这种定义方法。作者认为，资产就是能把钱放进你口袋里的东西，负债就是把钱从你口袋你取走的东西。例如一辆车，如果不开动他，但是每年还要为车子缴纳保险以及保养费用，实际上它就是你的负债。而一些不用多大资金投入，但是能带来可观现金流的项目，是作者追寻的宝贵的资产。 2、穷人与富人思维差异穷人穷观念，富人钱生钱 富人买入资产 穷人只有支出 中产阶级买入买入他们以为是资产的负债 3、真正的资产作者认为，真正的资产不需要本人到场即可开展业务，作者分为以下几列： 股票 债券 共同基金 产生收入的房地产 票据 专利权 任何其他有价值、可以产生收入或者可能增值并且有很好的流通市场的东西 结合中国国情，以及普通人可以触及到的业务范围，王二认为资产可以分为以下几列： 业绩好的股票 产生收入的房地产 合伙入股朋友的事业 虚拟产品自动化交易 无人售货商店 4、财商教育作者认为，在今天，仅仅建议孩子好好念书，将来找一份安全稳定的工作是危险的，大多数人会因此陷入这样的怪圈，获得收入，交税，还房贷，消费，继续获得收入，交税，还房贷，消费…很明显，他们陷入了“老鼠赛跑”的陷阱中。作者认为今天孩子需要更复杂的教育，而现在的教育体系并不足以供应这些。其中最需要教育的是财商教育，财商教育主要由以下四个主要技能组成： 财务知识。即阅读理解数字的能力。 投资战略。即钱生钱的科学。 市场、供给与需求。（作者引以为豪的一笔交易先是花费2000美元定金低价了入手了一栋破产拍卖的房屋，然后转手又以较高的价格零首付卖给了别人，但是作者向买主要了2500美元的手续费，买主也高兴地支付了。作者在书中说到：“我支付2万美元成本买入一幢房子，又以6万美元的价格卖出去，净赚的4万美元以买主开出的承兑汇票的形式流入我的资产项目。所有的工作时间累积起来只有5个小时。”） 法律规章。（真正的资本家会用财务知识借助公司合理避税，公司并不需要是一个真正的实体，它可以只是一些符合法律要求的文件。企业税率低于个人所得税，另外，公司的一些支出可以在税前获得抵减） 5、我们的危机这一点王二感同深受，作者的父亲受到过良好的教育（博士学位），工作很努力，也越来越具有竞争力，但是他也更深地陷入对自己专业特长的依赖之中。虽然工资收入增长了，可是选择的机会也消失了。这就好比职业运动员突然受伤或者年龄太大而无法再参加比赛，如果曾经的高收入工作失去，单一技能无法使他们另辟蹊径。 6、如何开始行动作者提到，在我们每个人的性格当中，既有勇敢、聪明、泼辣的一面，也有畏惧、愚昧和胆怯的一面，这就好像一些非常勇敢的顽强的英雄有时也会跪下来祈求上帝的恩赐。所以说性格重叠这是人之常情。 但是作者也提到，过分的畏难情绪和自我怀疑是浪费我们才能的最大因素，不要等待“好事情”自然发生，那需要等非常长的时间。和就好比在动身旅行之前非要等待前面五公里长的路上所有的红绿灯都变成绿色一样。 在本书的最后一章，作者建议了十个步骤来开发我们的潜能，感兴趣的同学可以戳下面的链接下载本书查看。 三、给王二的启示其实这本书给王二最大的启示是： 在自己的本职工作之外，增加自己的被动收入，至于如何增加被动收入，具体需要结合自己的行业来探索，这也是一门艺术。工作之余要分出精力去研究如何赚钱如何打造自己的资产。 另外另王二耳目一新的观念是作者对资产与负债与众不同的认知：资产就是能把钱放进你口袋里的东西，负债就是把钱从你口袋你取走的东西。 读书资源： 百度云(密码：9rw6)]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单了解fetch API]]></title>
    <url>%2F2018%2F02%2F13%2F%E4%BA%86%E8%A7%A3fetch-API%2F</url>
    <content type="text"><![CDATA[fetch() 允许我们发出类似于 XMLHttpRequest(XHR)的网络请求。 主要区别在于 Fetch API 使用 Promises ，这使我们避免了回调地狱，并且不需要再记住 XMLHttpRequest 的复杂API。 一、fetch() 与 XMLHttpRequest 的使用差异王二在这里放两个简单的示例来体现他们的使用差异，如下： 1、使用 XMLHttpRequest 请求数据 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;测试XMLHttpRequest请求&lt;/p&gt; &lt;script&gt; function reqListener() &#123; console.log(this.responseText); &#125; var oReq = new XMLHttpRequest(); oReq.onload = reqListener; oReq.open("get", "test.json", true); oReq.send(); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 2、使用 fetch 请求数据 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;测试Fetch请求&lt;/p&gt; &lt;script&gt; fetch('test.json').then(function(res) &#123; return res.text(); &#125;).then(function(data) &#123; console.log(data) &#125;); //箭头函数表达更清爽 //fetch("test.json").then(res=&gt;res.text().then(data=&gt;&#123;console.log(data)&#125;)) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 需要注意的是,以上代码需要在本地启动一个HTTPServer，并在示例代码的同一级目录下放一个test.json 才能正常演示。 二、fetch() 的具体语法1234567891011121314151617fetch(url, &#123; method: "POST", body: JSON.stringify(data), headers: &#123; "Content-Type": "application/json" &#125;, credentials: "same-origin"&#125;).then(function(response) &#123; response.status //=&gt; number 100–599 response.statusText //=&gt; String response.ok //=&gt; Boolean response.headers //=&gt; Headers response.url //=&gt; String return response.text()&#125;, function(error) &#123; error.message //=&gt; String&#125;) 如上述代码有两个地方需要注意： 1、 fetch() 可以接受第二个可选参数，一个可以控制不同配置的 init 对象，详细参数配置可以看这里 2、fetch()处理完promises之后会返回一个Response对象，我们会看到一些常见的 response 属性,例如: Response.status — 整数(默认值为200) 为response的状态码. Response.statusText — 字符串(默认值为”OK”),该值与HTTP状态码消息对应. Response.ok — 如上所示, 该属性是来检查response的状态是否在200-299(包括200,299)这个范围内.该属性返回一个Boolean值. response对象上还有一些常用的方法，例如，blob()、json()、text(),可以帮我们处理不同的数据类型，参考下图： 三、参考阅读：Fetch的MDN文档中文版 XMLHttpRequest的MDN文档中文版 谷歌开发者文档 “Introduction to fetch()” fetch API fetch documentation]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[王二的精神错乱症]]></title>
    <url>%2F2018%2F02%2F12%2F%E7%8E%8B%E4%BA%8C%E7%9A%84%E7%B2%BE%E7%A5%9E%E9%94%99%E4%B9%B1%E7%97%87%2F</url>
    <content type="text"><![CDATA[王二最近有问题 王二最近精神有点不正常，王二自己都感觉到了。王二知道，自己摊上大事了。 倒不是王二惹了什么杀生之祸，以王二过去的经验，出现这种症状无非三种有原因：第一种：快要过年了，又能和老同学吃饭洗澡吹牛逼了；第二种，王二的bug又改完了，又要开始躲着老板开始划水了；第三种：…; 好吧，王二编不下去了。你看看，你看看，精神错乱的王二连前期的铺垫都写不好了。 王二现在想发笑，写个文章要什么铺垫，又不是什么文学大师，写出来的东西有没有几个人看，还在这里卖关子。王二就直说了吧，王二恋爱了。 虽说恋爱是两个人的事情，没有必要说出来，但是王二发现自己恋爱时期蠢的厉害，就是一个二傻子，疯疯癫癫，宛如一个四脚着地的爬行动物。王二认为自己有必要记录下来这些心路历程，所以王二决定继续精神错乱地写下去。 请允许王二说自己傻，因为这是有迹可循的，接下来王二会具体说明。实际上，比王二傻的人大有人在，当初王小波追求李银河的时候比王二还要疯癫，李银河一个冷笑都要让小波怀疑半天人生，活像一个小学生，哭天抢地，每天还给李银河写信，现在整理成了书信集 –《爱你就像爱生命》。 这样来看，王二要比小波稳重一点，至少表面上如此。 不过，王二也好不到哪去。你知道吗，这些天王二醒来第一件事就是打开手机看你有没有留言。有时候敲代码会无缘无故地傻笑起来。想把身边的趣事和你分享，又害怕打扰到你，要是你十分钟不回王二，王二可要煎熬死了。王二又害怕每天和你聊天，把话题都聊完了，你就对王二腻味了。 王二知道，你也是这样想的。 我们就像两个小孩子，围着一个神秘的果酱，一点点地尝它，看看里面有多少甜。 说实话，王二有些两重人格，冷漠和稳重都是表面上的，内心呢，很幼稚和傻气，承认这一点有些不好意思，但是重现在开始，王二有必要向你坦诚相待。 王二也要道歉，以前对你不理不睬，还惹你生气，那是之前你我不熟悉。现在咱俩谁跟谁啊，要是再不理你王二直播跪搓衣板。 哦对了，王二最近也变的臭美起来了，每次洗完澡都要各种角度照镜子。王二计划接下来买个梳子，虽然王二有两年没有梳头了。 王二现在还养成一个习惯，就是想每天和你聊聊天，但是王二又害怕你会有负担，心里嘀咕：“这个王二烦死了，整天唠唠叨叨个不停，也不知道在说啥”，然后就跑了。王二有过前车之鉴，所以对于这一点，王二很是纠结。王二也想过给你写信，可惜没有小波的文采，想唱歌，可是嗓门实在不怎么样。要是有一天，你觉得腻了烦了，你一定要向王二抱怨：“傻王二，你还有没其他能耐，快给老娘露两手”，王二立马会狂奔到你面前逗你发笑。 总之，现在王二有了两件正事，代码和你，代码占49%，你占51%。 但愿我和你，是一支唱不完的歌。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>她</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解Puppeteer]]></title>
    <url>%2F2018%2F02%2F12%2F%E4%BA%86%E8%A7%A3Puppeteer%2F</url>
    <content type="text"><![CDATA[最近谷歌官方出了个挺火的库 – Puppeteer，我们来了解一下它 一、什么是 Puppeteer ?Puppeteer 是 Google Chrome 团队官方的无界面（Headless）Chrome 工具。Chrome 作为浏览器市场的领头羊，Chrome Headless 将成为 web 应用 自动化测试 的行业标杆。所以我们很有必要来了解一下它 无头浏览器是指没有窗口的浏览器 二、用它能做什么?通过 Puppeteer 我们可以让浏览器帮我们自动完成很多事情,例如 ： 生成页面的截图或者PDF 自动表单提交，UI测试，键盘输入 创建自动化测试环境 三、如何安装 Puppeteer ?安装 Puppeteer 很简单，如下： 12npm i --save puppeteer# or "yarn add puppeteer" 需要注意的是，由于用到了ES7的 async/await 语法 ，node 版本最好是v7.6.0或以上 四、一些实例1、屏幕截图12345678910const puppeteer = require('puppeteer');(async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('http://www.wangyulue.com'); await page.screenshot(&#123;path: 'wanger.png'&#125;); await browser.close();&#125;)(); 需要注意的是，Puppeteer将默认页面大小为800px x 600px，该大小定义了屏幕截图的大小。我们可以通过 Page.setViewport() 来设置截图页面大小。 2、将网页保存为PDF12345678910const puppeteer = require('puppeteer');(async () =&gt; &#123; const browser = await puppeteer.launch(); const page = await browser.newPage(); await page.goto('https://github.com/GoogleChrome/puppeteer/blob/master/docs/api.md', &#123;waitUntil: 'networkidle2'&#125;); await page.pdf(&#123;path: 'api.pdf', format: 'A4'&#125;); await browser.close();&#125;)(); 关于 page.pdf() 的更多可配置项，感兴趣的同学可以戳这里 3、模拟登录GitHub123456789101112131415161718/** * @desc Logs into Github. Provide your username and password as environment variables when running the script, i.e: * `GITHUB_USER=myuser GITHUB_PWD=mypassword node github.js` */const puppeteer = require('puppeteer')const screenshot = 'github.png';(async () =&gt; &#123; const browser = await puppeteer.launch(&#123;headless: true&#125;) const page = await browser.newPage() await page.goto('https://github.com/login') await page.type('#login_field', process.env.GITHUB_USER) await page.type('#password', process.env.GITHUB_PWD) await page.click('[name="commit"]') await page.waitForNavigation() await page.screenshot(&#123; path: screenshot &#125;) browser.close() console.log('See screenshot: ' + screenshot)&#125;)() 在GitHub上专门有一个 puppeteer 的demo集合库，感兴趣的同学可以戳这里了解 五、详细的 Puppeteer API关于 Puppeteer 详细的API文档，感兴趣的同学可以戳这里 六、参考阅读GoogleChrome/puppeteer Puppeteer 与 Chrome Headless —— 从入门到爬虫 Puppeteer API checkly/puppeteer-examples]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>Chrome</tag>
        <tag>自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Chrome快捷键使用小记录]]></title>
    <url>%2F2018%2F02%2F10%2FChrome%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这两天抽空了解了一下 Chrome 的快捷键，这里做一个记录 Chrome常用的快捷键标签页和窗口快捷键 快捷键 作用 ⌘ + t 打开新的标签页，并跳转到该标签页 ⌘ + w 关闭当前标签页 ⌘ + Shift + t 重新打开最后关闭的标签页，并跳转到该标签页 ⌘ + ←(或→) 跳转到历史记录上一页（或下一页） ⌘ + 1(至9) 跳转到特定标签页，⌘ + 9 跳转到最后一个标签页 开发快捷键 快捷键 作用 ⌘ + Shift + j 打开开发者工具 ⌘ + Shift + delete 打开清除浏览数据选项 ⌘ + r 重新加载当前网页 ⌘ + Shift + r 忽略缓存重新加载当前网页 网页快捷键 快捷键 作用 ⌘ + d 将当前网页保存为书签 ⌘ + Shift + d 将所有打开的标签页以书签的形式保存在新文件夹中 ⌘ + p 打印当前网页 ⌘ + o 使用Chrome打开计算机中的文件 ⌘ + l 将光标定位到地址栏 鼠标快捷键 快捷键 作用 ⌘ + 点击链接 在新的后台标签页中打开链接 ⌘ + Shift + 点击链接 在新的后台标签页中打开链接，并跳转到该链接 ⌥ + 点击链接 下载链接目标 相关推荐阅读： 谷歌官方文档(需要科学上网)]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[macOS快捷键使用小记录]]></title>
    <url>%2F2018%2F02%2F09%2FmacOS%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[这两天抽空了解了一下macOS的快捷键，这里做一个记录 macOS的常用快捷键截屏 快捷键 作用 ⌘ + Shift + 3 截取整个屏幕 ⌘ + Shift + 4 截取选择区域 ⌘ + Shift + 4 + 空格键 截取选择窗口 文件管理器 快捷键 作用 空格键 快速查看 ⌘ + I 显示简介 ⌘ + F 搜索 ⌘ + delete 删除 ⌘ + Shift +delete 清空回收站 通用 快捷键 作用 ⌘ + H 隐藏窗口 ⌘ + M 最小化窗口 ⌘ + O 打开 ⌘ + Shift + S 另存为 ⌘ + P 打印 ⌘ + Q 退出 F11 显示主屏幕 感兴趣的同学还可以参考以下图片：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>macOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VS Code快捷键使用小记录]]></title>
    <url>%2F2018%2F02%2F08%2FVS-Code%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[用 VS Code 开发有一段时间了，可是还没有好好地了解过它，这两天抽空先简单了解一下 VS Code 的一些常用快捷键 需要注意到是，以下内容是王二结合自己的使用体验，着重突出的一些个快捷键。关于 VS Code 快捷键更加全面的介绍，感兴趣的同学可以参考官方文档 VS Code 的常用快捷键页面内快捷键 快捷键 作用 ⌥ + up/down 移动行上下 Shift + ⌥ + up(或者down) 在当前行上下复制当前行 ⌘ + I 选中当前行 ⌘ + Shift + K 删除当前行 ⌘ + Enter 在当前行下插入新的一行 ⌘ + Shift + Enter 在当前行上插入新的一行 ⌘ + Shift + \ 匹配花括号的闭合处，跳转 ⌥ + Z 行代码过长全都可见 ⌥ + left（或者right) 跳过单词向前或向后 ⌥ + Shift + left（或者right) 选中跳过的单词向前或向后 ⌥ + Enter 选中所有出现在查询中的,结合⌘ + F使用 多行光标同时操作快捷键 快捷键 作用 ⌥ + Click 插入光标-支持多个 ⌘ + U 撤销最后一次光标操作 ⌘ + Shift + L 选择所有出现在当前选中的词或者行 ⌘ + D 匹配当前选中的词汇或者行，再次使用这个快捷键，可以匹配到下一个这个词或者行，并可以同时修改他们 ⌘ + K + ⌘ + D 结合上一个快捷键使用，如果有一个匹配到的词或者行你想跳过它们，就可以使用这个快捷键 语言操作快捷键 快捷键 作用 Shift + ⌥ + F 格式化代码 ⌘ + K + ⌘ + F 格式化选中部分的代码 F12 跳转到定义处 ⌥ + F12 代码片段显示定义 ⌥ + K + F12 在其他窗口打开定义处 Shift + F12 显示所有引用 ⌘ + K + ⌘ + X 移除空白字符 ⌘ + K + P 复制当前文件的存放路径 ⌘ + K + R 打开当前文件的存放位置 编辑器管理快捷键 快捷键 作用 ⌘ + Shift + [（或者]） 标签页左右切换 ⌥ + ⌘ + left（或者right) (与上面快捷键的作用相同)标签页左右切换 ⌘ + W 关闭当前页面 ⌘ + Shift + W 关闭编辑器 ⌘ + \ 切割编辑窗口 ⌘ + 1(或者2、3) 在不同的编辑窗口切换 ⌘ + J 打开或关闭控制台 ⌘ + B 侧边栏显示隐藏 ⌘ + Shift+P 展示全局命令面板 ⌘ + P 快速打开最近打开的文件 ⌘ + Shift + F 打开全局搜索 文件管理快捷键 快捷键 作用 ⌘ + N 新建文件 ⌘ + Shift + S 另存为 其他 快捷键 作用 ⌘ + K + ⌘ + S 查看所有快捷方式 ⌘ + Shift + V 预览Markdown文件 ⌘ + K + v 在边栏打开Markdown渲染后的视图 相关推荐阅读： VS code官方文档’Key Bindings for Visual Studio Code’ 掘金“CRPER”的文章《VS Code折腾记 - (2) 快捷键大全，没有更全》]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>VS Code</tag>
        <tag>快捷键</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vimium快捷键使用小记录]]></title>
    <url>%2F2018%2F02%2F07%2FVimium%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E5%B0%8F%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[Vimium是一款谷歌浏览器扩展程序，它继承了 Vim 中的常用操作，让我们在使用 Chrome 的过程中，无论是浏览网页、切换标签或是其它任何操作，全都可以只通过键盘完成。 Vimium 插件可以帮我们做到： 帮助您在不触摸鼠标的情况下浏览网页 使用巧妙的突出显示方法来使用链接进行导航 可自定义的键盘快捷键 有一个页面内的帮助对话框来提醒您个性化的快捷键 插件地址戳这里(需要科学上网) 需要注意到是，以下内容是王二结合自己的使用体验，着重突出的几个快捷键。关于 Vimium 快捷键更加全面的介绍，感兴趣的同学可以戳这里，或者戳这里 Vimium的常用快捷键1、页面操作 j:向下滚动一点 k:向上滚动一点 2、打开(关闭)页面 o(O):搜索查看收藏夹、历史记录中的页面，并打开（小写的o是在当前标签页打开，大写的O是在新标签页打开），如图所示： f(F):显示当前页面上所有可点击的链接，再输入相应字母就能打开这个页面（小写的f是在当前标签页打开，大写的F是在新标签页打开），如图所示： gi:将焦点聚集在第一个输入框(2gi就是第二个输入框) t:创建新标签页 x:关闭当前页面 X:恢复刚刚关闭的页面 3、切换标签页 J:切换到上个标签页 K:切换到下个标签页 4、当前页面 H:后退历史记录 L:前进历史记录 r:刷新页面 5、查看所有快捷键 ?:查看所有快捷键，如图所示： 推荐阅读： githubvimium.github.io知乎文章‘浏览器神器–Vimium’知乎回答‘如何优雅地使用 Vimium？’简书‘15分钟入门Chrome神器Vimium’]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>快捷键</tag>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊H5的pushState与replaceState]]></title>
    <url>%2F2018%2F02%2F01%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AH5%E7%9A%84pushState%E4%B8%8EreplaceState%2F</url>
    <content type="text"><![CDATA[之前一直不熟悉history上的pushState与replaceState方法，今天抽空了解一下，这篇文章很大一部分转载了MDN的Manipulating the browser history以及window.onpopstate中的内容，有兴趣的同学可以直接参考这些文章 一、简介HTML5引入了 history.pushState()_method) 和 history.replaceState()_method) 方法，它们分别可以添加和修改历史记录条目。这些方法通常与window.onpopstate 配合使用。 二、pushState() 方法的例子假设在 http://mozilla.org/foo.html 中执行了以下 JavaScript 代码: 12var stateObj = &#123; foo: "bar" &#125;;history.pushState(stateObj, "page 2", "bar.html"); 这将使浏览器地址栏显示为 http://mozilla.org/bar.html，但并不会导致浏览器加载 bar.html ，甚至不会检查bar.html 是否存在。 假设现在用户又访问了 http://google.com，然后点击了返回按钮。此时，地址栏将显示 http://mozilla.org/bar.html，同时页面会触发 popstate 事件，事件对象state中包含了 stateObj 的一份拷贝。页面本身与 foo.html 一样，尽管其在 popstate 事件中可能会修改自身的内容。 如果我们再次点击返回按钮，页面URL会变为http://mozilla.org/foo.html，文档对象document会触发另外一个 popstate 事件，这一次的事件对象state object为null。 这里也一样，返回并不改变文档的内容，尽管文档在接收 popstate 事件时可能会改变自己的内容，其内容仍与之前的展现一致。 三、pushState() 方法pushState() 需要三个参数: 一个状态对象, 一个标题 (目前被忽略), 和 (可选的) 一个URL. 让我们来解释下这三个参数详细内容： 状态对象 — 状态对象state是一个JavaScript对象，通过pushState () 创建新的历史记录条目。无论什么时候用户导航到新的状态，popstate事件就会被触发，且该事件的state属性包含该历史记录条目状态对象的副本。 标题 — 目前忽略这个参数被忽略，但未来可能会用到。传递一个空字符串在这里是安全的，而在将来这是不安全的。二选一的话，你可以为跳转的state传递一个短标题。 URL — 该参数定义了新的历史URL记录。注意，调用 pushState() 后浏览器并不会立即加载这个URL，但可能会在稍后某些情况下加载这个URL，比如在用户重新打开浏览器时。新URL不必须为绝对路径。如果新URL是相对路径，那么它将被作为相对于当前URL处理。新URL必须与当前URL同源，否则 pushState() 会抛出一个异常。该参数是可选的，缺省为当前URL。 四、pushState() 方法与设置hash值的区别在某种意义上，调用 pushState() 与 设置 window.location = &quot;#foo&quot; 类似，二者都会在当前页面创建并激活新的历史记录。但 pushState() 具有如下几条优点： 新的 URL 可以是与当前URL同源的任意URL 。而设置 window.location 仅当你只修改了哈希值时才保持同一个文件。 如果需要，可以不必改变URL就能创建一条历史记录。而设置 window.location = &quot;#foo&quot;;,只有在当前哈希不是 #foo 的情况下， 才会创建一个新的历史记录项。 我们可以为新的历史记录项关联任意数据。而基于哈希值的方式，则必须将所有相关数据编码到一个短字符串里。 五、replaceState() 方法history.replaceState() 的使用与 history.pushState() 非常相似，区别在于 replaceState() 是修改了当前的历史记录项而不是新建一个。 六、popstate 事件每当处于激活状态的历史记录条目发生变化时,popstate 事件就会在对应window对象上触发。 如果当前处于激活状态的历史记录条目是由history.pushState()方法创建,或者由history.replaceState()方法修改过的, 则popstate事件对象的state属性包含了这个历史记录条目的state对象的一个拷贝。 我们也可以直接在history对象上获取state，如下：1var currentState = history.state; 需要注意的是，调用 history.pushState() 或者 history.replaceState() 不会触发 popstate 事件。 opstate事件只会在浏览器某些行为下触发， 比如点击后退、前进按钮(或者在JavaScript中调用history.back()、history.forward()、history.go()方法)。 七、popstate 事件的例子假如当前网页地址为 http://example.com/example.html ,则运行下述代码后: 12345678910window.onpopstate = function(event) &#123; alert("location: " + document.location + ", state: " + JSON.stringify(event.state));&#125;;//绑定事件处理函数. history.pushState(&#123;page: 1&#125;, "title 1", "?page=1"); //添加并激活一个历史记录条目 http://example.com/example.html?page=1,条目索引为1history.pushState(&#123;page: 2&#125;, "title 2", "?page=2"); //添加并激活一个历史记录条目 http://example.com/example.html?page=2,条目索引为2history.replaceState(&#123;page: 3&#125;, "title 3", "?page=3"); //修改当前激活的历史记录条目 http://ex..?page=2 变为 http://ex..?page=3,条目索引为3history.back(); // 弹出 "location: http://example.com/example.html?page=1, state: &#123;"page":1&#125;"history.back(); // 弹出 "location: http://example.com/example.html, state: nullhistory.go(2); // 弹出 "location: http://example.com/example.html?page=3, state: &#123;"page":3&#125; 八、pushState()的用途王二使用 pushState() 主要是它可以监听到浏览器上的返回事件，这在移动端上也同样适用，参考如下一段代码(可以直接运行）： 1234567891011&lt;body&gt; &lt;div&gt;window.onpopstate可以监听到返回键事件&lt;/div&gt; &lt;script&gt; history.pushState(&#123;&#125;, ""); window.onpopstate = function(event) &#123; //这里可以监听到浏览器的返回事件，并做你想做的事情， //例如：跳转到另一个网页 location.href = "https://www.baidu.com"; &#125;; &lt;/script&gt;&lt;/body&gt; 当然，用 window.onhashchange 也可以监听到浏览器上的返回事件，参考如下一段代码(可以直接运行）： 12345678910111213&lt;body&gt; &lt;div&gt;window.onhashchange可以监听到返回键事件&lt;/div&gt; &lt;script&gt; setTimeout(()=&gt;&#123; location.hash="a" &#125;,100); setTimeout(()=&gt;&#123; window.onhashchange = function(event) &#123; location.href = "https://www.baidu.com"; &#125; &#125;,200); &lt;/script&gt;&lt;/body&gt; 九、参考文章‘pushState’、’replaceState’MDN文档(中文翻译版)‘onpopstate’MDN文档(中文翻译版)]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[卡尔维诺《树上的男爵》]]></title>
    <url>%2F2018%2F01%2F28%2F%E3%80%8A%E6%A0%91%E4%B8%8A%E7%9A%84%E7%94%B7%E7%88%B5%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[在大陆，王小波和阮一峰是卡尔维诺忠实的粉丝，阮一峰甚至还办了一个卡尔维诺中文站,而王二又是王小波和阮一峰的忠实粉丝，受他们的影响，王二早早知道了卡尔维诺的大名。今天，王二有幸读完了卡尔维诺的一本小说 –《树上的男爵》，结合豆瓣上的书评以及阮一峰之前写的一篇文章，王二在这里做一个分享 卡尔维诺《我们的祖先》三部曲作为对人的生存问题的考察，三部小说各有侧重。《不存在的骑士》是人争取存在，《分成两半的子爵》是人摆脱生命不完整的痛苦，《树上的男爵》则回答，人怎样才能找到一条生活的道路。 这个故事很简单：1767年6月15日，12岁的柯希莫因为忍受不了父亲阿米尼奥·迪·隆多男爵的专制，一气之下爬到了树上，并发誓不再下树。从此，直到65岁的柯希莫去世，他从未用双脚接触过地面哪怕一步。 小说写了男爵在树上五十多年中发生的一些重要事件，来反映他独一无二的树栖生活。这种生活多姿多彩，充满挑战。如果柯希莫没有爬上树，那么他的一生可能也就是过着贵族应该享受的中规中矩平庸安逸的生活了，但是他不接受这种地面上的生活，所以他爬上了树，决不下来。在树上，他打猎、读书、恋爱、旅行，他和各种各样的人交往，使一个凶残的大盗爱上了小说，他帮助小城建立了防火系统，挫败了土耳其海盗，打退了狼群的袭击；他广泛阅读，比同时代人更早的接受新思想，他与伏尔泰和卢梭通信，印刷自己的出版物，成为当地共济会的创始人，在大革命期间组织了当地的革命，成为市政委员会的一员，连拿破仑视察意大利的时候都慕名来拜访他。 《树上的男爵》中“树”是有象征的。柯希莫爬到树上这种行为也是有象征的。书上有两段话，就是很好的说明。先看这一段： “我哥哥认为，”我回答说，“谁想看清尘世就应同它保持必要的距离。”伏尔泰很欣赏这样的答复。 “从前，只是大自然创造生命现象，”他总结道，“现在是理智。” 再看这一段： 伯爵说：“你留在树上做什么事情呢？没有理由呀！” 柯希莫张开双臂：“我比你们早到这上面来，先生们，我也要留到最后！” “你要后退吗？”伯爵大声嚷。 “不，是抵抗。”男爵回答。 从这两段可以看出，小说中“树上的生活”和“地上的生活”是两个对立的概念。“地上的生活”象征平庸、世俗、乏味，“树上的生活”象征理想、高尚、富有精神性，“树上的生活”高于“地上的生活”。柯希莫爬到树上象征他不甘于平庸的生活，他坚持决不下树象征他不放弃自己的理想，用他自己的话说，这是一种“抵抗”。 小说中，柯希莫积极参加社会事务，并没有因为待在树上而遁世，但事实上他也不可能遁世，他追求自己的理想只能是局部的和修正的，而不可能是彻底的决绝的，准确的说，其中愿望和精神胜利的成分更多一些。柯希莫每到迷茫和郁闷的时候，就会爬到树的最顶端，向远方眺望，这个小说中一再提到的细节，是有着深刻寓意的。他没有放弃“抵抗”，但他也爬不到天上。 特别要提到的是柯希莫与薇莪拉的爱情，这无疑是本书最浓墨重彩的一笔。柯希莫与薇莪拉的第一次相遇分明是充满了浪漫主义色彩的。12岁的攀援于高大圣栎树的男爵柯希莫在阳光中俯瞰10岁的正在边啃着苹果边悠然荡着秋千的少女薇莪拉。她邀请他一起荡秋千。他拉着她在树上狂奔。他向她宣布树上的领土。她却是一个调皮的质疑者。相遇之后便是长达数十年的分离。 十年里，柯希莫与一个纯洁的女孩相爱过，也和很多勇敢的女人私会过。而薇莪拉有无数的风流韵事，她嫁过人，却最终成为一个寡妇。但是一次偶然的原因，命运再次将他们的生命会合。他们一同在树上攀援，他们疯狂地抱在一起，他们的内心因为爱情中的嫉妒而被撕扯，他们彼此诉说彼此倾听，他们忘记尘世，还有比这更透彻的爱情吗？ 然而到后来，两个人明明深爱着对方，却固执地说违心的话彼此伤害，用不正确和愚蠢的傲气伤害对方，她赌气离开之后，嫁给了一个英国贵族，再也没有回来。 结尾的时候，柯希莫老来病至，奄奄一息，人们把床架到树上，让他躺着，医生用梯子爬到树上给他看病，但柯希莫仍然不愿意这样被动的等待死亡。当一只热气球飞过树顶，他像个孩子一样一跃而起，抓住气球的锚绳，被它带着飞走了。这个结局为人物的塑造完成了最后一笔，这就是一个理想主义者的一生，他的生命中充满了寻找和探索，哪怕是死亡也无法让他改变。 通过柯希莫的一生，卡尔维诺想告诉我们什么呢？他为我们指出了一条什么样的生活道路呢？我想，可以这样说，生活的出路还是在现实中，但又高于现实，寻找这种出路本身就构成了生活的意义。寻找离不开勇气，而勇气又来自纯洁的理想。一个人如果在这些大的原则下度过自己的一生，那他的生命就不会虚度。 阅读链接： 阮一峰的“卡尔维诺中文站” 参考文章： 树上的男爵（豆瓣） 阮一峰“卡尔维诺《树上的男爵》”]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单介绍一下Progressive Web App(PWA)]]></title>
    <url>%2F2018%2F01%2F27%2F%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D%E4%B8%80%E4%B8%8BProgressive-Web-App-PWA%2F</url>
    <content type="text"><![CDATA[前段时间在公司的内部分享会上简单地介绍了一些关于PWA的技术，不过当时用的是思维导图版本的，现在整理成博客分享给大家 Progressive Web App(PWA)一、前期介绍1、王二为什么要将PWA作为本次的技术分享2017年11月份，谷歌在上海举办了一个开发者大会，期间在很多会场都有关于PWA的介绍，王二认为谷歌在致力于推行这项技术，那么技术上还是很先进的，于是有了如下分享。 2、简单介绍PWA的中文名叫做渐进式网页应用，早在2014年， W3C 公布过 Service Worker 的相关草案，但是其在生产环境被 Chrome 支持是在 2015 年。因此，如果我们把 PWA 的关键技术之一 Service Worker 的出现作为 PWA 的诞生时间，那就应该是 2015 年。 自 2015 年以来，PWA 相关的技术不断升级优化，在用户体验和用户留存两方面都提供了非常好的解决方案。PWA 可以将 Web 和 App 各自的优势融合在一起：渐进式、可响应、可离线、实现类似 App 的交互、即时更新、安全、可以被搜索引擎检索、可推送、可安装、可链接。 需要特别说明的是，PWA 不是特指某一项技术，而是应用了多项技术的 Web App。其核心技术包括 App Manifest、Service Worker、Web Push，等等。 3、为什么W3C和谷歌在推广这项技术这就要从前端的现状说起： Native APP 用起来很流畅，但是也有其天然的基因缺陷： 由于其天生封闭的基因，内容无法被索引 用户 80% 的时间被 Top3 的超级 App 占据，对于站点来说，应用分发的性价比也越来越不划算 要使用它，首先还需要下载几十兆上百着兆的安装包 WEB前端虽然天生具有开放的基因，但是很多时候页面会卡顿，用户体验不佳。虽然社区之前也做过很多努力，例如virtual dom、spa、混合编程、用canvas将整个页面画出来，用户体验也有了很大的改善，但是仍然无法解决几个重要的问题： 离线时用户无法使用 无法接收消息推送 移动端没有一级入口 W3C和谷歌看到了这些问题，于是推出了PWA。 4、PWA的核心目标PWA的核心目标就是提升 Web App 的性能，改善 Web App 的用户体验。媲美native的流畅体验，将网络之长与应用之长相结合。 二、特点1、PWA的特点PWA具有以下一些特点： 这边有一个关于PWA特点的列表清单，有兴趣的同学可以点进去看看. 2、特点详解（1）、可安装1、可安装指的是可以像原生APP在主屏幕上留有图标。 2、但是这需要我们提供 Web app manifest，manifest.json 是一个简单的JSON文件，我们在 html 页面如下引用他： 它描述了我们的图标在主屏幕上如何显示，以及图标点击进去的启动页是什么，它的JSON格式如下所示： 其中： start_url 可以设置启动网址 icons 会帮我萌设置各个分辨率下页面的图标 background_color 会设置背景颜色， Chrome 在网络应用启动后会立即使用此颜色，这一颜色将保留在屏幕上，直至网络应用首次呈现为止。 theme_color 会设置主题颜色 display 设置启动样式 关于manifest.json里字段更加具体的含义，感兴趣的同学可以参考MDN文档或者谷歌开发者文档里的这篇文章 3、实际上 豆瓣移动端就是一个PWA应用，如果我们用高版本的浏览器打开，就会发现有横幅提示，不过需要注意的是，IOS似乎还不支持，以下王二用安卓手机来做一个演示： 打开豆瓣后，浏览器会提示添加到主屏幕： 点击确定后，他会提示添加成功，然后在主屏幕上留有一个豆瓣的图标。 （2）、离线使用1、PWA 另一项令人兴奋的特性就是可以离线使用,其背后用到的技术是 Service worker ; 2、Service worker实际上是一段脚本，在后台运行。作为一个独立的线程，运行环境与普通脚本不同，所以不能直接参与 Web 交互行为。Service Worker 的出现是正是为了使得 Web App 也可以做到像 Native App 那样可以离线使用、消息推送的功能。 我们可以把Service worker当做是一种客户端代理， 3、我们来看看如何注册一个 Service Worker 关于Service Worker更加详细的介绍，感兴趣的同学可以参考MDN文档或者Github上的Basic Service Worker Sample这篇介绍。 4、 当然 Service Worker 也有生命周期，参考下图： 关于 Service Worker 生命周期的详细介绍可以参考下面这张图： 关于Service Worker 生命周期更加详细的介绍，感兴趣的同学可以参考MDN文档 （3）、消息推送消息推送具体可以参考谷歌的官方教程Your First Web Push Notification,里面有详细的代码Demo和说明，以及相应的后台配置（带好梯子）。 3、开发者如何了解是否具备这些特点说了这么多，那我们开发者如何了解一个网页是否具备了 PWA 的一些特点呢？ 这时候谷歌开发者工具可以帮上我们的忙，在 Chrome浏览器的开发者工具里有一个Audits面板，它可以帮我们检测网页是否具备了PWA的一些特点： 三、有哪些企业已经在使用PWA？1、国内已经有豆瓣、饿了么使用了部分PWA技术； 2、国外用PWA的企业相对较多，例如Twitter、Filpboard; 3、特别需要注意的是Twitter ，Twitter 在 2017 年上线了 Twitter Lite PWA，其获得了相当惊人的收益： 平均用户停留时长增长 65% Web 站点发推的数量增长 75% 跳出率降低 20% Twitter Lite 能取得这样的成绩，归功于 PWA 的新技术和用户体验至上的设计原则：它通过 Service Worker 缓存文件，让页面可以离线，同时降低网络消耗；通过 Web Push 接受服务器推送的消息；采用 App Shell 的设计模型，配合 Service Worker 能让页面瞬间展现。 4、另外一些采用了PWA的网站可以参考这个链接 四、代码细节1、代码可以参考的是谷歌的官方教程1、Your First Progressive Web App会帮我们了解如何从头构建一个PWA应用。2、Debugging Service Workers会辅导我们如何调试Service Worker。 2、缓存策略有缓存可以优化用户体验，但是如果没有合理的缓存策略，我们会发现我们的网站将会很难更新。 在用户重新加载新的Service Worker的时候，我们需要将之前旧的资源文件都删掉,如下图所示： 更多的缓存策略有兴趣的同学可以参考这篇文章 – The offline cookbook 3、官方工具除了前面提到的手工编写 Service Worker 脚本, Google 提供了 sw-toolbox 和 sw-precache 两个工具方便快速生成 service-worker.js 文件: sw-precache 可以用来生成配置使 PWA 在安装时进行静态资源的缓存 sw-toolbox 提供了动态缓存使用的通用策略, 这些动态的资源不合适用 sw-precache 预先缓存。 五、小结Progressive Web App仍处于初级阶段，国内普及度还不够，但我们不可忽视其背后的的技术，以及对前端全新的定位。或许它会像十年前的AJAX那样重新改变前端的生态。 参考文章（部分链接需要带好梯子）谷歌开发者网站关于PWA的搜索结果Your First Progressive Web AppExemplary Progressive Web App ChecklistThe offline cookbookYour First Web Push NotificationDebugging Service WorkersPWA网站清单列表PWA是否能带来新一轮大前端技术洗牌？PWA 入门: 理解和创建 Service Worker 脚本web-app-manifestBasic Service Worker Sample‘ServiceWorker’MDN文档‘ServiceWorker’MDN文档‘Using_Service_Workers’MDN文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>PWA</tag>
        <tag>Service Worker</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[不要自称为程序员]]></title>
    <url>%2F2018%2F01%2F27%2F%E4%B8%8D%E8%A6%81%E8%87%AA%E7%A7%B0%E4%B8%BA%E7%A8%8B%E5%BA%8F%E5%91%98%2F</url>
    <content type="text"><![CDATA[本文转自阮一峰的新书《前方的路》（官网，源码），这本书总结了阮一峰过去走过的人生道路。这篇文章转载自阮一峰2011年写的一篇文章 不要自称为程序员日期： 2011年10月31日 每年都有无数年轻程序员，加入软件行业。他们在学校里学过编程，但是对这个行业的现实一无所知。 Patrick McKenzie 是美国一家小软件公司的老板，他写了一篇长文，介绍这个行业的一些实际情况。我看了以后很感慨，有些地方很受启发。我选择了一部分，翻译如下。 一、90%的编程工作来自内部软件计算机专业的学生，可能有一种印象，觉得大部分程序员，都在编写公开出售的软件或者通用软件。 这种看法是不对的。大部分程序员，实际上编写的是不公开的企业内部软件，比如追踪费用的软件、优化装运成本的软件、帮助记账的软件、设计新部件的软件、计算保单价格的软件、识别恶意订单的软件等等。各种各样的商业公司，开发内部软件，解决它们自己的问题。市场上对程序员的大部分需求来源于此，只有极少数程序员直接编写面向外部顾客的软件。 内部软件的开发，通常非常乏味，令人厌倦。因为它们的技术复杂性低、技术决策非常保守、预算很少、缺乏长远考虑。但是，世界上大部分编程工作都是这种。 二、别人雇你的目的，是让你创造利润，不是让你编程商业公司最关心的（或者说唯一在乎的）事情，就是增加收入、降低成本。因此，它们实际上需要的不是程序员，而是能够帮助它们增加收入、降低成本的人。 开发优美的软件，解决技术难题，编写没有 bug 的代码，这些都不是商业公司的目的。它们雇佣你，是为了让你帮它们完成某个可以增加收入、降低成本的项目，而不是为了让你追求个人的软件成就。 你对于公司的唯一价值，就在于能多大程度上为它们增加收入、降低成本。 三、不要自称为程序员很多公司的经理不懂计算机，在他们心目中，程序员就是一群高成本的劳动力，只会在一台复杂的机器上干一些难懂的事情。 如果你自称为”程序员“，当公司需要压缩成本的时候，某些经理首先就会想到解雇你，因为你的工资高。有一家公司叫 Salesforce，口号是”没有软件“，意思就是如果经理们购买了他们的服务，就不再需要别的软件管理销售业务了，也就是说，不再需要自己雇佣程序员了。 正确的做法是，你应该把自己描述成与增加收入、降低成本有关系的人，比如”xx 产品的开发者“或”改进者“。有一个 Google Adsense 程序员的自我介绍，是这样写的：”Google 公司97%的收入，与我的代码有关。“ 四、不要限定自己年轻学生经常会问，应该选择哪种语言或平台？Java 是不是比 .NET 容易找工作？ 过分强调某一种语言或平台，都是不必要的。如果你把自己限定为 Java 程序员或 .NET 程序员，你就已经输了，因为首先你不应该自称为程序员（理由见上一点），其次这种限定使得你自动被排除在世界上大多数编程工作之外。 现实生活中，学会一种新语言，只需要几个星期，然后再过半年到一年，你就会变成老手。那时，根本没人在乎你以前用什么语言。 天才程序员是很少的，可是需要天才程序员的工作机会却很多很多，大多数场合都是需求远远大于供给。这意味着，即使你不是天才程序员，只要你是一个优秀工程师，那些招聘公司也会立刻录用你，因为它们知道招聘到天才程序员的机会微乎其微。（重复一遍，所谓“优秀工程师”，就是你的履历上有一连串增加收入、降低成本的记录。） 某些公司的人事部门，会根据某个关键词（比如 Java 或 .NET）过滤简历。虽然这样的公司根本不值得去，但是如果你真的想过这一关，也很容易：投入几个晚上和周末，在你当前的项目中设法用到这个关键词，然后再把它写进简历就行了。 五、如何提高求职时的谈判能力？（1）记住你不是在求职，不是在展示编程技巧，而是在推销某种商业问题（增加收入或降低成本）的解决方案。 （2）面试时，要有自信，要平等的对话。你要的是一个互利的录用合同，不要每次对方提出要求，你都说 Yes。 （3）雇主可能会问”你的上一份工资是多少“，他们其实在说”给我一个理由，压低你的报酬“。你要想好如何适当地回答这个问题。 （4）要还价。这里不仅仅指钱，还指其它你关心的方面。如果你无法要求更高的薪水，那就试着要求更多的假期。 （5）在对方决定录用你以后，才开始讨论薪水。因为那时，他们已经在你身上，投入了大量的时间和金钱，产生了一定的成本，此时他们可能觉得一些小问题已经不值得再纠缠了，比如每年的工资增加几千元。 六、创业公司是否适合应届毕业生？如果你一毕业就加入创业公司，最可能的结果是，接下来几年你都工作得非常辛苦，然后公司悲惨地失败了，你失业了，不得不又去另一家创业公司工作。 如果你真的想去创业公司，应该首先找一家大公司干上两年，攒一点钱，积累一些经验，然后精心挑选一家创业公司，再去实现自己的梦想。 在创业公司工作，一般情况下，你遇到的都是创业者。他们大多数人没有能力在两年后雇佣你；而在大公司工作，你遇到的都是其他大公司的人，他们中很多人将来有能力雇用你或者帮你介绍工作。 七、沟通技能是最重要的职业技能前面说过，工程师被雇佣，不是因为会编程，而是因为能够创造商业价值。所以，你得让人们相信你能创造价值，这是帮助你找到工作的最重要的能力。这种能力与你真的能创造多少价值，实际上联系不是很紧密。 我认识的一些最优秀的程序员，往往拙于表达。因此，别人不是不想与他们一起工作，就是低估了他们的价值。相反地，如果你看上去很会编程，并且很善于表达，别人就会真的这样看待你。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo渲染时排除部分目录]]></title>
    <url>%2F2018%2F01%2F26%2FHexo%E6%B8%B2%E6%9F%93%E6%97%B6%E6%8E%92%E9%99%A4%E9%83%A8%E5%88%86%E6%96%87%E4%BB%B6%E6%88%96%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[最近想再自己的Hexo博客上放一些js文件以便网络请求使用，却发现在Hexo里的js文件怎么引用都会脚本出错，后来才发现Hexo渲染时也会将这些js渲染进去，这时候我们就需要额外进行配置来跳过部分文件或目录的渲染 我们需要修改根目录下的 _config.yml 文件，其中又一个 skip_render 字段，假设 source 文件夹下有一个 assets文件夹 ,如果要将 assets 整个文件夹跳过渲染，就要进行如下配置： 12skip_render: - "assets/**" 当然还可以设置排除单个文件、多个文件或者有特定后缀的文件，感兴趣的同学可以参考这篇文章]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何将一个URL转为二维码并配上文字说明再将其转为图片下载下来]]></title>
    <url>%2F2018%2F01%2F26%2F%E4%B8%80%E4%B8%AA%E5%B0%86URL%E8%BD%AC%E4%B8%BA%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%B9%B6%E9%85%8D%E4%B8%8A%E6%96%87%E5%AD%97%E8%AF%B4%E6%98%8E%E7%9A%84js%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[最近公司业务有一个需求，在页面上需要将一个URL转为二维码并配上文字说明，并提供一个下载按钮，可以下载带有文字说明的二维码图片。 如果说只要一个二维码图片，Github上的qrcodejs库就能帮我们实现； 但是如果再加上文字说明，情况就变得有那么一丝复杂。 王二之前尝试过直接在canvas里绘画文字，但是canvas里文字不会换行，虽然可以通过js控制每行文字的数量来换行，但是文字有宽有窄，终究不是一个好的解决方案； 然后又上网找解决方案，然后听说用svg可以直接将一个div整个画出来。王二也尝试了，svg确实可以将div整个画出来，再导入到canvas里。这时候二维码和文字说明都在一张canvas里，而且文字实际上可以用css的样式来控制。但是在最后一步，将canvas转换为base64再导出图片的时候栽了跟头，在canvas里用svg画出来的部分最后转为图片的时候不会呈现，这条思路似乎又走不通了。 然后又上网找解决方案，最后在Github发现了html2canvas这个神奇的库，它可以将一个div绘画成canvas，那么思路也随之而来了。 王二写了如下的一串html代码，并对 qrcode、html2canvas 进行了一个简单的封装，以下代码可以直接运行，有兴趣可以直接拷贝到本地看看运行效果： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;meta charset="utf-8"/&gt;&lt;/head&gt;&lt;body&gt;&lt;div id="QRcode"&gt;&lt;/div&gt;&lt;a class="QR-download" href="#" download&gt;下载&lt;/a&gt;&lt;script src="http://www.wangyulue.com/assets/js/qrcode.js"&gt;&lt;/script&gt;&lt;script src="http://www.wangyulue.com/assets/js/html2canvas.min.js"&gt;&lt;/script&gt;&lt;script&gt; /** * 输出一个带有文字说明的二维码。 * * @param &#123;Object&#125; obj 相关配置， * obj = &#123; dom : "QRcode", // url : "http://www.wangyulue.com", //二维码网址 text : ["王玉略的个人网站","Stay Hungry, Stay Foolish."], //二维码的文字说明 pic_size : 300, // 图片的尺寸大小 font_size : 16, //说明文字的字体大小 &#125; * 回调函数中返回一个base64形式的图片，以便在回调中注入到&lt;a&gt;标签中下载使用 * */ function getQRcodeImg(obj,fn)&#123; var url = obj.url, size = obj.pic_size || 256; font_size = obj.font_size || 18; dom = document.getElementById(obj.dom); dom.innerHTML = generateHTML(obj.text,size,font_size); var $qrcode = dom.getElementsByClassName("QR-qrcode")[0], $main = dom.getElementsByClassName("QR-main")[0]; new QRCode($qrcode, &#123; text: url, width: size, height: size, &#125;); html2canvas($main).then(function(canvas) &#123; var base64 = concatCanvas(dom,$qrcode.getElementsByTagName("canvas")[0],canvas,20); fn &amp;&amp; fn(base64); &#125;); /** * 根据配置拼凑要处理的html代码 * * @param &#123;Array&#125; arr 要添加的文字，以数组传入 * */ function generateHTML(arr,size,font_size)&#123; var out = "",temp = ""; arr.forEach(function(item)&#123; temp += "&lt;div style='text-align:center;font-size:" +font_size+ "px;'&gt;"+ item +"&lt;/div&gt;" ; &#125;) out = "&lt;div style='position:absolute;opacity:0;'&gt;" + "&lt;div class='QR-main' style='width: " +size+ "px;'&gt;" + temp + "&lt;/div&gt;" + "&lt;/div&gt;" + "&lt;div class='QR-qrcode' style='display:none;'&gt;&lt;/div&gt;"; return out ; &#125; /** * 将两个canvas合并在一起 * * @param &#123;Object&#125; dom canvas要添加的dom对象 * @param &#123;Object&#125; canvas1 第一个canvas * @param &#123;Object&#125; canvas2 第二个canvas * @param &#123;Number&#125; padding 图片的padding，默认20 * @return &#123;String&#125; 返回base64字符串 * */ function concatCanvas(dom,canvas1,canvas2,padding)&#123; var c1h = canvas1.height, c1w = canvas1.width, // c2h = canvas2.height, // c2w = canvas2.width, /* 说明：将以上两行代码改为以下两行代码； * 原因：以上两行代码在window下显示是好的，但是放到Mac下显示会出一些问题， * 仔细发现是在Mac下,html2canvas的API返回的canvas不符合预期，在MAC环境canvas返回如下： * html2canvas($main).then(function(canvas) &#123; * console.log(canvas); //&lt;canvas width="600" height="88" style="width: 300px; height: 44px;"&gt;&lt;/canvas&gt; * &#125;); * 可以看到看到canvas的width和height值和其style里的width和height的值有所不同， * 于是采用以下的方法来获得canvas的宽度和高度 * 王二认为出现以上问题可能是因为分辨率的问题 */ c2h = Number(canvas2.style.height.slice(0,-2)); c2w = Number(canvas2.style.width.slice(0,-2)); canvas = document.createElement("canvas"); padding = padding || 20 ; /** 根据二维码、文字两个canvas，再加上padding计算出新的canvas的宽度和高度 **/ canvas.height = c1h + c2h + 2.5 * padding ; canvas.width = Math.max(c1w,c2w) + 2 * padding ; /** end **/ dom.appendChild(canvas); /** 将canvas画上白色背景 **/ context = canvas.getContext("2d"); context.fillStyle ="white"; context.fillRect(0,0,canvas.width,canvas.height); /** end **/ /** 将二维码、文字两个canvas绘画到一个canvas里 **/ context.drawImage(canvas1, padding, padding, c1w ,c1h); context.drawImage(canvas2, padding, 1.5 * padding+c1h, c2w ,c2h); /** end **/ /** 返回base64,用于注入到a标签里以便下载 **/ return canvas.toDataURL('image/jpeg',1); /** end **/ &#125; &#125; var obj = &#123; dom : "QRcode", url : "http://www.wangyulue.com", text : ["王玉略的个人网站","Stay Hungry, Stay Foolish."], pic_size : 300, font_size : 16, &#125; getQRcodeImg(obj,function(base64)&#123; document.getElementsByClassName("QR-download")[0].href = base64 ; &#125;); &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 下载后的图片就像下面这样： 对于很长的文字，它也能很完美的换行，并且图片的高度自适应，就像下面这样： 这样来看，这个需求算是被完美解决了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《大而不倒》读后感--回顾十年前的次贷危机]]></title>
    <url>%2F2018%2F01%2F21%2F%E3%80%8A%E5%A4%A7%E8%80%8C%E4%B8%8D%E5%88%B0%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F-%E5%9B%9E%E9%A1%BE%E5%8D%81%E5%B9%B4%E5%89%8D%E7%9A%84%E6%AC%A1%E8%B4%B7%E5%8D%B1%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[最近读完《大而不倒》这本书，结合之前看过的《大而不倒》、《监守自盗》这两部纪录片，感受颇深，以下做一个分享 今年是2018年，离2008年的金融危机已经过去十年了。很多同学恐怕只知道08年有金融危机这一回事，但是很少有了解其中的前因后果。如果是这样，那么你有必要读一读这篇文章。 这篇文章将尝试讨论以下几个问题： 1、金融危机发生的前因后果2、美国政府在危机中扮演了什么角色？3、为什么大型企业在金融危机中走到了“大而不倒”的境地 需要注意的是，王二以下的观点仅仅是根据书中的内容以及网上查阅的相关文章得出来的，所以难免会有理解上的偏差。如果有说的不对的地方，还有望多多赐教。 一、主要标志性事件1、2007年2月，汇丰银行宣布北美住房贷款按揭业务遭受巨额损失，减记108亿美元相关资产，次贷危机由此拉开序幕； 2、2007年6月7日，美国第五大投行贝尔斯登宣布，旗下两只对冲基金停止赎回； 3、2007年8月6日，美国住房抵押贷款公司宣布破产； 4、9月17日，格林斯潘首次公开对外承认，美国房市存在泡沫，且房价存在很大的下降比率； 5、从2007年9月至到2008年4月，美联储连续7次降息，将基准利率由5.25%大幅削至2%； 6、2008年1月24日，美国房地产经济人协会宣布，2007年美国旧房销售量下跌了13%，为25年来最大降幅；旧房中间价下跌了1.8%，为每套21.78万美元，为1968年有相关记录以来首次出现年度下跌； 7、3月16日，贝尔斯登估价从每股77.32美元，短短几天到以每股2美元的“跳楼价”将自己卖给了摩根大通银行； 8、2008年7月中旬，美国房地产抵押贷款巨头“两房”遭受700亿美元巨额亏损，最终被美国政府接管。 9、9月7日，美国政府再度出手，出资2000亿美元接管“两房”； 10、9月15日，美国第四大投银行雷曼兄弟(Lehman Brothers)宣布破产； 11、9月17日，美联储被迫对AIG提供高达850亿美元的紧急贷款，避免该公司陷入破产； 12、9月20日，美国政府正式向国会提交7000亿金融救援计划； 13、10月3日，国会通过了《2008经济稳定紧急法案》，该法案将推进7000亿美元的问题资产救援计划，即TARP（The Troubled Asset Relief Program）。 二、危机发生的原因1、大萧条时期在大萧条时期，罗斯福政府成立房利美（Fannie Mae）作为其新政的一部分，为低收入家庭提供住房抵押贷款。也就是从这个时候开始，美国政府通过房利美，以及后来成立的房地美间接的影响着房地产市场。 这一时期国会通过了“格拉斯·斯蒂格尔”法案，旨在防止银行利用储蓄存款进行风险投资活动。 2、里根政府时期上世纪80年代，为了振兴经济发展，里根政府开始全面放宽金融管制，为后续金融业的起飞奠定了基础。 3、宽松的信贷条件2000年互联网泡沫破裂，面对衰退的经济，美联储连续27次降息，将利率降至1%水平，过低的利率政策导致信贷规模快速扩张，为房市的上升提供了动力，加上人们对经济前景的乐观估计，贷款买房的人越来越多，房地产市场呈现一片繁荣景象。 这一时期国会通过了“格莱姆-里奇-布莱利”法案，也被称为“花旗解救法案”，这彻底推翻了“格拉斯·斯蒂格尔”法案。 4、次级贷款产生由于低利率刺激消费以及宽松的信贷条件，越来越多信用评级较差、无法从正常管道借贷的人也有能力贷款买上了新房子。 为了刺激购房，市场甚至出现了ARMs—可调整利率抵押贷款，即先给次贷客户一个初始的低利率贷款诱使客户上钩，后期再上浮利率，分期付款也直线攀升，这也为次贷危机添了一把火。 5、银行将购房贷款卖给其他机构银行当然也不会闲着，在当时的火爆行情下，贷款的债权转手就能卖给房利美与房地美，它们再打包成RMBS卖给投资者，当时就能收回款加利息，没有风险，何乐而不为？ 住宅抵押贷款证券（RMBS）是一种抵押贷款抵押债务债务，其现金流来自住房债务，如抵押贷款，房屋净值贷款和次级抵押贷款。 住宅抵押贷款支持证券由银行和其他金融机构创建的抵押贷款组成。 每个集合抵押贷款的现金流量都由一个特殊目的实体打包成班级和档次，然后发行证券并可以由投资者购买。 6、金融机构将抵押贷款打包成CDO卖给世界各地投资者投资银行（高盛、美林、雷曼、摩根斯坦利）在这样的链条中担当了一个中间人的角色，他们将“安全”的RMBS买过来，连同其他抵押证券一起被放入一个证券组合中，形成抵押担保债券（CMO）然后这个证券组合又和其他抵押贷款（如助学贷款等）组合在一起，形成新的组合债务抵押债券CDO。（collateral debt obligations），卖给世界各地的投资者，包括各种主权基金、养老金等。 这些证券在次贷危机前，大多得到了像标准普尔等大型评级机构的AAA评级。 7、权力和责任开始分离从这里开始，发债的决定权，和债务资金的提供者被华尔街分开了。是否给个体贷款，这个是由银行决定的，然后房利美、房地美把这些债务打包，卖给投行，投行把债务分解，增级，打包成CDO卖给个体投资者。所以，本质来说，是银行贷款出去，个体投资者出资来支持这笔债务。 银行发放贷款但是风险由个体投资者承担，自己还能从中赚取中间差价。按照这个逻辑，银行会更倾向于把钱带给还不起的人。 8、基准利率上升2002年，格林斯潘曾警告说：“我们非比寻常的住房繁荣……来源于的抵押贷款债务的大量增加，毫无疑问这是无法持续的。”面对过热的房地产市场，在他主导下，从2003年至2006年，美联储又连续17次加息，将基准利率从1%提升到5.25%。利率的大幅攀升加重了购房者的还贷负担，房贷违约不断出现，美国房市泡沫开始破裂。 9、大银行购入大量CDS对冲风险信用违约交换（英语：credit default swap，缩写CDS）也称信用违约掉期、信贷违约掉期、贷款违约保险；是信贷与保险的衍生工具之一，合约由两个法人交易，一个称为买方（信贷违约时受保护的一方），另一个称为卖方（保障买方于信贷违约时损失）。主要为约定期内信用违约提供一个高比率的保险业务，其意义在于为买方提供被违约时的本金保障。 高盛等大型金融机构为了对冲风险，或者说投机获利，为CDO购入的大量AIG的CDS，此举将AIG拖入了泥潭。 并且AIG所卖的CDS，0.02美分保一美元，不需持有CDO，也可以购买CDS防范风险，这也给空头很大的做空机会。 10、其他重要原因（1）、高杠杆率许多投资银行为了赚取暴利，采用20－30倍杠杆(Leverage)操作，假设一个银行A自身资产为30亿，30倍杠杆就是900亿。也就是说，这个银行A以30亿资产为抵押去借900亿的资金用于投资，假如投资盈利5%，那么A就获得45亿的盈利，相对于A自身资产而言，这是150%的暴利。反过来，假如投资亏损5%，那么银行A赔光了自己的全部资产还欠15亿。 （2）、CDO定价机制的问题这些证券组合十分复杂，而计算他们的价值和风险更为困难，最初创立CDO的摩根大通团队整合模型时，既需要繁荣时期的数据也需要衰退时期的数据，但是他们却寻找不到房地产市场衰退的数据，这些数据十分重要，想要估算CDO中证券之间的相关性，及其风险，就必须依靠这些数据。如果这些证券是没有相关性的，则相对来说是安全的，如果这些证券高度相关，结果将是灾难性的。 （3）、华尔街的薪酬制度华尔街的薪酬制度鼓励短期冒险行为，一部分是工资，更重要的是奖金，奖金相当于绩效，如果今年干的好，就能得到多少。以雷曼为例，2007年雷曼CEO福尔德的年薪为4000万美元。 三、政府在经融危机所面临的困境关于政府是否应该救助华尔街，矛盾主要集中在“道德风险”问题，“道德风险”这个晦涩的经济术语是指风险承担着业务失败时因受到某种保护，逃避了本该承担的种种恶果，而这会促使他们日后经营业务时会冒更大的风险。 问题就在于是政府否有必要拿纳税人的钱为华尔街的那些银行家们兜底，救的话会出现“道德风险”问题，以后他们可能会更加肆无忌惮冒着高风险谋取利润，如果失败了，纳税人将会为他们埋单；但是不救的话金融市场可能会产生系统性的崩溃，普通民众的正常生活和工作机会将会受到很大影响。 四、关于雷曼的悲情角色在阅读《大而不倒》这本书中，感觉最惨的是福尔德以及他的雷曼，保尔森挽救了那么多公司，但是唯独没有救雷曼。 这其实是由包括保尔森、伯南克和盖特纳在内的联邦政府官员，所做的一系列前后矛盾的决策引起的，在08年初的时候，政府救助了贝尔斯登集团，所依据是太大而不能倒闭的原则，可是太大而不能倒闭原则并没有清楚的界定什么样的金融企业是太大而不能倒闭的，什么样规模的是可以倒闭的，在拯救了美国第六大投资银行贝尔斯登后，保尔森却宣布不拯救第四大投资银行雷曼兄弟，更要命的是，美国政府并未解释为什么拯救了贝尔斯登而不拯救雷曼兄弟。 这一切到底遵循怎样的一种模式呢？采用的规则又是什么呢？这些问题似乎并没有明确的答案。当投资者变得困惑，不清楚一家公司到底是会得到挽救，还是走向破产，甚至是被国有化时，他们自然而然救开始变得恐慌，市场的动荡也会加剧。 五、关于《大而不倒》、《监守自盗》这两部纪录片这两部纪录片都描述了08年的金融危机，但是立场却有很大不同。 《坚守自盗》主要描述了资本主义贪婪的本性，华尔街的银行家们唯利是图，并且这场经融危机很大成都就是他们的贪得无厌造成的。 而《大而不倒》则主要描述了在危机发生后财长保尔森、美联储主席伯南克、纽约联储主席盖特纳联手华尔街各银行，鞠躬尽瘁，想尽一切能想到的方法，将这场金融风暴控制在尽可能小的范围内。 这两部观点完全对立的纪录片通过不同的角度来描述08年的金融危机，更有助于读者理解危机的全貌。 但是在王二看来，《监守自盗》似乎有意将华尔街放到人民的对立面，并且为了证明华尔街的邪恶，裁剪了很多持不同意见的采访内容，或者有选择地只说出了部分事实。 例如，片中认为保尔森（前高盛CEO）出任财政部长是他一生中最重要的财务决定，因为转入政府的企业工作人员在出售股票时不必交税，保尔森因此节省了5000万美元的税金。 按片中的观点看，保尔森确实是一个聪明绝顶的商人，此举确实帮助保尔森少缴了5000万美金的税。但是片中却没有提到保尔森曾经两度拒绝出任美国财政部长一职，并且在2007年10月，高盛股票涨到每股235.93美元，而他出手时仅为每股142美元。 当然文艺需要立场，需要塑造一个大反派，这一点《监守自盗》做的很成功，它是2011年奥斯卡最佳纪录片奖得主。但是我们读者也要明辨是非，记得之前在 《理解国际冲突》读后感 里说过新闻记者、史学家、纪录片编剧会有选择的叙述事实，《监守自盗》也不例外。 六、关于大企业的大而不倒纵观整个危机，我们会发现，华尔街的很多大企业企业都处在了大而不倒的境地。像AIG、花旗、摩根斯坦利、房利美、房地美，尽管他们有很多问题，但是如果政府任由他们倒闭，那么金融市场可能会产生系统性的崩溃。最后只能由整体纳税人埋单。 在国内，其实也有很多大而不倒的企业，政府处于一些考虑，例如保证就业、控制关键行业、维持社会稳定，并没有让他们正常倒闭。一方面我们看到了它的不少好处，但另一方面也付出了很大的代价，银行有时候要贷很多钱给这些企业。如果这些钱最后通过财政支出付掉，那么相当于由整体纳税人埋单；如果这些钱最后是通过印钞机印出来的，那么就相当于由整体国人埋单；如果这些钱最后债转股还给银行，银行在卖到二级市场，那就相当于由股民埋单。 从这个角度来看，我们其实也陷入了与美帝人民相同的境地。 七、关于财政部长保尔森的功过是非救市之后，摩根大通CEO杰米·戴蒙给保尔森发去的一封信中引用了罗斯福总统于1910年4月在索邦大学发表的题为“共和政体中的公民权”的演说的一段话： 当一个强者跌倒或者一个实干家做的不够完美时，只会在一旁指手画脚的批评家，算不了什么。荣耀属于那个真正站到竞技场上的人，他的脸满是灰尘和血汗，尽管一次次地失败，却仍然顽强地奋斗，因为世界上根本不存在没有失败和缺陷的成就。他明白热情和奉献的意义，并完全投身于有价值的事业中。最后，若是成功了，他能享受胜利的喜悦；就算失败了，至少他也会因为曾经全力以赴而无怨无悔。所以永远不会与那些冷漠胆小、不知何谓成功和失败的灵魂为伍。 戴蒙挑选的这段话恰到好处。罗斯福描写了一个英雄，但是对于其成功与否的描述却模棱两可。这也正好描述了保尔森以及其团队的状态，他们的功过是非，恐怕每个人的看法都不一样。 相关阅读链接： 维基百科“次贷危机”知乎“次贷危机是怎么回事？”豆瓣“文艺眼中的金融危机”豆瓣“文艺界围攻华尔街，我来为华尔街洗地”文艺眼中的金融危机百度云相关图书以及纪录片 密码:4g1v]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】被拒绝，也是一种肯定]]></title>
    <url>%2F2018%2F01%2F13%2F%E8%A2%AB%E6%8B%92%E7%BB%9D%EF%BC%8C%E4%B9%9F%E6%98%AF%E4%B8%80%E7%A7%8D%E8%82%AF%E5%AE%9A%2F</url>
    <content type="text"><![CDATA[本文转自阮一峰的一本书《前方的路》（官网，源码），这本书总结了阮一峰过去走过的人生道路。这篇文章转载自阮一峰2010年写的一篇文章 昨天，先是看到一个老外，说了一句很震撼的话。 ”你个人的项目，应该有四分之一会失败，否则就说明你的冒险精神不够。“ 我心里一动，心想这些天，我是不是把个人的失败看得太重了？ 失败完全可以理解成积极进取的结果，只有生命力充沛的人，才可能会有一次又一次的失败。一味地恐惧失败，只会让自己畏首畏尾，丧失进取心。 没料到，几个小时之后，创业家 Chris Dixon 也谈到了这个话题。 他说： ”八年前，找工作时，我四处碰壁。投了几百份简历，一无所获。大公司不给我面试机会，风投公司说他们只要有经验的人，而创业公司那时正在大批裁员。宏观经济糟透了，我自己的领域（互联网消费）一落千丈，我的简历又缺乏亮点，于是就一次又一次地被拒绝。“ 但是，Chris Dixon 后来感到，这一段经历对自己职业生涯的帮助最大。为什么？ ”因为这些挫折让我的脸皮变厚了。我开始意识到，雇主只是拒绝我的简历，而不是拒绝我这个人。既然不是对个人的否定，我又害怕失去什么呢？所以，我就更加大胆（或者说更加厚脸皮）地去找工作了。最后，终于有一家公司愿意雇佣我（感谢他们不看重我的简历），此后的一切都很顺利，我走上了事业起飞的大道。“ 他得出了结论： ”遭受挫折，并不是坏事。因为，人生的最终结果是一个极大值函数（由所有尝试中最成功的一次决定），而不是一个平均值函数。即使现在，我每天在生活中，还是会遭到拒绝。朋友想安慰我，但是我却要告诉他：之所以会这样，只是因为我在不停尝试。如果你不是每天被人拒绝，那就说明你的人生目标不够远大。“ 读到最后一句话，我的心豁然开朗。这个夏天挥之不去的一些烦恼，顿时平静了。 丘吉尔说过，”所谓成功，就是不停地经历失败，并且始终保持热情。“一次又一次地被拒绝，是你的勇气和进取心的最好证明。它们决定了你可以走多远，把你和那些决心放弃的人拉开差距。 所以，不要害怕被拒绝，这其实是对你的肯定和褒扬。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[推荐一些好用的油猴脚本]]></title>
    <url>%2F2018%2F01%2F06%2F%E6%8E%A8%E8%8D%90%E4%B8%80%E4%BA%9B%E5%A5%BD%E7%94%A8%E7%9A%84%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[最近试了几个油猴脚本，功能都很好用，以下做一个分享 首先明确一个概念：为什么要用油猴脚本？ 因为油猴脚本可以为我们增强对浏览体验的控制权。在安装之后，它们可自动为您访问的网站添加功能，或使其更加强大、易用。 说白了就是一群写JS的程序员觉得WEB端的网页不够好用，然后自己写一段JS代码，然后在不使网页报错的情况下，使网页的功能更加强大。 我们先需要安装一个用户脚本管理器，然后才可以在里面安装相应的用户脚本，来实现我们的需求。 那咱们就开始吧！ 一、安装一个用户脚本管理器首先需要安装一个用户脚本管理器，这里推荐猴脚本管理器，它是一款免费的浏览器扩展和最为流行的用户脚本管理器，它适用于 Chrome, Microsoft Edge, Safari, Opera Next, 和 Firefox。 下载油猴脚本管理器的地址戳这里 二、哪些用户脚本比较好用？我们可以用它来干什么？以王二为例，王二可以用它来做以下事情： 1、豆瓣和IMDb互相显示评分 脚本地址戳这里 2、去除百度的竞价广告 它可以为我们屏蔽掉百度的广告，脚本地址戳这里 这里再强烈推荐一个的去除网页上广告的Chrome插件–AdBlock，绝对好用顶呱呱。 3、英文不太好的同学使用GitHub可以用油猴脚本汉化 脚本地址戳这里 4、百度网盘直接下载助手可以直接下载百度网盘和百度网盘分享的文件,避免下载文件时调用百度网盘客户端,获取网盘文件的直接下载地址，就像下面这样： 脚本地址戳这里 5、破解VIP会员视频可以破解[优酷|腾讯|乐视|爱奇艺|芒果|AB站|音悦台]等VIP或会员视频，而且挺好用的，就像下面这样： 以后绝大部分电影就能随便看了，脚本地址戳这里 更多的脚本可以戳这里探索 相关链接： “油猴脚本管理器”下载地址 科学上网可以试试蓝灯 相应脚本下载地址 知乎问题”有哪些超神的油猴脚本？”]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>油猴脚本</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何使用JavaScript编写的PDF阅读器]]></title>
    <url>%2F2018%2F01%2F05%2F%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8JavaScript%E7%BC%96%E5%86%99%E7%9A%84PDF%E9%98%85%E8%AF%BB%E5%99%A8%2F</url>
    <content type="text"><![CDATA[最近公司碰到一个棘手的需求，需要用浏览器在线浏览PDF文件，这个在PC端不是问题，浏览器可以直接打开以.pdf结尾的文件，在ios端的浏览器上也能正常打开，但是如果是安卓设备，则会直接将.pdf结尾的文件下载下来，如果安卓设备上没有相应的PDF阅读器，还不能正常打开。这次要解决的问题就是：判断是否是安卓设备，如果是安卓设备，则将.pdf结尾的文件用js的PDF阅读器打开 一、判断是否是安卓设备(1)、判断是否是安卓设备很简单，只要判断它的userAgent是否包含android就能搞定，一个可运行的代码如下： 12345678// 返回true表示是安卓设备，flase表示不是安卓设备；function isAndroid()&#123; if(navigator.userAgent.toLowerCase().indexOf("android") &gt; -1)&#123; return true ; &#125;else&#123; return false ; &#125;&#125; (2)、顺便再说一下如何判断是否是IE浏览器，一个可运行的代码如下： 12345678function isIE() &#123; var userAgent = navigator.userAgent.toLowerCase(); if (userAgent.indexOf("msie") &gt; -1 || userAgent.indexOf("rv:11") &gt; -1) &#123; return true; &#125;else&#123; return false; &#125;&#125; 二、怎么使用用js的PDF阅读器这里使用的是Github上一个比较火的项目–mozilla/pdf.js。不过王二搞了半天都没清楚怎么用它。 王二的需求很简单，给王二一个.html文件，然后王二会在.html文件后面加上对应的pdf文件的绝对路径，然后就可以正常访问这个pdf文件，链接类似下面这样： http://localhost/static/pdf_read/web/viewer.html?pdf=/media/resume/7/test.pdf 王二期望的是点开上面的链接，就可以顺利地访问test.pdf文件。 于是王二在mozilla/pdf.js打包后的文件夹下稍微做了一些修改，以达到上面的目的，有这方面需求读者可以直接戳这里来查看相关代码。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑镜》第四季观后感]]></title>
    <url>%2F2018%2F01%2F03%2F%E3%80%8A%E9%BB%91%E9%95%9C%E3%80%8B%E7%AC%AC%E5%9B%9B%E5%AD%A3%E8%A7%82%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[最近《黑镜》第四季上映，王二这两天断断续续把它看完了，在这里写一个观后感。 先说一个王二看完最直接的感受，拍的没有第一季、第二季好看了。 以下轻微剧透。 《黑镜》有一个共通的主题是都以极端的黑色幽默来讽刺和探讨科技对人类生活产生的影响。 但是第四季与第一季第二季有一个很大的不同点是，第四季里很多地方是架空的科技想象，比如在你的太阳穴上放一个小的意识提取器，过一会儿就能提取你的全部记忆，这种技术恐怕在我们的有生之年都不会看到，就算实现了恐怕也不会如此简单的就能提取全部的记忆。而且第四季更多的感觉是在看科幻片，对人性伦理的讨论不多。 而第一季、第二季（加圣诞篇）更多是将剧情限定在当下的技术或者即将实现的技术来进行讨论，情节的设定上颇具科幻意味，但其内核却完全指涉现实，互联网暴民、娱乐致死、科技对隐私的侵犯、虚拟意识有没有人权…无不一一都是我们当下或者不久的将来需要直面的问题。 回到《黑镜》第四季，这一季黑镜不够黑，也不够深刻，但是仍然值得一看。 其中： “USS Callister” 卡李斯特号–可谓是另类版《星际迷航》。 “Arkangel” 大天使–由朱迪·福斯特执导，主要讲述了一位保护欲极强的母亲在其女儿脑部植入了一个智能软件的故事。 “Crocodile” 鳄鱼–聚焦于这样一个未来：那时的设备将有权限访问人类的记忆。 “Hang the DJ” 绞死DJ–将会带观众们进入该剧版本的爱情“喜剧”，想象一下这样一个世界吧：某种高科技服务会为你的所有人际关系创设相应的播放列表。 “Metalhead” 铁头–这是一部黑白特集，其中会出现一只令人畏惧的智能机械犬，因此会充满更原始的快节奏和紧张感。 “Black Museum” 暗黑博物馆–和《辛普森一家：万圣节特辑之恐怖树屋》已经被进行过比较。 还有一点不得不提，在第一集里程序员实在是被黑的太惨了，王二要给程序员正名，程序员哪有这么阴暗扭曲、心里变态的，大概是这一季的编剧对程序员心存偏见吧。 最后送一波福利，戳这里查看《黑镜》第四季影视资源（密码:kp6u）。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>美剧</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何简单地在本地启动一个HTTP服务，并将其映射到外网环境]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%A6%82%E4%BD%95%E7%AE%80%E5%8D%95%E5%9C%B0%E5%9C%A8%E6%9C%AC%E5%9C%B0%E5%90%AF%E5%8A%A8%E4%B8%80%E4%B8%AAHTTP%E6%9C%8D%E5%8A%A1%EF%BC%8C%E5%B9%B6%E5%B0%86%E5%85%B6%E6%98%A0%E5%B0%84%E5%88%B0%E5%A4%96%E7%BD%91%E7%8E%AF%E5%A2%83%2F</url>
    <content type="text"><![CDATA[文本旨在告诉读者如何简单的启动一个HTTP Server，并将其映射到外网，让外网访问者也能通过浏览器访问自己本地的服务。其中关键词有 http-server 、web server for chrome 、ngrok 有时候，我们想要测试一下打包好的项目，但是直接点开index.html文件不管用，因为依赖的路径不正确，这时候就需要启动一个HTTP服务来打开项目。我们可以使用 http-server 或者 web server for chrome 来解决这个问题。 有时候，我们还想要外网也能访问我们本地的服务，这时候我们可以使用 ngrok 来解决这个问题。 一、如何简单地在本地启动一个HTTP服务1、http-serverhttp-server 是一个简单的，零配置的命令行http服务器。它足够强大,可以用于生产环境，但它很简单，可以用来测试，本地开发和学习。 使用 http-server 很简单： 12345//全局安装http-servernpm install http-server -g//找到你要运行的文件目录下，敲下http-server，项目就顺利运行起来了http-server 关于http-server 的具体说明： 123http-server [path] [options]//[path]默认路径为./public，如果没有./public文件夹，则路径为./。 http-server还有更多的配置项，可以戳这里来详细了解它。 2、web server for chromeweb server for chrome 是谷歌浏览器的一个插件，使用它也可以很方便的启动本地HTTP服务。它长下面这个样子： 你可以戳这里来获取它，不过需要注意的的是，由于这个链接访问的是谷歌商店，所以需要科学上网。如果你还不知道如何科学上网，戳这里,蓝灯或许能帮助到你。 安装好后打开 web server for chrome，它长下面这个样子： 这时候就可以手动配置来轻松使用它了。 一、如何将本地服务映射到外网环境1、ngrokngrok是一个反向代理，它会在本地的Web服务和公共端点之间创建一个安全的通道。 使用它也很简单，先到他的官方网站上找到对应的下载地址，解压并运行ngrok, 12//敲下ngrok http 8080，本地的8080端口就会被映射到外网环境ngrok http 8080 如下图： 我们还可以到它的官方网站或者github更详细地了解它。]]></content>
      <categories>
        <category>计算机通识</category>
      </categories>
      <tags>
        <tag>Chrome</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的2017]]></title>
    <url>%2F2017%2F12%2F31%2F%E6%88%91%E7%9A%842017%2F</url>
    <content type="text"><![CDATA[如果把镜头拉长，从未来遥远的的时间点来看王二的2017，只发生了一件大事 ———— 王二顺利毕业 如果把镜头拉长，从未来遥远的的时间点来看王二的2017，只发生了一件大事 ———— 王二顺利毕业 但是把镜头拉近，从当下的时间点来看2017，还是有不少的趣闻趣事值得分享的： 1、17年3月份，买了台无人机，老妈问多少钱，我说2000块，老妈信了，我妈一直如此信任我。过段时间，无人机玩腻了，有一次在老妈面前说漏嘴，说要5000块卖掉，当时我妈的眼神特别复杂，估计是夸他儿子特别厉害，2000块的东西转手5000块能卖掉。2、17年6月份，临近毕业答辩，我于是和导师探讨怎样才能让自己通过答辩，我导师人很好，我问他这个问题，他也很负责地和我探讨了起来。导师边看着我图纸边跟我说你现在还没有底子，要想通过答辩很难，除非，你直接二辩！导师现场拍胸脯保证说，只要你二辨，保证给你一个及格。我很痛恨二辩，认为那会消磨我有限的精力，那不是我想要的，那时候我在想，我要好好画图，我不能二辩。3、17年6月3日，我清楚地记得这一天是答辩日期，早上爬起来打算打印图纸去答辩，这时候手机推送一条新闻，说比特币大涨，当时好像涨到了13000人民币，我一下子就被吸引到了，然后就查了一天关于比特币的知识，从中本聪的白皮书到区块链技术。如我导师所愿，我顺利地直接二辩。4、17年6月22日，发生了今年最重要的事情，完成毕业典礼，导师的胸脯没有白拍，二辩拿了一个及格，我顺利毕业了。当时还给自己配了一首诗：键未佩妥，出门已是征途，钱路漫漫，唯键作伴。5、17年7月7日，在第一家公司顺利转正，一个礼拜后，传闻公司经验不善，再一个礼拜后，公司一半码农跑路了，公司里做前端开发的似乎就是我最厉害了（连我只剩两个）。我当时也寻思要不要跑路，但是想想，转正都转过来了，两眼一抹黑，先这样干着呗，人有时候也要逼自己一把。6、17年7月31日，搭建了自己的个人网站，这个还是值得一说的，截止到今天，上面一共写了68篇博文，除去转载的10篇博客，自己一共写了58篇博客。网站的访客数一共有 530 人次 ，总访问量也有 1377 次。7、17年8月20日，淘宝上给自己的英雄联盟账号买了个封号三年套餐，想想自己对游戏也就死心了。一个月后，一次偶然机会，和同事一起去网吧上网，手贱试了试到底有没有被封号，很遗憾，没有被封号，我算是被那个店家忽悠瘸了。8、17年10月26日，收到现在公司的offer，转战到上海。9、17年12月份，伴随着这一年比特币的大涨大跌，自己又多了个身份，比特币以及比特币现金持有者。10、整个17年，自己在技术上有了不少精进，也在Github开源项目上也有一些自己小小的贡献，但总觉得没有发挥自己的全部功力，有时依然很懈怠。 总的来说，2017年平淡又不乏精彩，有很多收获又有不少遗憾。17年初写下的八个目标真正完成的只有两个，还有两个算是半吊子，另外四个落实都没落实。不管怎么说，自己过的日子自己最清楚，2018再来吧！]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】这鸡蛋真难吃]]></title>
    <url>%2F2017%2F12%2F30%2F%E8%BF%99%E9%B8%A1%E8%9B%8B%E7%9C%9F%E9%9A%BE%E5%90%83%2F</url>
    <content type="text"><![CDATA[本文转自阮一峰的新书《前方的路》（官网，源码），这本书总结了阮一峰过去走过的人生道路。这篇文章转载自阮一峰2008年写的一篇文章 有些人的逻辑是很奇怪的。网友若昔难得就归纳出了几种，我转载在下面。 A：这鸡蛋真难吃。B：隔壁家那鸭蛋更难吃，你咋不说呢？ A：这鸡蛋真难吃。B：有本事你下个好吃的蛋来。 A：这鸡蛋真难吃。B：下蛋的是一只勤劳勇敢善良正直的鸡。 A：这鸡蛋真难吃。B：比前年的蛋已经进步很多了。 A：这鸡蛋真难吃。B：你就是吃这鸡蛋长大的，你有什么权力说这蛋不好吃？ A：这鸡蛋真难吃。B：你这么说是什么居心什么目的？ A：这鸡蛋真难吃。B：嫌难吃就别吃，滚去吃隔壁的鸭蛋吧。 A：这鸡蛋真难吃。B：隔壁的鸡给了你多少钱? A：这鸡蛋真难吃。B：再难吃也是自己家的鸡下的蛋，凭这个就不能说难吃。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】大教堂和集市]]></title>
    <url>%2F2017%2F12%2F28%2F%E5%A4%A7%E6%95%99%E5%A0%82%E5%92%8C%E9%9B%86%E5%B8%82%2F</url>
    <content type="text"><![CDATA[本文转自阮一峰的新书《前方的路》（官网，源码），这本书总结了阮一峰过去走过的人生道路。这篇文章转载自阮一峰2008年写的一篇文章 Eric Raymond 有一篇著名文章《大教堂和集市》（The Cathedral and the Bazaar）。他说，世界上的建筑可以分两种：一种是集市，天天开放在那里，从无到有，从小到大；还有一种是大教堂，几代人呕心沥血，几十年才能建成，投入使用。 当你新建一座建筑时，你可以采用集市的模式，也可以采用大教堂的模式。一般来说，集市的特点是开放式建设、成本低、周期短、品质平庸；大教堂的特点是封闭式建设、成本高、周期长、品质优异。 Eric Raymond 就问了一个问题，有没有可能用修建集市的方式，造出一所大教堂？ 我多年前读过这篇文章，上个星期与朋友在邮件里讨论问题时，突然想到了它。我们的问题是，有一个项目，方案 A 是精心准备后再投入使用，方案 B 是将半成品先公开，然后再逐步完善。这让我情不自禁地就想到了”大教堂和集市“这个比喻。 我们想造出一个大教堂，可是眼下只有一个集市，怎么办？ 我找出 Eric Raymond 的这篇文章，重读了一遍，很多模糊的印象一下子清晰起来。到底是经典文章啊，虽然写在10年前，但是很多问题他都考虑到了。 他说，集市要变成大教堂，有几个前提条件。 你不能从零开始建设集市，你必须先有一个原始项目。 你的原始项目可以有缺陷，但是它必须能运行（work）。 你必须向用户展示一个可行的前景，且让潜在的合作者相信在可预见的将来它会变成一个真正漂亮的东西。 项目的主持者本身不一定是天才，但他一定要能够慧眼识别出他人的优秀想法。 项目的主持者必须要有良好的人际关系、交流技能和人格魅力。这样才能吸引他人，使别人对你所做的事感兴趣，愿意帮助你。 以上是一些必要条件，Eric Raymond 也总结了一些项目成功的充分条件。 项目首先必须是你自己感兴趣的，但是最终能对其他人有用。 将用户当作合作者。 尽快地和经常地做出改进，多听取用户的意见。 健壮的结构远比精巧的设计来得重要。换句话说，结构是第一位的，功能是第二位的。 保持项目的简单性。设计达到完美的时候，不是无法再增加东西了，而是无法再减少东西了。 Eric Raymond 这篇文章，原始目的是要分析 Linux 的成功之道。 为什么一个本科生的业余作品，最后竟变成了全世界最流行的操作系统之一？ 一个简陋的集市究竟是怎样变成壮丽的大教堂的？ 这个过程是否是可复制和推广的？ 他认为，这就是开放的威力。一个开放式的项目，如果加以良好的管理和运作，能取得比同等的封闭式项目大得多的成功。他这样看待大教堂和集市之间的竞争： 我认为，未来会更多地属于那些告别大教堂、拥抱集市的人们。这不是说个人的远见和才华不再重要；而是在我看来，未来的成功者只是从自己的远见和才华开始工作，然后通过有效的社区合作，将其不断地放大。 开放式的文化会最终胜利，这或许不是因为“开放”在道德上正确，或者“封闭”在道德上错误，而只是因为开放式合作可以在一个问题上投入多几个数量级的技术工时，封闭的世界无法赢得这样的竞争。]]></content>
      <categories>
        <category>文学</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】JavaScript 语言的历史]]></title>
    <url>%2F2017%2F12%2F26%2FJavaScript-%E8%AF%AD%E8%A8%80%E7%9A%84%E5%8E%86%E5%8F%B2%2F</url>
    <content type="text"><![CDATA[最近阮一峰在写关于JavaScript辅导教程，其中关于JavaScript历史的这一部分写的非常不错，这里做一个转载 转载自阮一峰的javascript-tutorial诞生JavaScript 因为互联网而生，紧跟着浏览器的出现而问世。回顾它的历史，就要从浏览器的历史讲起。 1990年底，欧洲核能研究组织（CERN）科学家 Tim Berners-Lee，在全世界最大的电脑网络——互联网的基础上，发明了万维网（World Wide Web），从此可以在网上浏览网页文件。最早的网页只能在操作系统的终端里浏览，也就是说只能使用命令行操作，网页都是在字符窗口中显示，这当然非常不方便。 1992年底，美国国家超级电脑应用中心（NCSA）开始开发一个独立的浏览器，叫做 Mosaic。这是人类历史上第一个浏览器，从此网页可以在图形界面的窗口浏览。 1994年10月，NCSA 的一个主要程序员 Marc Andreessen 联合风险投资家 Jim Clark，成立了 Mosaic 通信公司（Mosaic Communications），不久后改名为 Netscape。这家公司的方向，就是在 Mosaic 的基础上，开发面向普通用户的新一代的浏览器 Netscape Navigator。 1994年12月，Navigator 发布了1.0版，市场份额一举超过90%。 Netscape 公司很快发现，Navigator 浏览器需要一种可以嵌入网页的脚本语言，用来控制浏览器行为。当时，网速很慢而且上网费很贵，有些操作不宜在服务器端完成。比如，如果用户忘记填写“用户名”，就点了“发送”按钮，到服务器再发现这一点就有点太晚了，最好能在用户发出数据之前，就告诉用户“请填写用户名”。这就需要在网页中嵌入小程序，让浏览器检查每一栏是否都填写了。 管理层对这种浏览器脚本语言的设想是：功能不需要太强，语法较为简单，容易学习和部署。那一年，正逢 Sun 公司的 Java 语言问世，市场推广活动非常成功。Netscape 公司决定与 Sun 公司合作，浏览器支持嵌入 Java 小程序（后来称为 Java applet）。但是，浏览器脚本语言是否就选用 Java，则存在争论。后来，还是决定不使用 Java，因为网页小程序不需要 Java 这么“重”的语法。但是，同时也决定脚本语言的语法要接近 Java，并且可以支持 Java 程序。这些设想直接排除了使用现存语言，比如 Perl、Python 和 TCL。 1995年，Netscape 公司雇佣了程序员 Brendan Eich 开发这种网页脚本语言。Brendan Eich 有很强的函数式编程背景，希望以 Scheme 语言（函数式语言鼻祖 LISP 语言的一种方言）为蓝本，实现这种新语言。 1995年5月，Brendan Eich 只用了10天，就设计完成了这种语言的第一版。它是一个大杂烩，语法有多个来源。 基本语法：借鉴 C 语言和 Java 语言。 数据结构：借鉴 Java 语言，包括将值分成原始值和对象两大类。 函数的用法：借鉴 Scheme 语言和 Awk 语言，将函数当作第一等公民，并引入闭包。 原型继承模型：借鉴 Self 语言（Smalltalk 的一种变种）。 正则表达式：借鉴 Perl 语言。 字符串和数组处理：借鉴 Python 语言。 为了保持简单，这种脚本语言缺少一些关键的功能，比如块级作用域、模块、子类型（subtyping）等等，但是可以利用现有功能找出解决办法。这种功能的不足，直接导致了后来 JavaScript 的一个显著特点：对于其他语言，你需要学习语言的各种功能，而对于 JavaScript，你常常需要学习各种解决问题的模式。而且由于来源多样，从一开始就注定，JavaScript 的编程风格是函数式编程和面向对象编程的一种混合体。 Netscape 公司的这种浏览器脚本语言，最初名字叫做 Mocha，1995年9月改为 LiveScript。12月，Netscape 公司与 Sun 公司（Java 语言的发明者和所有者）达成协议，后者允许将这种语言叫做 JavaScript。这样一来，Netscape 公司可以借助 Java 语言的声势，而 Sun 公司则将自己的影响力扩展到了浏览器。 之所以起这个名字，并不是因为 JavaScript 本身与 Java 语言有多么深的关系（事实上，两者关系并不深，详见下节），而是因为 Netscape 公司已经决定，使用 Java 语言开发网络应用程序，JavaScript 可以像胶水一样，将各个部分连接起来。当然，后来的历史是 Java 语言的浏览器插件失败了，JavaScript 反而发扬光大。 1995年12月4日，Netscape 公司与 Sun 公司联合发布了 JavaScript 语言，对外宣传 JavaScript 是 Java 的补充，属于轻量级的 Java，专门用来操作网页。 1996年3月，Navigator 2.0 浏览器正式内置了 JavaScript 脚本语言。 JavaScript 与 Java 的关系这里专门说一下 JavaScript 和 Java 的关系。它们是两种不一样的语言，但是彼此存在联系。 JavaScript 的基本语法和对象体系，是模仿 Java 而设计的。但是，JavaScript 没有采用 Java 的静态类型。正是因为 JavaScript 与 Java 有很大的相似性，所以这门语言才从一开始的 LiveScript 改名为 JavaScript。基本上，JavaScript 这个名字的原意是“很像Java的脚本语言”。 JavaScript 语言的函数是一种独立的数据类型，以及采用基于原型对象（prototype）的继承链。这是它与 Java 语法最大的两点区别。JavaScript 语法要比 Java 自由得多。 另外，Java 语言需要编译，而 JavaScript 语言则是运行时由解释器直接执行。 总之，JavaScript 的原始设计目标是一种小型的、简单的动态语言，与 Java 有足够的相似性，使得使用者（尤其是 Java 程序员）可以快速上手。 JavaScript 与 ECMAScript 的关系1996年8月，微软模仿 JavaScript 开发了一种相近的语言，取名为JScript（JavaScript是Netscape的注册商标，微软不能用），首先内置于IE 3.0。Netscape 公司面临丧失浏览器脚本语言的主导权的局面。 1996年11月，Netscape 公司决定将 JavaScript 提交给国际标准化组织 ECMA（European Computer Manufacturers Association），希望 JavaScript 能够成为国际标准，以此抵抗微软。ECMA 的39号技术委员会（Technical Committee 39）负责制定和审核这个标准，成员由业内的大公司派出的工程师组成，目前共25个人。该委员会定期开会，所有的邮件讨论和会议记录，都是公开的。 1997年7月，ECMA 组织发布262号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript。这个版本就是 ECMAScript 1.0 版。之所以不叫 JavaScript，一方面是由于商标的关系，Java 是 Sun 公司的商标，根据一份授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 已经被 Netscape 公司注册为商标，另一方面也是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现。在日常场合，这两个词是可以互换的。 ECMAScript 只用来标准化 JavaScript 这种语言的基本语法结构，与部署环境相关的标准都由其他标准规定，比如 DOM 的标准就是由 W3C组织（World Wide Web Consortium）制定的。 ECMA-262 标准后来也被另一个国际标准化组织 ISO（International Organization for Standardization）批准，标准号是 ISO-16262。 JavaScript的版本1997年7月，ECMAScript 1.0发布。 1998年6月，ECMAScript 2.0版发布。 1999年12月，ECMAScript 3.0版发布，成为 JavaScript 的通行标准，得到了广泛支持。 2007年10月，ECMAScript 4.0版草案发布，对3.0版做了大幅升级，预计次年8月发布正式版本。草案发布后，由于4.0版的目标过于激进，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。 2008年7月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激进，ECMA 开会决定，中止 ECMAScript 4.0 的开发（即废除了这个版本），将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 2009年12月，ECMAScript 5.0版 正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 的总体考虑是，ECMAScript 5 与 ECMAScript 3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是ECMAScript 6。第六版发布以后，将指 ECMAScript 7。TC39 预计，ECMAScript 5 会在2013年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。 2011年6月，ECMAscript 5.1版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。到了2012年底，所有主要浏览器都支持 ECMAScript 5.1版的全部功能。 2013年3月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。 2013年12月，ECMAScript 6 草案发布。然后是12个月的讨论期，听取各方反馈。 2015年6月，ECMAScript 6 正式发布，并且更名为“ECMAScript 2015”。这是因为 TC39 委员会计划，以后每年发布一个 ECMAScript 的版本，下一个版本在2016年发布，称为”ECMAScript 2016”，2017年发布“ECMAScript 2017”，以此类推。 周边大事记JavaScript 伴随着互联网的发展一起发展。互联网周边技术的快速发展，刺激和推动了 JavaScript 语言的发展。下面，回顾一下 JavaScript 的周边应用发展。 1996年，样式表标准 CSS 第一版发布。 1997年，DHTML（Dynamic HTML，动态 HTML）发布，允许动态改变网页内容。这标志着 DOM 模式（Document Object Model，文档对象模型）正式应用。 1998年，Netscape 公司开源了浏览器，这导致了 Mozilla 项目的诞生。几个月后，美国在线（AOL）宣布并购 Netscape。 1999年，IE 5部署了 XMLHttpRequest 接口，允许 JavaScript 发出 HTTP 请求，为后来大行其道的 Ajax 应用创造了条件。 2000年，KDE 项目重写了浏览器引擎 KHTML，为后来的 WebKit 和 Blink 引擎打下基础。这一年的10月23日，KDE 2.0发布，第一次将 KHTML 浏览器包括其中。 2001年，微软公司时隔5年之后，发布了 IE 浏览器的下一个版本 Internet Explorer 6。这是当时最先进的浏览器，它后来统治了浏览器市场多年。 2001年，Douglas Crockford 提出了 JSON 格式，用于取代 XML 格式，进行服务器和网页之间的数据交换。JavaScript 可以原生支持这种格式，不需要额外部署代码。 2002年，Mozilla 项目发布了它的浏览器的第一版，后来起名为 Firefox。 2003年，苹果公司发布了 Safari 浏览器的第一版。 2004年，Google 公司发布了 Gmail，促成了互联网应用程序（Web Application）这个概念的诞生。由于 Gmail 是在4月1日发布的，很多人起初以为这只是一个玩笑。 2004年，Dojo 框架诞生，为不同浏览器提供了同一接口，并为主要功能提供了便利的调用方法。这标志着 JavaScript 编程框架的时代开始来临。 2004年，WHATWG 组织成立，致力于加速 HTML 语言的标准化进程。 2005年，苹果公司在 KHTML 引擎基础上，建立了 WebKit 引擎。 2005年，Ajax 方法（Asynchronous JavaScript and XML）正式诞生，Jesse James Garrett 发明了这个词汇。它开始流行的标志是，2月份发布的 Google Maps 项目大量采用该方法。它几乎成了新一代网站的标准做法，促成了 Web 2.0时代的来临。 2005年，Apache 基金会发布了 CouchDB 数据库。这是一个基于 JSON 格式的数据库，可以用 JavaScript 函数定义视图和索引。它在本质上有别于传统的关系型数据库，标识着 NoSQL 类型的数据库诞生。 2006年，jQuery 函数库诞生，作者为John Resig。jQuery 为操作网页 DOM 结构提供了非常强大易用的接口，成为了使用最广泛的函数库，并且让 JavaScript 语言的应用难度大大降低，推动了这种语言的流行。 2006年，微软公司发布 IE 7，标志重新开始启动浏览器的开发。 2006年，Google推出 Google Web Toolkit 项目（缩写为 GWT），提供 Java 编译成 JavaScript 的功能，开创了将其他语言转为 JavaScript 的先河。 2007年，Webkit 引擎在 iPhone 手机中得到部署。它最初基于 KDE 项目，2003年苹果公司首先采用，2005年开源。这标志着 JavaScript 语言开始能在手机中使用了，意味着有可能写出在桌面电脑和手机中都能使用的程序。 2007年，Douglas Crockford 发表了名为《JavaScript: The good parts》的演讲，次年由 O’Reilly 出版社出版。这标志着软件行业开始严肃对待 JavaScript 语言，对它的语法开始重新认识， 2008年，V8 编译器诞生。这是 Google 公司为 Chrome 浏览器而开发的，它的特点是让 JavaScript 的运行变得非常快。它提高了 JavaScript 的性能，推动了语法的改进和标准化，改变外界对 JavaScript 的不佳印象。同时，V8 是开源的，任何人想要一种快速的嵌入式脚本语言，都可以采用 V8，这拓展了 JavaScript 的应用领域。 2009年，Node.js 项目诞生，创始人为 Ryan Dahl，它标志着 JavaScript 可以用于服务器端编程，从此网站的前端和后端可以使用同一种语言开发。并且，Node.js 可以承受很大的并发流量，使得开发某些互联网大规模的实时应用变得容易。 2009年，Jeremy Ashkenas 发布了 CoffeeScript 的最初版本。CoffeeScript 可以被转换为 JavaScript 运行，但是语法要比 JavaScript简洁。这开启了其他语言转为 JavaScript 的风潮。 2009年，PhoneGap 项目诞生，它将 HTML5 和 JavaScript 引入移动设备的应用程序开发，主要针对 iOS 和 Android 平台，使得 JavaScript 可以用于跨平台的应用程序开发。 2009，Google 发布 Chrome OS，号称是以浏览器为基础发展成的操作系统，允许直接使用 JavaScript 编写应用程序。类似的项目还有 Mozilla 的 Firefox OS。 2010年，三个重要的项目诞生，分别是 NPM、BackboneJS 和 RequireJS，标志着 JavaScript 进入模块化开发的时代。 2011年，微软公司发布 Windows 8操作系统，将 JavaScript 作为应用程序的开发语言之一，直接提供系统支持。 2011年，Google 发布了 Dart 语言，目的是为了结束 JavaScript 语言在浏览器中的垄断，提供更合理、更强大的语法和功能。Chromium浏览器有内置的 Dart 虚拟机，可以运行 Dart 程序，但 Dart 程序也可以被编译成 JavaScript 程序运行。 2011年，微软工程师Scott Hanselman提出，JavaScript 将是互联网的汇编语言。因为它无所不在，而且正在变得越来越快。其他语言的程序可以被转成 JavaScript 语言，然后在浏览器中运行。 2012年，单页面应用程序框架（single-page app framework）开始崛起，AngularJS 项目和 Ember 项目都发布了1.0版本。 2012年，微软发布 TypeScript 语言。该语言被设计成 JavaScript 的超集，这意味着所有 JavaScript 程序，都可以不经修改地在 TypeScript 中运行。同时，TypeScript 添加了很多新的语法特性，主要目的是为了开发大型程序，然后还可以被编译成 JavaScript 运行。 2012年，Mozilla 基金会提出 asm.js 规格。asm.js 是 JavaScript 的一个子集，所有符合 asm.js 的程序都可以在浏览器中运行，它的特殊之处在于语法有严格限定，可以被快速编译成性能良好的机器码。这样做的目的，是为了给其他语言提供一个编译规范，使其可以被编译成高效的 JavaScript 代码。同时，Mozilla 基金会还发起了 Emscripten 项目，目标就是提供一个跨语言的编译器，能够将 LLVM 的位代码（bitcode）转为 JavaScript 代码，在浏览器中运行。因为大部分 LLVM 位代码都是从 C / C++ 语言生成的，这意味着 C / C++ 将可以在浏览器中运行。此外，Mozilla 旗下还有 LLJS （将 JavaScript 转为 C 代码）项目和 River Trail （一个用于多核心处理器的 ECMAScript 扩展）项目。目前，可以被编译成 JavaScript 的语言列表，共有将近40种语言。 2013年，Mozilla 基金会发布手机操作系统 Firefox OS，该操作系统的整个用户界面都使用 JavaScript。 2013年，ECMA 正式推出 JSON 的国际标准，这意味着 JSON 格式已经变得与 XML 格式一样重要和正式了。 2013年5月，Facebook 发布 UI 框架库 React，引入了新的 JSX 语法，使得 UI 层可以用组件开发，同时引入了网页应用是状态机的概念。 2014年，微软推出 JavaScript 的 Windows 库 WinJS，标志微软公司全面支持 JavaScript 与 Windows 操作系统的融合。 2014年11月，由于对 Joyent 公司垄断 Node 项目、以及该项目进展缓慢的不满，一部分核心开发者离开了 Node.js，创造了 io.js 项目，这是一个更开放、更新更频繁的 Node.js 版本，很短时间内就发布到了2.0版。三个月后，Joyent 公司宣布放弃对 Node 项目的控制，将其转交给新成立的开放性质的 Node 基金会。随后，io.js 项目宣布回归 Node，两个版本将合并。 2015年3月，Facebook 公司发布了 React Native 项目，将 React 框架移植到了手机端，可以用来开发手机 App。它会将 JavaScript 代码转为 iOS 平台的 Objective-C 代码，或者 Android 平台的 Java 代码，从而为 JavaScript 语言开发高性能的原生 App 打开了一条道路。 2015年4月，Angular 框架宣布，2.0 版将基于微软公司的TypeScript语言开发，这等于为 JavaScript 语言引入了强类型。 2015年5月，Node 模块管理器 NPM 超越 CPAN，标志着 JavaScript 成为世界上软件模块最多的语言。 2015年5月，Google 公司的 Polymer 框架发布1.0版。该项目的目标是生产环境可以使用 WebComponent 组件，如果能够达到目标，Web 开发将进入一个全新的以组件为开发基础的阶段。 2015年6月，ECMA 标准化组织正式批准了 ECMAScript 6 语言标准，定名为《ECMAScript 2015 标准》。JavaScript语言正式进入了下一个阶段，成为一种企业级的、开发大规模应用的语言。这个标准从提出到批准，历时10年，而 JavaScript 语言从诞生至今也已经20年了。 2015年6月，Mozilla 在 asm.js 的基础上发布 WebAssembly 项目。这是一种 JavaScript 引擎的中间码格式，全部都是二进制，类似于 Java 的字节码，有利于移动设备加载 JavaScript 脚本，执行速度提高了 20+ 倍。这意味着将来的软件，会发布 JavaScript 二进制包。 2016年6月，《ECMAScript 2016 标准》发布。与前一年发布的版本相比，它只增加了两个较小的特性。 2017年6月，《ECMAScript 2017 标准》发布，正式引入了 async 函数，使得异步操作的写法出现了根本的变化。 2017年11月，所有主流浏览器全部支持 WebAssembly，这意味着任何语言都可以编译成 JavaScript，在浏览器运行。 参考链接 Axel Rauschmayer, The Past, Present, and Future of JavaScript John Dalziel, The race for speed part 4: The future for JavaScript Axel Rauschmayer, Basic JavaScript for the impatient programmer resin.io, Happy 18th Birthday JavaScript! A look at an unlikely past and bright future 维基百科 JavaScript]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用 Proxy 实现监听 js 中变量的变化]]></title>
    <url>%2F2017%2F12%2F25%2F%E5%88%A9%E7%94%A8-Proxy-%E5%AE%9E%E7%8E%B0%E7%9B%91%E5%90%AC-js-%E4%B8%AD%E5%8F%98%E9%87%8F%E7%9A%84%E5%8F%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[刚刚在 gitHub 上看到一段代码，很巧妙地利用SE6新的 Proxy 对象，可以很方便的监听 js 中变量的变化，这里做一个分享 一、利用 Proxy 实现监听 js 中变量的变化代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940var observe1 = (object, onChange) =&gt; &#123; const handler = &#123; get(target, property, receiver) &#123; try &#123; return new Proxy(target[property], handler); &#125; catch (err) &#123; return Reflect.get(target, property, receiver); &#125; &#125;, set(target, key, value, receiver) &#123; onChange(value); return Reflect.set(target, key, value, receiver); &#125; &#125;; return new Proxy(object, handler);&#125;;var obj = &#123; foo: false, a: &#123; x:&#123; y: 4 &#125;, b:[ &#123; c: false &#125; ] &#125;&#125;;var watchedObj = observe1(obj,(val)=&gt;&#123; console.log(`哈哈哈，监听到值变化为$&#123;val&#125;了`);&#125;);watchedObj.foo = true; //哈哈哈，监听到值变化为true了watchedObj.a.x.y = 5; ////哈哈哈，监听到值变化为5了watchedObj.a.b[0].c = true;//哈哈哈，监听到值变化为true了 以上的思路主要是参考自Github仓库 on-change,有兴趣可以点进去看看。 对 Proxy 还不太了解的同学可以先读读阮一峰的这篇文章,或者MDN的这篇文章。 二、用 Object.defineProperty 实现监听 js 中变量的变化之前王二写过一篇博客叫做JS中Object.defineProperty的使用方法,里面也有一段实现监听 js 中变量的变化的代码 代码修改如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748function observe2(data,onChange) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key],onChange); &#125;); function defineReactive(data, key, val, onChange) &#123; observe2(val,onChange); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; onChange(newVal); val = newVal; &#125; &#125;); &#125;&#125;;var obj = &#123; foo: false, a: &#123; x:&#123; y: 4 &#125;, b:[ &#123; c: false &#125; ] &#125;&#125;;observe2(obj,(val)=&gt;&#123; console.log(`哈哈哈，监听到值变化为$&#123;val&#125;了`);&#125;)obj.foo = true; //哈哈哈，监听到值变化为true了obj.a.x.y = 5; ////哈哈哈，监听到值变化为5了obj.a.b[0].c = true;//哈哈哈，监听到值变化为true了 这样写的话也能实现第一种用 Proxy 实现的功能，不过两者也有差异： 1、如果写一个新的元素，则第一种方法能监听到，但是第二种方法监听不到2、还有一个问题就是修改数组的length，以及数组的push等变异方法是无法触发setter的，也就是这两种情况第二种方法也监听不到 试试如下验证代码：1234567watchedObj.a.b.length = 4;watchedObj.a.x.z = 'tt';watchedObj.a.b.push("2");obj.a.b.length = 4;obj.a.x.z = 'tt';obj.a.b.push("2"); 三、其他方式实现监听 js 中变量的变化当然还有其他方法实现监听 js 中的变化，例如：脏检测、__defineGetter__/__defineSetter_方法、被废弃的Object.observe()方法、以及支持IE8的vbscript，这里就不暂开聊了，有兴趣可以看看下面的相关链接： ‘萧秦’的博客知乎话题’如何监听 js 中变量的变化?’Angular沉思录（一）数据绑定Object.observe() - JavaScript | MDN]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[“30 seconds of code”中好玩的代码片段]]></title>
    <url>%2F2017%2F12%2F22%2F30-seconds-of-code-%E4%B8%AD%E5%A5%BD%E7%8E%A9%E7%9A%84%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5%2F</url>
    <content type="text"><![CDATA[最近做了github出现一个挺火的代码库“30 seconds of code”,里面有不少好玩的代码片段，这里做一个分享 以下分享8个有趣的代码片段，有兴趣可以亲自点开看看1、differenceReturns the difference between two arrays.Create a Set from b, then use Array.filter() on a to only keep values not contained in b. 12const difference1 = (a, b) =&gt; &#123; const s = new Set(b); return a.filter(x =&gt; !s.has(x)); &#125;;// difference1([1,2,3], [1,2,4]) -&gt; [3] 王二还想出了如下两种解决方法，也可以满足以上需求： 123const difference2 = (a, b) =&gt; &#123; return a.filter( _ =&gt; !b.some(($)=&gt;(_===$))&#125;;const difference3 = (a, b) =&gt; &#123; return a.filter( _ =&gt; !b.includes(_))&#125;; 2、pickPicks the key-value pairs corresponding to the given keys from an object.Use Array.reduce() to convert the filtered/picked keys back to a object with the corresponding key-value pair if the key exist in the obj. 12const pick1 = (obj, arr) =&gt; arr.reduce((acc, curr) =&gt; (curr in obj &amp;&amp; (acc[curr] = obj[curr]), acc), &#123;&#125;);// pick1(&#123; 'a': 1, 'b': '2', 'c': 3 &#125;, ['a', 'c']) -&gt; &#123; 'a': 1, 'c': 3 &#125; 如果不用reduce而使用一般的解决循环，也可以解决以上需求，例如王二如下给出的方法，不过用reduce一行就能搞定，当然是显得更优雅了。 12345const pick2 = (obj, arr) =&gt; &#123; const res = &#123;&#125;; arr.forEach(curr =&gt; (curr in obj &amp;&amp; (res[curr] = obj[curr]))); return res ;&#125;; 3、zipCreates an array of elements, grouped based on the position in the original arrays. Use Math.max.apply() to get the longest array in the arguments. Creates an array with that length as return value and use Array.from() with a map-function to create an array of grouped elements. If lengths of the argument-arrays vary, undefined is used where no value could be found. 12345678const zip1 = (...arrays) =&gt; &#123; const maxLength = Math.max(...arrays.map(x =&gt; x.length)); return Array.from(&#123;length: maxLength&#125;).map((_, i) =&gt; &#123; return Array.from(&#123;length: arrays.length&#125;, (_, k) =&gt; arrays[k][i]); &#125;)&#125;//zip1(['a', 'b'], [1, 2], [true, false]); -&gt; [['a', 1, true], ['b', 2, false]]//zip1(['a'], [1, 2], [true, false]); -&gt; [['a', 1, true], [undefined, 2, false]] 以上需求一般的解决方法如下所示，可以用两层for循环搞定。但是很显然，上面的写法显得更优雅； 12345678910111213141516const zip2 = () =&gt; &#123; var arr = Array.prototype.slice.call(arguments), maxLength = 0, out = []; arr.forEach(function(i)&#123; maxLength = Math.max(i.length,maxLength) ; &#125;) for(var x=0;x&lt;maxLength;x++)&#123; var temp = []; for(var y=0;y&lt;arr.length;y++)&#123; temp.push(arr[y][x]); &#125; out.push(temp); &#125; return out;&#125; 4、getBoundingClientRect()dom元素使用getBoundingClientRect()可以获得其详细的位置。 5、getURLParametersReturns an object containing the parameters of the current URL. Use match() with an appropriate regular expression to get all key-value pairs, Array.reduce() to map and combine them into a single object. Pass location.search as the argument to apply to the current url. 1234567const getURLParameters1 = () =&gt; location.href.match(/([^?=&amp;]+)(=([^&amp;]*))/g).reduce( (a, v) =&gt; (a[v.slice(0, v.indexOf('='))] = v.slice(v.indexOf('=') + 1), a), &#123;&#125; );// location.href = 'http://url.com/page?name=Adam&amp;surname=Smith';// getURLParameters() -&gt; &#123;name: 'Adam', surname: 'Smith'&#125; 一般的解决思路如下，但是以上的方法用正则加reduce一行就能搞定； 123456789101112131415161718192021222324const getURLParameters2 = () =&gt; &#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, //在 for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到 args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 6、curryCurries a function. Use recursion. If the number of provided arguments (args) is sufficient, call the passed function f. Otherwise return a curried function f that expects the rest of the arguments. If you want to curry a function that accepts a variable number of arguments (a variadic function, e.g. Math.min()), you can optionally pass the number of arguments to the second parameter arity. 123456const curry = (fn, arity = fn.length, ...args) =&gt; arity &lt;= args.length ? fn(...args) : curry.bind(null, fn, arity, ...args);// curry1(Math.pow)(2)(10) -&gt; 1024// curry1(Math.min, 3)(10)(50)(2) -&gt; 2 一些王二一直弄不明白什么叫做柯里化，这个函数给王二好好上了一课； 7、pipePerforms left-to-right function composition. Use Array.reduce() with the spread operator (...) to perform left-to-right function composition. The first (leftmost) function can accept one or more arguments; the remaining functions must be unary. 1234567const pipeFunctions = (...fns) =&gt; fns.reduce((f, g) =&gt; (...args) =&gt; g(f(...args)));/*const add5 = x =&gt; x + 5const multiply = (x, y) =&gt; x * yconst multiplyAndAdd5 = pipeFunctions(multiply, add5)multiplyAndAdd5(5, 2) -&gt; 15*/ 王二第一次看到这个函数简直就是黑科技； 8、fibonacciGenerates an array, containing the Fibonacci sequence, up until the nth term. Create an empty array of the specific length, initializing the first two values (0 and 1). Use Array.reduce() to add values into the array, using the sum of the last two values, except for the first two. 123const fibonacci = n =&gt; Array.from(&#123; length: n&#125;).map(v =&gt; 0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] 一行函数搞定斐波那契数列。这里，王二觉得作者写的有些偏差，实际上，这里不需要map(v =&gt; 0)，如下： 123const fibonacci = n =&gt; Array.from(&#123; length: n&#125;).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []);// fibonacci(5) -&gt; [0,1,1,2,3] 当然，还有其他的解决方案，如下： 12const fibonacci = n =&gt; Array(n).fill(0).reduce((acc, val, i) =&gt; acc.concat(i &gt; 1 ? acc[i - 1] + acc[i - 2] : i), []); 一般的解决思路如下： 1234567const fibonacci = n =&gt;&#123; var out = []; for(var i=0;i&lt;n;i++)&#123; i &gt; 1 ? out.push(out[i-1]+out[i-2]) : out.push(i); &#125; return out ;&#125; 小结：无聊时看两段，每段理解起来不过30秒，实在是居家旅行必备的良品！赶紧戳进来看看]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gitHub上一个很牛的代码库]]></title>
    <url>%2F2017%2F12%2F19%2FgitHub%E4%B8%8A%E4%B8%80%E4%B8%AA%E5%BE%88%E7%89%9B%E7%9A%84%E4%BB%A3%E7%A0%81%E5%BA%93%2F</url>
    <content type="text"><![CDATA[最近Github上出现了一个很牛的代码库30-seconds-of-code，短短一天就有了八千多个star. 这个代码库精心收集了不少有用的JavaScript代码片段，你可以在30秒或更少的时间内理解。实在是居家旅行搭公交坐地铁的必备良品。 戳这里可以看到这个代码库的文档。 在这个代码库里，我看到了之前写的一个算法的另一个实现。之前我写过这么一篇文章一道有趣的算法面试题 文章中描述了这么一个问题： 问题：已知一个字符串，请以字典序写出它的所有排列组合。例如：’asd’的所有排列组就是[“ads”, “asd”, “das”, “dsa”, “sad”, “sda”]；规定：字符串由小写字母组成，且无重复 我当时的写法是这样的： 123456789101112131415 function test (str)&#123; var str = str.split('').sort().join(''); var arr = []; function demo (str,i='')&#123; if(str.length===1)&#123; arr.push(i+str); return; &#125; for(var x=0;x&lt;str.length;x++)&#123; demo(str.substring(0,x)+str.substring(x+1),i+str[x]); &#125; &#125; demo(str); return arr ;&#125; 在30-seconds-of-code代码库里，我又发现了另一种优雅的实现，参考如下代码： 123456const anagrams = str =&gt; &#123; if (str.length &lt;= 2) return str.length === 2 ? [str, str[1] + str[0]] : [str]; return str.split('').reduce((acc, letter, i) =&gt; acc.concat(anagrams(str.slice(0, i) + str.slice(i + 1)).map(val =&gt; letter + val)), []);&#125;;// anagrams('abc') -&gt; ['abc','acb','bac','bca','cab','cba'] 里面用到了 map、reuduce ，代码一气呵成，实在是妙。戳这里可以看它的具体文档。 不过也有一点需要注意，可能是map、reuduce 的性能问题，这个算法的运行速度并没有王二之前所实现的那个算法的运行速度快。不过总的来说，用 map、reuduce 来实现这个算法确实很优雅。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我们这一代人的芳华]]></title>
    <url>%2F2017%2F12%2F17%2F%E6%88%91%E4%BB%AC%E8%BF%99%E4%B8%80%E4%BB%A3%E7%9A%84%E8%8A%B3%E5%8D%8E%2F</url>
    <content type="text"><![CDATA[昨天看了电影《芳华》，感触良多。不仅仅是对男女主人公悲惨境遇的深深同情，更是对时代的思考。 昨天看了电影《芳华》，感触良多。不仅仅是对男女主人公悲惨境遇的深深同情，更是对时代的思考。 事实上，每一代人的生活轨迹都受那个年代的国家政策、政治环境的影响。就像在电影中，那个年代粗犷的标语口号，领袖头像，集体主义，对人性的压抑都深深地刻在文工团每个人的芳华里。也刻在我们父亲辈或者爷爷辈的芳华里。 当文工团宣布要解散，大家吃散伙饭，要各奔东西的那个画面，是不是像极了我们大学毕业，结束学业生涯的那一刻？也是在那一刻，我们也像电影中那样，分道扬镳，天各一方，各自上演着不一样的芳华。多说一句，好久不见，我的老同学们。 王二想，或许20年以后，又会有一个像冯小刚这样厉害的导演，述说着我们这一代人的芳华。那么，什么会刻在我们这一代人的芳华里呢？加入WTO?中国发展的黄金十年？街机？金融危机？北京奥运会？应试教育？长牛楼市？电竞？墙？ 王二很期待那个厉害导演会怎么把故事展开，我们到时候拭目以待。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《理解国际冲突》读后感]]></title>
    <url>%2F2017%2F12%2F17%2F%E3%80%8A%E7%90%86%E8%A7%A3%E5%9B%BD%E9%99%85%E5%86%B2%E7%AA%81%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[过去一段时间，王二读了《理解国际冲突》这本书 最近读了《理解国际冲突》这本书，教科书式的书写风格。王二太年轻，资历尚浅，所以有些章节读的昏昏欲睡，但是这本书仍然带着很多好货，特别是思考国际问题的通用框架-三个层次分析法，写的相当精髓，以下做一个简单的阅读分享： 一、安全困境在无政府状态下，一个国家追求安全的独立行为可能导致所有的国家更不安全。正如伯罗奔尼撒战争的根源，乃是雅典力量的增长及其引起的斯巴达的恐惧。（这里的无政府状态指主权国家之上没有更高一级的权威） 二、思考国际问题的框架——三个层次分析法三层次分析法由肯尼斯·沃尔兹(Kenneth N.Waltz)教授在《个人、国家和战争》(Man, the State, and War)一书中首先提出。这三个层次分别为：个人、国家和国际体系。个人层面指决策者的个人性格倾向，国家层面指国家的国内政治情况，国际体系指当时的国际社会的政治体系。 三、第一次世界大战的起源用三个层次分析法来分析：（1）、在机构层次上：德国的崛起和同盟体系的僵化。原因： 民族主义的兴起 人们对和平产生了自满情绪 德国的政策是含糊不清的（2）、在国内社会和内部政治的层次上：一个正在衰落的奥匈帝国和奥斯曼帝国的内部危及，另一个是德国的国内政治形势。（3）、在个人层次上： 奥匈皇帝是一个疲惫的老人，受康拉将军以及表里不一的外交大臣左右 俄国沙皇尼古拉二世是一个与世隔绝的贵族，深受其多病且神经质妻子影响 德国皇帝是一个有很强自卑感、脾气暴躁的人，特别情感用事 王二认为，民族主义不是坏事，但是不要让民族主义裹挟着政府行事。和平来之不易，国家虽然强大了，导弹精度提高了，五对负重轮也变六对了，我们的腰板也挺直了不少，但也不要想随便弄你弄他的。 四、因果联系的复杂性由于因果具有复杂的特性，所以人们容易在考虑不清因果联系的情况下，把两件看似有关但实则无关联的事情画上连接符号，做出不明智的选择。比如“汉堡包论调”，认为自己在学校餐厅少吃肉就能一定程度上缓解世界粮食短缺的问题，其实不吃汉堡包生下来的粮食并不能到达孟加拉饥民的受众，反而会引起美国市场的商品过剩，更可能引起国内市场价格下跌、农民减少产量等一系列影响。所以，没能看到因果联系的复杂性，可能会使处于良好意愿的行动与其结果向背离。 就像之前砸日系车、堵在肯德基门口不让别人进去吃饭，我们的同胞的出发点是好的，但是实现方式上出现了偏差。不是我们这边一砸，日本就经济危机了，不是我们不吃肯德基，美国就发不出军费了。好好工作，努力创作税收，要比上面的方法强多了。 五、相互关联的误导性相互关联的现象并不一定包含真实的因果关系。例如活在和救火车的出现显然是相互关联的，但是我们不能认为救火车引起了火灾。认为民主国家之间不会发生战争也是这样的思维模式在作怪，因为这个现象之所以会产生的原因也可能在于，民主国家一般是富裕国家，而富裕国家倾向于从事贸易，而根据贸易自由主义理论，富裕国家不太可能交战。即不能简单地有现象引到一个结论，现象有可能与和他最近接的结论并不一致，而是拐了很多的弯，从而和其他结论相连接。 举个例子： 六、什么是民族主义，什么是民族？构建主义者指出，民族的概念是不确定的。按照字典的解释，民族就是声称具有一样认同和有权建立国家的一个群体。但是，它包括哪些群体呢？一样的认同之根源又是什么呢？一种观点认为，民族指在族群上相似的群体，可是美国人尽管在族群上是多样化的，他们仍然属于一个民族。另一种观点认为，民族是有共同语言的的群体，可是瑞士人尽管在语言上是多样化的，但他们仍然同属一个民族。还有人认为，宗教是民族的基础，某些国家，比如以色列和巴基斯坦，是建立在宗教认同的基础之上的。 关键问题是，虽然一个具有一样的认同的群体称自己为一个民族，但是这种认同的根源并不是单一的，而是多样的。法国思想家欧内思特·里纳指出：“民族的核心因素在于，其成员有着很多共同的东西，但同时他们也一定忘却了很多东西。”民族有时候也会被称为“想象的共同体”，因为名族的成员太多，大家相互之间大都不认识，想象起了很大的作用。 民族主义概念很难被界定，因为民族主义既是一个描述性的词，也是一个规范性的词。如果一个词既具描述性，又具规范性，那么它就会成为政治词汇，被应用于权力斗争之中。事实上，民族主义已经成为当代世界中国家合法性的重要源泉。 七、不同群体对政治词汇的使用动机对于一个政治词汇，例如“民族主义”、“帝国主义”或者“全球化”之类的，他们实际上都是含义不清的，人们对他的理解往往也是五花八门、相互矛盾的。政治家和分析家使用政治词汇的动机不一样。政治家希望自己的追随者越多越好，所以他们倾向于使用模糊的语言，并且极力造成一种体现大家共同利益的印象：“我们都在一条船上，大家必须相互合作，都要听我的。”在另一方面，分析家则关注相互间的区别，以便更地理解世界。他们强调，好与坏的问题有程度大小之分。分析家指出，我们所乘坐的那条船可能只是朝着一个人的目的地行驶，或者说一个人划船，另一个人掌舵或免费搭乘。 八、新闻记者、史学家、纪录片编剧会有选择的叙述事实新闻记者、史学家、纪录片编剧大部分时候不会说假话，他们会用事实来陈述正在发生的问题，但他们不会告诉我们在选择事实的时候所遵循和隐藏的原则。 九、1973年石油危机期间，美国为什么没有像伊拉克战争一样在中东使用武力？文中提到了一个有趣的问题：在1973年石油危机期间，为什么世界上最强大的国家竟然允许大量的美元流向弱国，而不使用武力呢？如果它发生在19世纪，那么富国就会使用其占优势的地位和军事权力，把制造麻烦的地区变成自己的殖民地，并且根据自己的意愿解决问题。到1973年的时候，世界发生了哪些变化呢？ 其中一个原因在于：事情远没有消费国希望油价较低，生产国希望油价较高这么简单，现实的政治要比这复杂得多。 具体来讲，消费国里头的生产商希望石油价格较高，那些较小的得克萨斯石油生产商们很高兴看到石油输出国组织提高油价，因为他们与阿拉伯人有着相同的利益。核能生产商看到石油涨价也很高兴，因为这可能促使核能成为一种更具竞争力的能源。欧洲日益衰弱的煤炭行业的经营者以及失业的煤矿工人们看见石油上涨也很高兴。生态保护者认为石油价格上升并不是一件坏事，因为有助于减少消费和污染。 因此，在消费国内部，人们对于油价有不同的利益考虑，如果我们揭开国家利益的面纱，那么就会发现，政治是错综复杂的。消费国内部的一些重要的政治行为体认为，能源价格高涨是值得欢迎的，这些欢迎石油上涨的人事实上结成了一个跨国联盟，他们无形中也加大了国会发动战争的难度。 十、战争会终结吗？康德预言说：从长远来看，人类将由于以下三个原因而超越战争：战争毁灭性的增大，经济相互依存的发展，以及超越主权国家的共和政，府或者我们今天所说的自由民主国家的出现。 王二认为，未来如果人类的足迹只限制在地球上，那么确实会像康德所预言的那样，不会有打的战争发生。但是未来如果人类的脚步迈向星空，那么恐怕又会是另外一幅场景。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《动物农场》读后感]]></title>
    <url>%2F2017%2F12%2F15%2F%E3%80%8A%E5%8A%A8%E7%89%A9%E5%86%9C%E5%9C%BA%E3%80%8B%E8%AF%BB%E5%90%8E%E6%84%9F%2F</url>
    <content type="text"><![CDATA[这是一本先知书 上个礼拜读了一遍乔冶・奥威尔的《动物农场》，今天又读了另一个翻译版本，感触良多。 《动物农场》是一则入木三分的反乌托的政治讽喻寓言。农场的一群动物成功地进行了一场“革命”，将压榨他们的人类东家赶出农场，建立起一个平等的动物社会。然而，动物领袖，那些聪明的猪们最终却篡夺了革命的果实，成为比人类东家更加独裁和极权的统治者。“多一个人看奥威尔，就多了一分自由的保障，”有论家如是说。 这本书似乎有一种魔力，让王二情不自禁的以当代视角带入进去，而且没有什么突兀感，仿佛王二就置身于动物农场之中。 或许正如豆瓣评论里所说：这是一本先知书。 这里王二摘抄一些豆瓣上关于《动物农场》的书评，作为引子： 一、 革命的都是无产阶级，所以一开始不想平等都难。一穷二白的时候最容易产生共识，所以能够行动一致。但是对社会理论（也就是老猪少校那一套论述）的理解和发展，并不是每个动物都能做到。从动物们后来对“七诫”的掌握来看，智力水平的参差不齐明白摆在那里。有的连字母表都背不齐,所以不要指望他们把老少校的教导发展成系统的思想体系。 二、 如果领导只有拿破仑一个了，而且它又掌握了武装力量。它是不是就可以建立阶级统治了？不，经验告诉它如果其他动物感受到专制独裁的话，会再次革命的。所以它需要找到可以为自己可能引起其它动物反抗的做法辩解的方法： （1）、少出现。它出现的次数越多，时间越长，和其他动物接触越多，就越有可能暴露自己的弱点。而这些弱点肯定存在，也肯定跟他英明形象背道而驰。而他出现的少，每次才珍贵。 （2）、找到一个更高的舌头。这个自然是嘎吱的角色。自己亲自说的话会让人不信服。至于说辞，更多的就是永远告诉群众他们有多蠢，领导者想的比他们复杂。比他们深刻，领导者是对的。 （3）、一群傻瓜和一个傻瓜。需要找一匹马，用它的淳朴和忠诚来作正面的、明确的宣传，从而把independent thoughts各个击破。需要找一群羊，来唱些简单而上口的歌，用打太极的方式调和不和谐因素，从而把浑噩浑浊的其他同志们搅和成没有立场的，就更容易改造成正果。 （4）、树立一个敌人。在任何情况下，凝聚力的产生都是在对外的时候。只有树立一个敌人（不管它存在不存在），把大家的仇恨转移到敌人的身上，把所有的苦难都归于敌人的错。才能使人们万众一心，不会怀疑你的领导，而只会默默接受你的领导。 三、 极权不是在我们与资本主义决裂的时候被同时抛弃了， 而是任何制度都会产生的一种东西。作为不能影响政治的人，在你吃不饱、穿不暖、自由受到限制的时候，要相信自己的感官，而不是官方的宣传。并确信，出现这种状况绝对是不正常的。这个时候，极权很可能已经形成了。 四、 你一再批判的所谓的社会不公平，只是因为你没有站在天平翘起的那一端。当我们总是在批判现在制度的腐败时，我们也在为自己认识位高权重的人并为此得利而沾沾自喜。“我上边有人”，并非只是调侃的笑话。每个人在面对利益取舍时都成了不许他人点灯，只许自己放火的独裁者。 中国的历史是能最好地诠释人性潜力的含义的，而《动物农场》在当时则相当精确地预言了中国的未来。这本书虽然不是为了中国而写，却是活生生地在中国铺展开。 如果以上的评价能勾起读者你的兴趣，王二推荐读一下原著，六十多页，不算长，两个小时就能读完，你会得到很多感悟、脑子里会蹦出很多想法。 不过，读完不要乱讲话，老大哥在看着你。 相关推荐阅读：豆瓣读书《动物农场》维基百科《动物农场》(需科学上网)知乎关于《动物农场》的话题 电子书：百度云 秘钥 ：zkq5]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>读书</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现等待wait函数]]></title>
    <url>%2F2017%2F12%2F14%2Fjs%E5%AE%9E%E7%8E%B0%E7%AD%89%E5%BE%85wait%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[以我以前的认知，JS是不能实现阻塞的，除非是alert()、confirm()这样的函数；不过通道巧妙地利用whlie关键字，我们还是可以实现类似JAVA中wait()函数的功能 废话就不多说了，直接上代码： 12345678910111213141516//具体实现方法function wait(ms)&#123; var start = new Date().getTime(); var end = start; while(end &lt; start + ms) &#123; end = new Date().getTime(); &#125;&#125;function demo() &#123; console.log("Hello wanger"); wait(1000); console.log("Hello World ！");&#125;demo() 以上代码中，打印 Hello wanger 一秒后,才会再打印 Hello World ！ 以上的 wait 方法还有一个更精简的实现方式，参考如下代码： 1234function wait(ms)&#123; var start = new Date().getTime(); while (new Date().getTime() &lt; start + ms);&#125;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扩展运算符的简单用法]]></title>
    <url>%2F2017%2F12%2F05%2F%E6%89%A9%E5%B1%95%E8%BF%90%E7%AE%97%E7%AC%A6%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[这篇文章简单介绍一下扩展运算符的一些使用场景 一、获取 arguments 中的参数123456789//ES5function demo1 () &#123; console.log(Array.prototype.slice.apply(arguments)) ;&#125;//ES6function demo2 () &#123; console.log([...arguments]) ;&#125; 二、合并数组例如： 1234// ES5[1, 2].concat(more)// ES6[1, 2, ...more] 再比如： 1234567891011let arr1 = ['a', 'b'];let arr2 = ['c'];let arr3 = ['d', 'e'];// ES5的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 三、字符串反转扩展运算符可以正确识别四个字节的 Unicode 字符,参考如下代码： 123456789let str = 'x\uD83D\uDE80y';//ES5str.split('').reverse().join('')// 'y\uDE80\uD83Dx'//ES6[...str].reverse().join('')// 'y\uD83D\uDE80x' 四、合并对象扩展运算符可以用于合并对象，参考如下代码：123456789var a = &#123;a:1,b:2&#125;var b = &#123;a:3,c:4&#125;var ab = &#123; ...a, ...b &#125;;// &#123;a: 3, b: 2, c: 4&#125;// 等同于var ab = Object.assign(&#123;&#125;, a, b); 参考文档：阮一峰的”ECMAScript 6 入门”MDN文档]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解构赋值的简单用法]]></title>
    <url>%2F2017%2F12%2F04%2F%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E7%9A%84%E7%AE%80%E5%8D%95%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[有时候，ES6中的解构赋值用起来会很方便，这里简单分享一下平时开发中会使用到解构赋值的三个场景 一、交换变量的值1234let x = 1;let y = 2;[x, y] = [y, x]; 二、对象的解构赋值，可以很方便地将现有对象的属性、值或方法，赋值到某个变量。例如，下面的代码会将 Math 对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 1let &#123; floor, round, random &#125; = Math; 在提取 JSON 对象中的数据时，也会方便很多，参考如下代码： 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data &#125; = jsonData;console.log(id, status, data);// 42, "OK", [867, 5309] 需要注意的是，在以上代码中，如果变量名与属性名不一致，需要写成下面这样： 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 三、函数参数的默认值1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，这样就避免了在函数体内部再写类似 var foo = config.foo || &#39;default foo&#39;; 的语句。 参考文档：阮一峰的”ECMAScript 6 入门”]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue中正确配置并使用scss]]></title>
    <url>%2F2017%2F11%2F23%2Fvue%E4%B8%AD%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%E5%B9%B6%E4%BD%BF%E7%94%A8scss%2F</url>
    <content type="text"><![CDATA[scss是个好东西，写起css来很爽，不过vue的脚手架默认没装scss，这时候需要我们额外配置，配置虽然简单，但难免有有时候会出错，于是索性在这里记录一下。如果之前还没有了解过scss,可以先看看这篇博文 一、安装依赖正确加载scss文件需要安装 node-sass 以及 sass-loader,参考以下命令： 1npm install node-sass sass-loader --save-dev 二、修改 webpack.base.conf.js 文件在配置文件的 module.rules 下加上如下规则： 12345&#123; test: /\.scss$/, include:'/src/', loader: 'style-loader!css-loader!sass-loader',&#125; 三、简单的配置过 sass 的脚手架如果参考上述配置后依旧报错，可以参考这个简单的配置过 sass 的脚手架项目，看看里面是如何配置的。 或者选个文件夹敲下如下命令： 1234567891011# 克隆远程代码git clone https://github.com/WangYuLue/vue_sass_cil# 进入克隆的文件夹cd vue_sass_cil# 安装依赖npm install# 运行代码npm run dev]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[猫头鹰选择器]]></title>
    <url>%2F2017%2F11%2F22%2F%E7%8C%AB%E5%A4%B4%E9%B9%B0%E9%80%89%E6%8B%A9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[如果要给所有拥有前一个同胞节点的元素设置 margin-top值，可以有三个写法解决这个问题，在这里做一个备忘 需求是什么？有一个列表，如下： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #main&gt;div&#123; margin-top: 20px; &#125; &lt;/style&gt;&lt;/head&gt; &lt;body&gt; &lt;div id="main"&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;div&gt;hello world&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 现在想让列表里的盒子分开一点，于是给每个盒子一个margin-top属性. 需求是想让列表的第一个盒子不拥有margin-top属性，这时候样式该怎么写？ 解决方法有三个方法可以简单的解决上述问题。 1、使用 not 选择器将上述样式改成如下即可解决： 123#main&gt;div:not(:first-child)&#123; margin-top: 20px;&#125; 2、使用 nth-child() 选择器将上述样式改成如下即可解决： 123#main&gt;div:nth-child(n+2)&#123; margin-top: 20px;&#125; 3、使用猫头鹰选择器将上述样式改成如下即可解决： 123#main&gt;div+div&#123; margin-top: 20px;&#125;]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解浏览器缓存以及304状态码]]></title>
    <url>%2F2017%2F11%2F20%2F%E7%90%86%E8%A7%A3%E6%B5%8F%E8%A7%88%E5%99%A8%E7%BC%93%E5%AD%98%E4%BB%A5%E5%8F%8A304%E7%8A%B6%E6%80%81%E7%A0%81%2F</url>
    <content type="text"><![CDATA[过去没太研究过HTTP,最近有空,看了一些。本文主要讨论浏览器缓存以及304状态码的一些知识，在这里做一个分享 废话少说，先上一张HTTP请求流程图： 一、详细讨论1、是否禁止缓存禁止缓存指的是缓存中不得存储任何关于客户端请求和服务端响应的内容。每次由客户端发起的请求都会下载完整的响应内容。 在请求头中，Cache-Control: no-store与Pragma: no-cache都可以禁止缓存， 但两者也有区别，Pragma: no-cache可以兼容http 1.0 ，而Cache-Control: no-store是http 1.1提供的。因此，Pragma: no-cache可以应用到http 1.0和http 1.1,而Cache-Control: no-store只能应用于http 1.1。 2、是否检查本地副本是否过期是否检查本地版本是否过期主要由Cache-Contro 的 no-cache和must-revalidate这两个可选值控制，其中： no-cache: 告诉浏览器、缓存服务器，不管本地副本是否过期，使用资源副本前，一定要到源服务器进行副本有效性校验。 must-revalidate：告诉浏览器、缓存服务器，本地副本过期前，可以使用本地副本；本地副本一旦过期，必须去源服务器进行有效性校验。 3、本地副本是否过期想要知道本地副本是否过期，我们就需要了解缓存的过期机制： (1)、过期机制中，最重要的指令是 max-age=&lt;seconds&gt;,它表示资源能够被缓的最大时间；它通常会和must-revalidate一起使用，使用起来就像下面这样： 1Cache-Control: max-age=60, must-revalidate (2)、如果不含有max-age属性，则会去查看是否包含Expires属性，，通过比较Expires的值和头里面Date属性的值来判断是否缓存还有效。 (3)、如果 max-age 和 expires 属性都没有，找找头里的 Last-Modified 信息。如果有，缓存的寿命就等于头里面 Date的值减去Last-Modified的值除以10（注：根据rfc2626其实也就是乘以10%）。 4、如果本地副本没有过期如果本地副本没有过期，则会直接重缓存中读取资源，并返回200状态码。 5、如果本地副本过期如果本地副本过期，则会进行到源服务器进行有效性校验的前期准备。 首先，会在请求头里寻找If-None-Match字段，其值为服务器上次返回的ETag响应头的值: 如果请求头里没有If-None-Match字段，则会在请求头中寻找If-Modified-Since字段，其值为服务器上次返回的Last-Modified响应头中的日期值： 如果If-None-Match与If-Modified-Since都没有，则会直接向服务器请求数据。 6、到源服务器进行有效性校验如果请求头中带有If-None-Match或If-Modified-Since，则会到源服务器进行有效性校验，如果源服务器资源没有变化，则会返回304；如果有变化，则返回200； 7、上述的一些流程还可以用下图来表示 二、补充私有缓存和公共缓存在Cache-Control还有两个值：private与public，其中： public 指令表示该响应可以被任何中间人（比如中间代理、CDN等）缓存。若指定了 public ，则一些通常不被中间人缓存的页面（因为默认是 private）（比如 带有HTTP验证信息（帐号密码）的页面 或 某些特定影响状态码的页面），将会被其缓存。 而 private 则表示该响应是专用于某单个用户的，中间人不能缓存此响应，该响应只能应用于浏览器私有缓存中。 三、参考文档HTTP协议MDNsegmentfault网站上’赵雍’的回答‘紫云飞’的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中图片压缩的一般方法]]></title>
    <url>%2F2017%2F11%2F13%2FJS%E4%B8%AD%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E7%9A%84%E4%B8%80%E8%88%AC%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前两天公司业务上有需求需要将较大的图片压缩后再传到远程服务器，网上找了不少方法都不太好用，今天有空索性自己写了一个方法，并把它放到了自己的github上，有兴趣的同学可以戳这里 一、需求是什么？首先想一想我们有哪些需求？大多时候我们需要将一个File对象压缩之后再变为File对象传入到远程图片服务器；有时候我们也需要将一个base64字符串压缩之后再变为base64字符串传入到远程数据库；有时候后它还有可能是一块canvas画布，或者是一个Image对象，或者直接就是一个图片的url地址，我们需要将它们压缩上传到远程；面对这么多的需求，王二索性画了一张图： 二、解决办法如上图所示，王二一共写了七个方法，基本覆盖了JS中大部分文件类型的转换与压缩，其中： 1、urltoImage(url,fn) 会通过一个url加载所需要的图片对象，其中url参数传入图片的url,fn为回调方法,包含一个Image对象的参数，代码如下： 1234567function urltoImage (url,fn)&#123; var img = new Image(); img.src = url; img.onload = function()&#123; fn(img); &#125;&#125;; 2、imagetoCanvas(image)会将一个Image对象转变为一个Canvas类型对象，其中image参数传入一个Image对象，代码如下： 12345678function imagetoCanvas(image)&#123; var cvs = document.createElement("canvas"); var ctx = cvs.getContext('2d'); cvs.width = image.width; cvs.height = image.height; ctx.drawImage(image, 0, 0, cvs.width, cvs.height); return cvs ;&#125;; 3、canvasResizetoFile(canvas,quality,fn)会将一个Canvas对象压缩转变为一个Blob类型对象；其中canvas参数传入一个Canvas对象;quality参数传入一个0-1的number类型，表示图片压缩质量;fn为回调方法，包含一个Blob对象的参数;代码如下： 12345function canvasResizetoFile(canvas,quality,fn)&#123; canvas.toBlob(function(blob) &#123; fn(blob); &#125;,'image/jpeg',quality);&#125;; 这里的Blob对象表示不可变的类似文件对象的原始数据。Blob表示不一定是JavaScript原生形式的数据。 File接口基于Blob，继承了Blob的功能并将其扩展使其支持用户系统上的文件。我们可以把它当做File类型对待，其他更具体的用法可以参考MDN文档 4、canvasResizetoDataURL(canvas,quality) 会将一个Canvas对象压缩转变为一个dataURL字符串,其中canvas参数传入一个Canvas对象;quality参数传入一个0-1的number类型，表示图片压缩质量;代码如下： 123methods.canvasResizetoDataURL = function(canvas,quality)&#123; return canvas.toDataURL('image/jpeg',quality);&#125;; 其中的 toDataURL API可以参考MDN文档 5、filetoDataURL(file,fn) 会将 File（Blob）类型文件转变为dataURL字符串,其中 file 参数传入一个File（Blob）类型文件;fn为回调方法，包含一个dataURL字符串的参数;代码如下： 1234567function filetoDataURL(file,fn)&#123; var reader = new FileReader(); reader.onloadend = function(e)&#123; fn(e.target.result); &#125;; reader.readAsDataURL(file);&#125;; 6、dataURLtoImage(dataurl,fn) 会将一串dataURL字符串转变为Image类型文件,其中dataurl参数传入一个dataURL字符串,fn为回调方法，包含一个Image类型文件的参数，代码如下： 1234567function dataURLtoImage(dataurl,fn)&#123; var img = new Image(); img.onload = function() &#123; fn(img); &#125;; img.src = dataurl;&#125;; 7、dataURLtoFile(dataurl) 会将一串dataURL字符串转变为Blob类型对象，其中dataurl参数传入一个dataURL字符串,代码如下： 12345678function dataURLtoFile(dataurl) &#123; var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1], bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n); while(n--)&#123; u8arr[n] = bstr.charCodeAt(n); &#125; return new Blob([u8arr], &#123;type:mime&#125;);&#125;; 三、进一步封装对于常用的将一个File对象压缩之后再变为File对象,我们可以将上面的方法再封装一下，参考如下代码： 1234567function fileResizetoFile(file,quality,fn)&#123; filetoDataURL (file,function(dataurl)&#123; dataURLtoImage(dataurl,function(image)&#123; canvasResizetoFile(imagetoCanvas(image),quality,fn); &#125;) &#125;)&#125; 其中，file参数传入一个File（Blob）类型文件；quality参数传入一个0-1的number类型，表示图片压缩质量；fn为回调方法，包含一个Blob类型文件的参数。 它使用起来就像下面这样： 12345var file = document.getElementById('demo').files[0];fileResizetoFile(file,0.6,function(res)&#123; console.log(res); //拿到res，做出你要上传的操作；&#125;) 这样的话，图片压缩上传就能轻松地搞定了，以上的8个方法我已经封装好放到github上了，喜欢的话可以使劲的star哈。 参考文档：MDN]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>图片压缩</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[信息过剩与极简主义]]></title>
    <url>%2F2017%2F11%2F12%2F%E4%BF%A1%E6%81%AF%E8%BF%87%E5%89%A9%E4%B8%8E%E6%9E%81%E7%AE%80%E4%B8%BB%E4%B9%89%2F</url>
    <content type="text"><![CDATA[由于信息爆炸，很多人都有有限精力和信息过剩之间的矛盾，这时候需要确定自己真正想要什么，闭源开流，只接受对自己有益的信息，做一个极简主义者。 不知道什么时候，王二养成了不少坏习惯。周末假期，王二会漫无目的地刷知乎、微博、朋友圈刷一下午,晚饭过后,什么也记不得了；有时候，也会一口气下载了几百本电子书，却重来没有阅读过；微博、知乎上有大量的收藏但再没翻开过；手机上很多APP，但经常用的却没几个；有时候甚至会在头条、知乎、微博的按钮之间迷茫，实在不知道该点开哪一个。王二知道，自己出问题了。 我想，这不单单是王二才有的问题，生在这个时代，我们多多少少会有上面的毛病。信息爆炸是互联网赋予给这个时代的特征，表面上的选择是非常多了，但是我们往往却不知所错，获取信息的手段实在是太低廉了，点开一个按钮，就能了解到世界上发生了什么，何况还有那么多按钮。你甚至不用主动获取，这些APP就会自动推送消息给你。 小些时候包个5元钱30兆流量，手机上只有个浏览器，逛逛论坛水水贴吧，流量还要省着花，快乐感也要比现在强不少。 理论上，如果两个人都能连上互联网，那么在接受信息方面，他们是平等的，都有能力获得相同的信息。那么，互联网弥平了信息的差距了吗？没有。 举个例子，同样是使用微信，有些大叔会把它当做赌博工具；同样是微信公众号，有些大妈却更偏爱于风水养生；还有美剧，有些人把它当做练习英语口语来看，还有人当做言情故事来看；再拿知乎的打开方式来说，自己主动到知乎检索问题和被动地接收知乎算法的推荐所得到的收获，那差距堪比法拉利之与永久，清华学霸之于我。 由于信息筛选能力以及方向的差异，接受信息的差距非但没有缩小，反而扩大了。 于是出现了一个有趣现象，很多人刷了那么多微博，还是讲不出段子，刷了那么多知乎，还是写不出好的故事，看了那么多美剧，英语口语却一直没有长进。每天早上一觉醒来，又能记得多少昨天看了什么。 事实上，很多人都面临着一个矛盾，即个人有限精力和信息过剩之间的矛盾。 拿王二来说，在过去一段时间里，为了做好自己的时间管理，王二下载了大量关于APP。它们各有特色，有的可以设置自己的每日必做、每周必做清单，还有提醒功能；有些可以记录过去一天做了哪些事情，还可以插入图片，高级版的还可以插入语音；有些还可以生成漂亮的时间线的，记录去年同期你正在干什么事情；有些可以记录下过去时间里对你产生重大影响的时刻，而且UI做的非常漂亮；有些还允许你像手记那样随心记录，不拘泥于格式；有些app便签还可以分成很多类，工作上的、生活上的、社交上的；有些做的很激进的，打开这个app 后就不能用其他的app 了；更有厉害的会让你记录此时此刻你正在什么地方干了些什么，而且会生成很多图表帮你分析时间用到哪里了，有哪些需要改进的地方。 王二开始非常兴奋，有这些管理工具，自己的生活一定会井井有条。然而事与愿违，生活再一次失控。实不相瞒，很多app打开一次后便再也没有打开第二次。 王二了解自己的焦虑——这么牛逼的功能不用会不会降低我生活的效率，就像平时刷知乎、微博，生怕一天不刷就是错过了什么大事。我们都希望抓住对自己一切有用的东西，但是往往事与愿违，精力有限。不要高估自己，误以为自己有足够的精力可以妥善处理好自己关注的所有事物。 我们需要花一段时间了解自己的目标是什么，自己想要成为什么样的人。是自媒体时代的弄潮儿？IT行业的技术专家？证券市场上叱咤风云的操盘手？还是泡满一百个姑娘的情场浪子？确定好以后，闭源开流，贯彻极简主义精神，只接受有利于达成目标的信息，处理过去的冗余信息。 就像是在一片肥沃的黑土地上，漫无目的的接受信息就像是随手抓起一把种子撒向这片土地，最终也会因为营养不良长出一片矮小的灌木丛。我们只需要少量几颗种子，定期为他们除草施肥，细心栽培，陪伴他们慢慢长大。但是要注意，时间有限，我们除草施肥的时间不多，如果树木太多而我们都又兼顾的话，那么可能他们长的都不会太好。如果是这样，就砍掉一些树吧，虽然有时候不忍心，但是必须要做出这样的抉择。单个树木也是，如果让他的枝叶肆意生长，终究长不太高，我需要定期修建，虽然有时候会不太舍得，但也是为了树木更好的成长。 我们还需要维护好自己的时间线，关掉不感兴趣的APP推送，或者直接删掉这些APP；取关已经累积数十条没看的公众号；退出不感兴趣的的群聊；删掉微信里也不知道是什么时候加的好友；屏蔽微商的朋友圈；删除自己一年不联系的联系人；少打游戏；给自己一些限制，只关注10个公众号，手机第一页只放10个常用的APP，我们需要的真的不是很多。 像王二这样自控力不强，有时候自己不能控制自己的，可以整理一份自己的“无聊时就做”清单，“无聊时就做”清单有三个原则：1、不要太多（不超过10条），适时更新；2、对自己的目标有益；3、促进思维发散，需要集中思考的不要放在清单里。 当自己打算做玩游戏、刷盆友圈、刷知乎这些“坏事情”时，请先过目一下自己的“无聊时就做”清单，它就像计算机语言中的“过滤器”，如果“无聊时就做”清单里的事情都提不起你的兴趣，那好吧，“过滤器”放行，你就去做这些“坏事情”吧。需要注意的的，自己“无聊时就做”清单并不意味着里面就不能有刷盆友圈，刷知乎，看美剧的选项，但是目标一定要具体，比如“阅读知乎上关于机器学习话题下精华部分前十高赞的回答并做笔记”，“看看好久不见的xx老朋友又发了哪些动态”，“看一集Rick and Morty”，”做五组俯卧撑”。 对于过去照片、文档、演讲稿、浏览器收藏以及其他个人资料，我们要做好心理准备，下好决心，清理掉那些自认为还有用但是以后再也不会用到的信息。 过去就像一个每个位置上都铺满厚厚纸片的房子，纸片中有不少重要线索，它们记录着过去的理想，过去生活的瞬间，过去你的认为及其重要的东西，过去的开心与快乐，过去的精神状况。这是生命中最珍贵的一部分回忆，你或许根本不想打乱他们，移动他们的位置，模糊了它们最初的模样，只是想在闲暇时间翻翻这些纸片，看看过去的自己。但不管怎么说，房间是要打扫一下了，虽然这会让自己的过去失真，但是不这样做的话纸片会越铺越厚，这些线索也会更加难以找到，我们只能筛选出一些值得纪念的纸片，把它们整理好，归档放到文件夹内。其他的，通通扔进垃圾桶。 不仅要把房间打扫干净，还要维持好这种状态，定期整理未处理的信息，不要吧纸片扔的满房间都是了。秩序，需要在我们内心的最底层建立。 如果读者你认为这篇文章有一些参考意义并打算将之付诸于实践，那有一点必须要提醒一下：只关注自己感兴趣的东西也会带来一些副作用，如果自己的时间线上都只限定于那几个化题，那么自我观点会不断的强化，认为自己关注的事物就是这世界的全部。就像头条刷多了推送的都是自己感兴趣的话题，实际上这会限制自己的视野，忽略了其他有趣的事情，这时候就需要加入一些“不和谐”的因素，刷刷知乎、Filpboard 就是不错的选择，但是也不要用力过猛，一刷就是一下午。 事实上，做好上面几点很难，这是一个系统工程，需要花费不少时间。把自己想象成是一个公司，你就是管理这个公司的CEO，管理好这个公司需要艺术，更需要耐心，但是值得尝试。 逻辑有些混乱，最后我用一句话总结一下这篇文章讲了什么：由于信息爆炸，很多人都有有限精力和信息过剩之间的矛盾，这时候需要确定自己真正想要什么，闭源开流，只接受对自己有益的信息，做一个极简主义者。]]></content>
      <categories>
        <category>王二说</category>
      </categories>
      <tags>
        <tag>时间管理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript 初体验（三）]]></title>
    <url>%2F2017%2F11%2F08%2Ftypescript-%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近vue2.5发布，其中提到了将大力加强对TypeScript和VSCode的支持，之前一直用VSCode开发，但是对TypeScript鲜有了解，于是最近有空看了一些TypeScript的基础语法，并在这里做一个小结。 需要注意的是，这篇文章是王二本人在刷了一遍TypeScript的语法后，认为有些地方需要着重注意，于是在这里做的一个小总结。如果需要系统的过一遍TypeScript的语法，这里重点推荐微软大神xcatliu的TypeScript辅导教程，王二就是看的这篇教程写的这篇文章，也可以看TypeScript文档(中文)系统了解 一、类型别名一个简单的例子： 1234567891011type Name = string;type NameResolver = () =&gt; string;type NameOrResolver = Name | NameResolver;function getName(n: NameOrResolver): Name &#123; if (typeof n === 'string') &#123; return n; &#125; else &#123; return n(); &#125;&#125; 上例中，我们使用 type 创建类型别名。 类型别名常用于联合类型。 二、字符串字面量类型字符串字面量类型用来约束取值只能是某几个字符串中的一个，举一个简单的例子： 123456789type EventNames = 'click' | 'scroll' | 'mousemove';function handleEvent(ele: Element, event: EventNames) &#123; // do something&#125;handleEvent(document.getElementById('hello'), 'scroll'); // 没问题handleEvent(document.getElementById('world'), 'dbclick'); // 报错，event 不能为 'dbclick'// index.ts(7,47): error TS2345: Argument of type '"dbclick"' is not assignable to parameter of type 'EventNames'. 上例中，我们使用 type 定了一个字符串字面量类型 EventNames，它只能取三种字符串中的一种。 注意，类型别名与字符串字面量类型都是使用 type 进行定义。 三、类我们先来回顾一下ES6中类的用法，这里当然推荐阮一峰大神的ES6-class教程，或者王二总结的ES6中类的使用简明教程 TypeScript 有三种访问修饰符（Access Modifiers），分别是 public、private 和 protected: public 修饰的属性或方法是公有的，可以在任何地方被访问到，默认所有的属性和方法都是 public 的 private 修饰的属性或方法是私有的，不能在声明它的类的外部访问 protected 修饰的属性或方法是受保护的，它和 private 类似，区别是它在子类中也是允许被访问的 这里和Java的访问修饰符很像，Java还多一个default 例如，有时候我们希望有的属性是无法直接存取的，这时候就可以用 private 了： 12345678910111213class Animal &#123; private name; public constructor(name) &#123; this.name = name; &#125;&#125;let a = new Animal('Jack');console.log(a.name); // Jacka.name = 'Tom';// index.ts(9,13): error TS2341: Property 'name' is private and only accessible within class 'Animal'.// index.ts(10,1): error TS2341: Property 'name' is private and only accessible within class 'Animal'. 需要注意的是，TypeScript 编译之后的代码中，并没有限制 private 属性在外部的可访问性。 而且使用 private 修饰的属性或方法，在子类中也是不允许访问的;而如果是用 protected 修饰，则允许在子类中访问。 给类加上 TypeScript 的类型很简单，与接口类似： 123456789101112class Animal &#123; name: string; constructor(name: string) &#123; this.name = name; &#125; sayHi(): string &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a: Animal = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 四、类与接口接口（Interfaces）可以不但可以用于对「对象的形状（Shape）」进行描述，而且可以对类的一部分行为进行抽象。 实现（implements）是面向对象中的一个重要概念。一般来讲，一个类只能继承自另一个类，有时候不同类之间可以有一些共有的特性，这时候就可以把特性提取成接口（interfaces），用 implements 关键字来实现。这个特性大大提高了面向对象的灵活性。 举例来说，门是一个类，防盗门是门的子类。如果防盗门有一个报警器的功能，我们可以简单的给防盗门添加一个报警方法。这时候如果有另一个类，车，也有报警器的功能，就可以考虑把报警器提取出来，作为一个接口，防盗门和车都去实现它： 123456789101112131415161718interface Alarm &#123; alert();&#125;class Door &#123;&#125;class SecurityDoor extends Door implements Alarm &#123; alert() &#123; console.log('SecurityDoor alert'); &#125;&#125;class Car implements Alarm &#123; alert() &#123; console.log('Car alert'); &#125;&#125; 一个类可以实现多个接口： 1234567891011121314151617181920interface Alarm &#123; alert();&#125;interface Light &#123; lightOn(); lightOff();&#125;class Car implements Alarm, Light &#123; alert() &#123; console.log('Car alert'); &#125; lightOn() &#123; console.log('Car light on'); &#125; lightOff() &#123; console.log('Car light off'); &#125;&#125; 上例中，Car 实现了 Alarm 和 Light 接口，既能报警，也能开关车灯。 五、混合类型之前学习过，可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 有时候，一个函数还可以有自己的属性和方法,这时候可以使用混合类型： 1234567891011121314151617interface Counter &#123; (start: number): string; interval: number; reset(): void;&#125;function getCounter(): Counter &#123; let counter = &lt;Counter&gt;function (start: number) &#123; &#125;; counter.interval = 123; counter.reset = function () &#123; &#125;; return counter;&#125;let c = getCounter();c(10);c.reset();c.interval = 5.0; 六、泛型泛型（Generics）是指在定义函数、接口或类的时候，不预先指定具体的类型，而在使用的时候再指定类型的一种特性。 例如，我们来实现一个函数 createArray，它可以创建一个指定长度的数组，同时将每一项都填充一个默认值： 123456789function createArray(length: number, value: any): Array&lt;any&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray(3, 'x'); // ['x', 'x', 'x'] 以上代码有一个显而易见的缺陷是：它并没有准确的定义返回值的类型。 Array&lt;any&gt; 允许数组的每一项都为任意类型。但是我们预期的是，数组中每一项都应该是输入的 value 的类型。 这时候，泛型就派上用场了： 123456789function createArray&lt;T&gt;(length: number, value: T): Array&lt;T&gt; &#123; let result = []; for (let i = 0; i &lt; length; i++) &#123; result[i] = value; &#125; return result;&#125;createArray&lt;string&gt;(3, 'x'); // ['x', 'x', 'x'] 上例中，我们在函数名后添加了 &lt;T&gt;，其中 T 用来指代任意输入的类型，在后面的输入 value: T 和输出 Array&lt;T&gt; 中即可使用了。 还有 多个类型参数、泛型约束、泛型接口、泛型类的概念，有兴趣可以了解这篇文章 最后：着重提醒：这篇文章大部分摘录自微软大神xcatliu的TypeScript辅导教程，读者直接阅读大神的教程效果会更佳哦！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript 初体验（二）]]></title>
    <url>%2F2017%2F11%2F08%2Ftypescript-%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近vue2.5发布，其中提到了将大力加强对TypeScript和VSCode的支持，之前一直用VSCode开发，但是对TypeScript鲜有了解，于是最近有空看了一些TypeScript的基础语法，并在这里做一个小结。 需要注意的是，这篇文章是王二本人在刷了一遍TypeScript的语法后，认为有些地方需要着重注意，于是在这里做的一个小总结。如果需要系统的过一遍TypeScript的语法，这里重点推荐微软大神xcatliu的TypeScript辅导教程，王二就是看的这篇教程写的这篇文章，也可以看TypeScript文档(中文)系统了解 一、接口在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implements）。 TypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述，参考如下代码： 123456789interface Person &#123; name: string; age: number;&#125;let tom: Person = &#123; name: 'Tom', age: 25&#125;; 上面的例子中，我们定义了一个接口 Person，接着定义了一个变量 tom，它的类型是 Person。这样，我们就约束了 tom 的形状必须和接口 Person 一致。 但是这个时候变量少了或者多了都会报错，我们可以用可选属性、任意属性、只读属性来进一步制定接口，详细可以了解这篇文章 二、定义数组类型在 TypeScript 中，数组类型有多种定义方式，比较灵活。 以下三种方式都可以定义数组：123456789//最简单的方法是使用「类型 + 方括号」来表示数组：let fibonacci1: number[] = [1, 1, 2, 3, 5];//也可以使用数组泛型（Array Generic） Array&lt;elemType&gt; 来表示数组：let fibonacci2: Array&lt;number&gt; = [1, 1, 2, 3, 5];//接口也可以用来描述数组：interface NumberArray &#123; [index: number]: number;&#125;let fibonacci3: NumberArray = [1, 1, 2, 3, 5]; 以上的代码中，数组中类型要求一致，如果想允许出现任意类型，可以用 any ： 1let list: any[] = ['Wanger', 22, &#123; website: 'http://www.wangyulue.com' &#125;]; Typescript 还实现了常见的类数组的接口定义，如 IArguments, NodeList, HTMLCollection 等，例如接受函数内的 arguments 对象： 123function sum() &#123; let args: IArguments = arguments;&#125; 三、约束函数的类型在 Typescript 中也可以约束函数的输入和输出，参考如下代码： 123function sum(x: number, y: number): number &#123; return x + y;&#125; 这时候 sum 函数被约束为只接受两个 number 类型并输出为一个 number 类型的函数。 现在哪怕输入多余的（或者少于要求的）参数，都是不被允许的： 123456789101112function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1, 2, 3);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target.function sum(x: number, y: number): number &#123; return x + y;&#125;sum(1);// index.ts(4,1): error TS2346: Supplied parameters do not match any signature of call target. 我们也可以使用接口的方式来定义一个函数需要符合的形状： 12345678interface SearchFunc &#123; (source: string, subString: string): boolean;&#125;let mySearch: SearchFunc;mySearch = function(source: string, subString: string) &#123; return source.search(subString) !== -1;&#125; 这时候其实还有 可选参数、参数默认值、剩余参数、重载的概念，有兴趣可以了解这篇文章 四、申明文件假如我们想使用第三方库，比如 jQuery，我们通常这样获取一个 id 是 foo 的元素： 123$('#foo');// orjQuery('#foo'); 但是在 TypeScript 中，我们并不知道 $ 或 jQuery 是什么东西： 123jQuery('#foo');// index.ts(1,1): error TS2304: Cannot find name 'jQuery'. 这时，我们需要使用 declare 关键字来定义它的类型，帮助 TypeScript 判断我们传入的参数类型： 123declare var jQuery: (string) =&gt; any;jQuery('#foo'); declare 定义的类型只会用于编译时的检查，编译结果中会被删除。 上例的编译结果是： 1jQuery('#foo'); 通常我们会把类型声明抽出来放到一个单独的文件中，这就是声明文件： 123// jQuery.d.tsdeclare var jQuery: (string) =&gt; any; 我们约定声明文件以 .d.ts 为后缀。 然后在使用到的文件的开头，用「三斜线指令」表示引用了声明文件： 123/// &lt;reference path="./jQuery.d.ts" /&gt;jQuery('#foo'); 当然，jQuery 的声明文件不需要我们定义了，已经有人帮我们定义好了：jQuery in DefinitelyTyped。 我们可以直接下载下来使用，但是更推荐的是使用工具统一管理第三方库的声明文件。 社区已经有多种方式引入声明文件，不过 TypeScript 2.0 推荐使用 @types 来管理。 @types 的使用方式很简单，直接用 npm 安装对应的声明模块即可，以 jQuery 举例： npm install @types/jquery –save-dev 可以在这个页面搜索你需要的声明文件。 五、内置对象ECMAScript标准提供的内置对象有： Boolean、Error、Date、RegExp 等。 我们可以在 TypeScript 中将变量定义为这些类型： 1234let b: Boolean = new Boolean(1);let e: Error = new Error('Error occurred');let d: Date = new Date();let r: RegExp = /[a-z]/; 更多的内置对象，可以查看 MDN 的文档。 而他们的定义文件，则在 TypeScript 核心库的定义文件中。 最后：着重提醒：这篇文章大部分摘录自微软大神xcatliu的TypeScript辅导教程，读者直接阅读大神的教程效果会更佳哦！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Typescript 初体验（一）]]></title>
    <url>%2F2017%2F11%2F07%2Ftypescript-%E5%88%9D%E4%BD%93%E9%AA%8C%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近vue2.5发布，其中提到了将大力加强对TypeScript和VSCode的支持，之前一直用VSCode开发，但是对TypeScript鲜有了解，于是最近有空看了一些TypeScript的基础语法，并在这里做一个小结。 需要注意的是，这篇文章是王二本人在刷了一遍TypeScript的语法后，认为有些地方需要着重注意，于是在这里做的一个小总结。如果需要系统的过一遍TypeScript的语法，这里重点推荐微软大神xcatliu的TypeScript辅导教程，王二就是看的这篇教程写的这篇文章，也可以看TypeScript文档(中文)系统了解 一、什么是 TypeScriptTypeScript 是 JavaScript 的类型的超集，它可以编译成纯 JavaScript。编译出来的 JavaScript 可以运行在任何浏览器上。TypeScript 编译工具可以运行在任何服务器和任何系统上。TypeScript 是开源的。 二、TypeScript 的特点王二认为 TypeScript 最大的特点是 可以进行静态检查语法，可以在编译阶段就发现大部分错误，这一点和java很像。 而且 TypeScript 是 JavaScript 的超集，.js 文件可以直接重命名为 .ts 即可。 三、安装 TypeScriptTypeScript 的命令行工具安装方法如下： npm install -g typescript 以上命令会在全局环境下安装 tsc 命令，安装完成之后，我们就可以在任何地方执行 tsc 命令了。 我们约定使用 TypeScript 编写的文件以 .ts 为后缀， 编译一个 TypeScript 文件很简单： tsc hello.ts 然后就会在 hello.ts 同一级的目录下生成一个 hello.js文件。 四、推荐编辑器当然是推荐Visual Studio Code啦，它本身就是由 TypeScript 编写的，而且天然支持对 TypeScript 支持。 五、一个简单的例子将以下代码复制到 hello.ts 中： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = 'Tom';console.log(sayHello(user)); 然后执行 tsc hello.ts 这时候会生成一个编译好的文件 hello.js： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = 'Tom';console.log(sayHello(user)); TypeScript 中，使用 : 指定变量的类型，: 的前后有没有空格都可以。 上述例子中，我们用 : 指定 person 参数类型为 string。但是编译为 js 之后，并没有什么检查的代码被插入进来。 如果发现有错误，编译的时候就会报错。 下面尝试把这段代码编译一下： 123456function sayHello(person: string) &#123; return 'Hello, ' + person;&#125;let user = [0, 1, 2];console.log(sayHello(user)); 编辑器中会提示错误，编译的时候也会出错： index.ts(6,22): error TS2345: Argument of type ‘number[]’ is not assignable to parameter of type ‘string’. 但是还是生成了 js 文件： 12345function sayHello(person) &#123; return 'Hello, ' + person;&#125;var user = [0, 1, 2];console.log(sayHello(user)); TypeScript 编译的时候即使报错了，还是会生成编译结果，我们仍然可以使用这个编译之后的文件。 六、空值JavaScript 没有空值（Void）的概念，在 TypeScirpt 中，可以用 void 表示没有任何返回值的函数： 123function alertName(): void &#123; alert('My name is Tom');&#125; 声明一个 void 类型的变量没有什么用，因为你只能将它赋值为 undefined 和 null： 1let unusable: void = undefined; 七、Null 和 Undefined在 TypeScript 中，可以使用 null 和 undefined 来定义这两个原始数据类型： 12let u: undefined = undefined;let n: null = null; undefined 类型的变量只能被赋值为 undefined，null 类型的变量只能被赋值为 null。 与 void 的区别是，undefined 和 null 是所有类型的子类型。也就是说 undefined 类型的变量，可以赋值给 number 类型的变量： 12345// 这样不会报错let num: number = undefined;// 这样也不会报错let u: undefined;let num: number = u; 而 void 类型的变量不能赋值给 number 类型的变量： 1234let u: void;let num: number = u;// index.ts(2,5): error TS2322: Type 'void' is not assignable to type 'number'. 八、任意值任意值（Any）用来表示允许赋值为任意类型，参考如下代码： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 但如果是 any 类型，则允许被赋值为任意类型。 12let myFavoriteNumber: any = 'seven';myFavoriteNumber = 7; 变量如果在声明的时候，未指定其类型，那么它会被识别为任意值类型 九、类型推论如果没有明确的指定类型，那么 TypeScript 会依照类型推论（Type Inference）的规则推断出一个类型。 以下代码虽然没有指定类型，但是会在编译的时候报错： 1234let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 事实上，它等价于： 1234let myFavoriteNumber: string = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. TypeScript 会在没有明确的指定类型的时候推测出一个类型，这就是类型推论。 ##如果定义的时候没有赋值，不管之后有没有赋值，都会被推断成 any 类型而完全不被类型检查：## 123let myFavoriteNumber;myFavoriteNumber = 'seven';myFavoriteNumber = 7; 十、联合类型联合类型（Union Types）表示取值可以为多种类型中的一种。 例如上面的代码： 1234let myFavoriteNumber = 'seven';myFavoriteNumber = 7;// index.ts(2,1): error TS2322: Type 'number' is not assignable to type 'string'. 用联合类型写就不会报错： 12let myFavoriteNumber :(string|number) = 'seven';myFavoriteNumber = 7; 最后：着重提醒：这篇文章大部分摘录自微软大神xcatliu的TypeScript辅导教程，读者直接阅读大神的教程效果会更佳哦！]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>typescript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6中类的使用简明教程]]></title>
    <url>%2F2017%2F11%2F07%2FES6%E4%B8%AD%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8%E7%AE%80%E6%98%8E%E6%95%99%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[系统地梳理一遍JS中的类应该如何使用 一、开始JavaScript 语言中，生成实例对象的传统方法是通过构造函数。下面是一个例子 12345678910function Animal(x, y) &#123; this.x = x; this.y = y;&#125;Animal.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')';&#125;;var p = new Animal(1, 2); 上面这种写法跟传统的面向对象语言（比如 C++ 和 Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。 基本上，ES6 的class可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用 ES6 的class改写，就是下面这样: 1234567891011//定义类class Animal &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125; 二、属性和方法使用 class 定义类，使用 constructor 定义构造函数。 通过 new 生成新实例的时候，会自动调用构造函数。 1234567891011class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;let a = new Animal('Jack');console.log(a.sayHi()); // My name is Jack 需要注意的是。类的内部所有定义的方法，都是不可枚举的（non-enumerable），这一点与 ES5 的行为不一致。 三、constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 1234567class Animal &#123;&#125;// 等同于class Animal &#123; constructor() &#123;&#125;&#125; 四、实例的属性与 ES5 一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 12345678910111213141516171819202122//定义类class Animal &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; toString() &#123; return '(' + this.x + ', ' + this.y + ')'; &#125;&#125;var animal = new Animal(2, 3);animal.toString() // (2, 3)animal.hasOwnProperty('x') // trueanimal.hasOwnProperty('y') // trueanimal.hasOwnProperty('toString') // falseanimal.__proto__.hasOwnProperty('toString') // true 五、不存在变量提升类不存在变量提升（hoist），这一点与 ES5 完全不同。 12new Animal(); // ReferenceErrorclass Animal &#123;&#125; 六、类的继承使用 extends 关键字实现继承，子类中使用 super 关键字来调用父类的构造函数和方法。 123456789101112131415161718192021class Animal &#123; constructor(name) &#123; this.name = name; &#125; sayHi() &#123; return `My name is $&#123;this.name&#125;`; &#125;&#125;class Cat extends Animal &#123; constructor(name) &#123; super(name); // 调用父类的 constructor(name) console.log(this.name); &#125; sayHi() &#123; return 'Meow, ' + super.sayHi(); // 调用父类的 sayHi() &#125;&#125;let c = new Cat('Tom'); // Tomconsole.log(c.sayHi()); // Meow, My name is Tom 七、存取器使用 getter 和 setter 可以改变属性的赋值和读取行为： 123456789101112131415class Animal &#123; constructor(name) &#123; this.name = name; &#125; get name() &#123; return 'Jack'; &#125; set name(value) &#123; console.log('setter: ' + value); &#125;&#125;let a = new Animal('Kitty'); // setter: Kittya.name = 'Tom'; // setter: Tomconsole.log(a.name); // Jack 八、静态方法使用 static 修饰符修饰的方法称为静态方法，它们不需要实例化，而是直接通过类来调用： 123456789class Animal &#123; static isAnimal(a) &#123; return a instanceof Animal; &#125;&#125;let a = new Animal('Jack');Animal.isAnimal(a); // truea.isAnimal(a); // TypeError: a.isAnimal is not a function ES7 中有一些关于类的提案，TypeScript 也实现了它们，这里做一个简单的介绍。 九、实例属性ES6 中实例的属性只能通过构造函数中的 this.xxx 来定义，ES7 提案中可以直接在类里面定义： 123456789class Animal &#123; name = 'Jack'; constructor() &#123; // ... &#125;&#125;let a = new Animal(); 十、静态属性ES7 提案中，可以使用 static 定义一个静态属性： 123456789class Animal &#123; static num = 42; constructor() &#123; // ... &#125;&#125;console.log(Animal.num); // 42 参考文章‘阮一峰’的ES6入门教程‘xcatliu’的TypeScript辅导教程]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】抓住数据的小尾巴 - JS浮点数陷阱及解法]]></title>
    <url>%2F2017%2F11%2F06%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91%E6%8A%93%E4%BD%8F%E6%95%B0%E6%8D%AE%E7%9A%84%E5%B0%8F%E5%B0%BE%E5%B7%B4-JS%E6%B5%AE%E7%82%B9%E6%95%B0%E9%99%B7%E9%98%B1%E5%8F%8A%E8%A7%A3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[前两天开发时做计算金额汇总，然后139.16+126计算的结果是265.15999999999997，这把我郁闷的半死，刚好这两天刷掘金看到一篇深度好文抓住数据的小尾巴 - JS浮点数陷阱及解法，算是解开了我心中的半片阴霾，因为有些没太理解，所以还有半片继续阴霾着。不管怎么说，这里先做一个转载 文章原发于掘金’前端新能源’ 众所周知，JavaScript 浮点数运算时经常遇到会 0.000000001 和 0.999999999 这样奇怪的结果，如 0.1+0.2=0.30000000000000004、1-0.9=0.09999999999999998，很多人知道这是浮点数误差问题，但具体原因就说不清楚了。本文帮你理清这背后的原理以及解决方案，还会向你解释JS中的大数危机和四则运算中会遇到的坑。 一、浮点数的存储首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — Number。它的实现遵循 IEEE 754 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。计算机组成原理中有过详细介绍，如果你不记得也没关系。 注：大多数语言中的小数默认都是遵循 IEEE 754 的 float 浮点数，包括 Java、Ruby、Python，本文中的浮点数问题同样存在。 这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。 64位比特又可分为三个部分： 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数 指数位E：中间的 11 位存储指数（exponent），用来表示次方数 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零 实际数字就可以用以下公式来计算： 注意以上的公式遵循科学计数法的规范，在十进制中 0&lt;M&lt;10，到二进制就是 0&lt;M&lt;2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转成二进制就是 100.1，科学计数法表示是 1.001*2^2，舍去1后 M = 001。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以约定减去一个中间数 1023，[0,1022] 表示为负，[1024,2047] 表示为正。如 4.5 的指数 E = 1025，尾数 M = 001。 最终的公式变成： 所以 4.5 最终表示为（M=001、E=1025）： (图片由此生成 http://www.binaryconvert.com/convert_double.html) 下面再以 0.1 为例解释浮点误差的原因，0.1 转成二进制表示为 0.0001100110011001100(1100循环)，1.100110011001100x2^-4，所以 E=-4+1023=1019；M 舍去首位的1，得到 100110011…。最终就是： 转化成十进制后为 0.100000000000000005551115123126，因此就出现了浮点误差。 1、为什么 0.1+0.2=0.30000000000000004？计算步骤为： 123456// 0.1 和 0.2 都转化成二进制后再进行运算0.00011001100110011001100110011001100110011001100110011010 +0.0011001100110011001100110011001100110011001100110011010 =0.0100110011001100110011001100110011001100110011001100111// 转成十进制正好是 0.30000000000000004 2、为什么 x=0.1 能得到 0.1？恭喜你到了看山不是山的境界。因为 mantissa 固定长度是 52 位，再加上省略的一位，最多可以表示的数是 2^53=9007199254740992，对应科学计数尾数是 9.007199254740992，这也是 JS 最多能表示的精度。它的长度是 16，所以可以近似使用 toPrecision(16) 来做精度运算，超过的精度会自动做凑整处理。于是就有： 123450.10000000000000000555.toPrecision(16)// 返回 0.1000000000000000，去掉末尾的零后正好为 0.1// 但你看到的 `0.1` 实际上并不是 `0.1`。不信你可用更高的精度试试：0.1.toPrecision(21) = 0.100000000000000005551 3、大数危机可能你已经隐约感觉到了，如果整数大于 9007199254740992 会出现什么情况呢？由于 E 最大值是 1023，所以最大可以表示的整数是 2^1024 - 1，这就是能表示的最大整数。但你并不能这样计算这个数字，因为从 2^1024 开始就变成了 Infinity 12345&gt; Math.pow(2, 1023)8.98846567431158e+307&gt; Math.pow(2, 1024)Infinity 那么对于 (2^53, 2^63) 之间的数会出现什么情况呢？ (2^53, 2^54) 之间的数会两个选一个，只能精确表示偶数 (2^54, 2^55) 之间的数会四个选一个，只能精确表示4个倍数 … 依次跳过更多2的倍数 下面这张图能很好的表示 JavaScript 中浮点数和实数（Real Number）之间的对应关系。我们常用的 (-2^53, 2^53) 只是最中间非常小的一部分，越往两边越稀疏越不精确。 在淘宝早期的订单系统中把订单号当作数字处理，后来随意订单号暴增，已经超过了9007199254740992，最终的解法是把订单号改成字符串处理。 要想解决大数的问题你可以引用第三方库 bignumber.js，原理是把所有数字当作字符串，重新实现了计算逻辑，缺点是性能比原生的差很多，所以原生支持大数就很有必要了。TC39 已经有一个 Stage 3 的提案 proposal bigint，大数问题有望彻底解决。在浏览器正式支持前，可以使用 Babel 7.0 来实现，它的内部是自动转换成 big-integer 来计算，这样能保持精度但运算效率会降低。 4、toPrecision vs toFixed数据处理时，这两个函数很容易混淆。它们的共同点是把数字转成字符串供展示使用。注意在计算的中间过程不要使用，只用于最终结果。 不同点就需要注意一下： toPrecision 是处理精度，精度是从左至右第一个不为0的数开始数起。 toFixed 是小数点后指定位数取整，从小数点开始数起。两者都能对多余数字做凑整处理，也有些人用 toFixed 来做四舍五入，但一定要知道它是有 Bug 的。 如：1.005.toFixed(2) 返回的是 1.00 而不是 1.01。 原因： 1.005 实际对应的数字是 1.00499999999999989，在四舍五入时全部被舍去！ 解法：使用四舍五入函数 Math.round() 来处理。但 Math.round(1.005*100) / 100 还是不行，因为 1.005*100 = 100.49999999999999。还需要把乘法和除法精度误差都解决后再使用 Math.round。可以使用后面介绍的 number-precision#round 方法来解决。 二、解决方案回到最关心的问题：如何解决浮点误差。首先，理论上用有限的空间来存储无限的小数是不可能保证精确的，但我们可以处理一下得到我们期望的结果。 1、数据展示类当你拿到 1.4000000000000001 这样的数据要展示时，建议使用 toPrecision 凑整并 parseFloat 转成数字后再显示，如下： 1parseFloat(1.4000000000000001.toPrecision(12)) === 1.4 // True 封装成方法就是： 123function strip(num, precision = 12) &#123; return +parseFloat(num.toPrecision(precision));&#125; 为什么选择 12 做为默认精度？这是一个经验的选择，一般选12就能解决掉大部分0001和0009问题，而且大部分情况下也够用了，如果你需要更精确可以调高。 2、数据运算类对于运算类操作，如 +-*/，就不能使用 toPrecision 了。正确的做法是把小数转成整数后再运算。以加法为例： 123456789/** * 精确加法 */function add(num1, num2) &#123; const num1Digits = (num1.toString().split('.')[1] || '').length; const num2Digits = (num2.toString().split('.')[1] || '').length; const baseNum = Math.pow(10, Math.max(num1Digits, num2Digits)); return (num1 * baseNum + num2 * baseNum) / baseNum;&#125; 以上方法能适用于大部分场景。遇到科学计数法如 2.3e+1（当数字精度大于21时，数字会强制转为科学计数法形式显示）时还需要特别处理一下。 这里作者推荐了一个开源库number-precision,完美支持浮点数的加减乘除、四舍五入等运算。非常小只有1K，远小于绝大多数同类库（如Math.js、BigDecimal.js），100%测试全覆盖，代码可读性强，可以覆盖大部分应用场景。 参考 Double-precision floating-point format What Every Programmer Should Know About Floating-Point Arithmetic Why Computers are Bad at Algebra | Infinite Series Is Your Model Susceptible to Floating-Point Errors?]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git reset 与 git revert 的区别]]></title>
    <url>%2F2017%2F11%2F06%2Fgit-reset-%E4%B8%8E-git-revert-%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[git reset 与 git revert 都可以将版本退回，那他们具体有哪些区别呢？如果你对此有疑惑，这篇文章或许能够帮助到你 我们现在创建一个由git管理的文件夹，文件夹是clean的，并且与远程的版本库是一致的，我们敲下git log --graph来看看历史版本： 现在文件夹中有一个readme.txt： 我们将文件修改如下： 并敲下如下命令提交至远程仓库： 12345git add readme.txtgit commit -m&quot;测试一下 git reset&quot;git push 那么现在再敲下git log --graph来看看历史版本： 到现在我们还没有发现什么大问题，接下来是重点： 第一种情况：我们现在敲下git reset --hard HEAD^来退回上一个版本 我们发现readme.txt如愿以偿的回到的最初的模样： 再看看历史版本： 也和刚开始一样，也就是说：由于使用了git reset,开头为957a2c的版本在本地消失不见了，但是由于刚刚王二已经将开头为957a2c的版本提交到了远程，所以远程依然存在开头为957a2c的版本。即本地落后远程一个版本 我们用git status就可以发现本地落后远程一个版本： 如果这时候在本地修改文件并提交至远程，push的时候就会被拒绝，如果还改了同一份文件，还需要手动解决冲突。 第二种情况：我们现在敲下git revert HEAD来退回上一个版本 我们发现readme.txt依旧如愿以偿的回到的最初的模样： 再看看历史版本： 发现没有，git的版本又向前走了一步，变成了开头为2b4dd6的版本。事实上，git revert的原理是根据你要回退的提交所做的改动做相反的改动，然后重新提交代码。 我们用git status就可以发现本地会优先远程一个版本： 如果这时候在本地修改文件并提交，就会很顺利地提交至远程。 小结：git reset会将HEAD的指针往后退一步 git revert则会根据要回退的提交所做的改动做相反的改动，然后重新提交代码，它的HEAD会往前进一步。]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转载】js中的事件委托或是事件代理详解]]></title>
    <url>%2F2017%2F11%2F06%2F%E3%80%90%E8%BD%AC%E8%BD%BD%E3%80%91js%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A7%94%E6%89%98%E6%88%96%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[以前一直不知道事件委托或时间代理到底指什么，今天看到的”凌云之翼”的博客文章，讲的超级清除，有兴趣可以点这里直接看”凌云之翼”的博客 文章原发于‘凌云之翼’的博客 一、起因1、这是前端面试的经典题型，要去找工作的小伙伴看看还是有帮助的； 2、其实我一直都没弄明白，写这个一是为了备忘，二是给其他的知其然不知其所以然的小伙伴们以参考； 二、概述那什么叫事件委托呢？它还有一个名字叫事件代理，JavaScript高级程序设计上讲：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。那这是什么意思呢？网上的各位大牛们讲事件委托基本上都用了同一个例子，就是取快递来解释这个现象，我仔细揣摩了一下，这个例子还真是恰当，我就不去想别的例子来解释了，借花献佛，我摘过来，大家认真领会一下事件委托到底是一个什么原理： 有三个同事预计会在周一收到快递。为签收快递，有两种办法：一是三个人在公司门口等快递；二是委托给前台MM代为签收。现实当中，我们大都采用委托的方案（公司也不会容忍那么多员工站在门口就为了等快递）。前台MM收到快递后，她会判断收件人是谁，然后按照收件人的要求签收，甚至代为付款。这种方案还有一个优势，那就是即使公司里来了新员工（不管多少），前台MM也会在收到寄给新员工的快递后核实并代为签收。 这里其实还有2层意思的： 第一，现在委托前台的同事是可以代为签收的，即程序中的现有的dom节点是有事件的； 第二，新员工也是可以被前台MM代为签收的，即程序中新添加的dom节点也是有事件的。 三、为什么要用事件委托一般来说，dom需要有事件处理程序，我们都会直接给它设事件处理程序就好了，那如果是很多的dom需要添加事件处理呢？比如我们有100个li，每个li都有相同的click点击事件，可能我们会用for循环的方法，来遍历所有的li，然后给它们添加事件，那这么做会存在什么影响呢？ 在JavaScript中，添加到页面上的事件处理程序数量将直接关系到页面的整体运行性能，因为需要不断的与dom节点进行交互，访问dom的次数越多，引起浏览器重绘与重排的次数也就越多，就会延长整个页面的交互就绪时间，这就是为什么性能优化的主要思想之一就是减少DOM操作的原因；如果要用事件委托，就会将所有的操作放到js程序里面，与dom的操作就只需要交互一次，这样就能大大的减少与dom的交互次数，提高性能； 每个函数都是一个对象，是对象就会占用内存，对象越多，内存占用率就越大，自然性能就越差了（内存不够用，是硬伤，哈哈），比如上面的100个li，就要占用100个内存空间，如果是1000个，10000个呢，那只能说呵呵了，如果用事件委托，那么我们就可以只对它的父级（如果只有一个父级）这一个对象进行操作，这样我们就需要一个内存空间就够了，是不是省了很多，自然性能就会更好。 四、事件委托的原理事件委托是利用事件的冒泡原理来实现的，何为事件冒泡呢？就是事件从最深的节点开始，然后逐步向上传播事件，举个例子：页面上有这么一个节点树，div&gt;ul&gt;li&gt;a;比如给最里面的a加一个click点击事件，那么这个事件就会一层一层的往外执行，执行顺序a&gt;li&gt;ul&gt;div，有这样一个机制，那么我们给最外面的div加点击事件，那么里面的ul，li，a做点击事件的时候，都会冒泡到最外层的div上，所以都会触发，这就是事件委托，委托它们父级代为执行事件。 五、事件委托怎么实现终于到了本文的核心部分了，哈哈，在介绍事件委托的方法之前，我们先来看一段一般方法的例子： 子节点实现相同的功能： 123456&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 实现功能是点击li，弹出123： 123456789window.onload = function()&#123; var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); for(var i=0;i&lt;aLi.length;i++)&#123; aLi[i].onclick = function()&#123; alert(123); &#125; &#125;&#125; 上面的代码的意思很简单，相信很多人都是这么实现的，我们看看有多少次的dom操作，首先要找到ul，然后遍历li，然后点击li的时候，又要找一次目标的li的位置，才能执行最后的操作，每次点击都要找一次li； 那么我们用事件委托的方式做又会怎么样呢？ 123456window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function()&#123; alert(123); &#125;&#125; 这里用父级ul做事件处理，当li被点击时，由于冒泡原理，事件就会冒泡到ul上，因为ul上有点击事件，所以事件就会触发，当然，这里当点击ul的时候，也是会触发的，那么问题就来了，如果我想让事件代理的效果跟直接给节点的事件效果一样怎么办，比如说只有点击li才会触发，不怕，我们有绝招： Event对象提供了一个属性叫target，可以返回事件的目标节点，我们成为事件源，也就是说，target就可以表示为当前的事件操作的dom，但是不是真正操作dom，当然，这个是有兼容性的，标准浏览器用ev.target，IE浏览器用event.srcElement，此时只是获取了当前节点的位置，并不知道是什么节点名称，这里我们用nodeName来获取具体是什么标签名，这个返回的是一个大写的，我们需要转成小写再做比较（习惯问题）： 1234567891011window.onload = function()&#123; var oUl = document.getElementById("ul1"); oUl.onclick = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; alert(123); alert(target.innerHTML); &#125; &#125;&#125; 这样改下就只有点击li会触发事件了，且每次只执行一次dom操作，如果li数量很多的话，将大大减少dom的操作，优化的性能可想而知！ 六、事件委托实现不一样的点击效果上面的例子是说li操作的是同样的效果，要是每个li被点击的效果都不一样，那么用事件委托还有用吗？ 123456&lt;div id="box"&gt; &lt;input type="button" id="add" value="添加" /&gt; &lt;input type="button" id="remove" value="删除" /&gt; &lt;input type="button" id="move" value="移动" /&gt; &lt;input type="button" id="select" value="选择" /&gt;&lt;/div&gt; 123456789101112131415161718window.onload = function()&#123; var Add = document.getElementById("add"); var Remove = document.getElementById("remove"); var Move = document.getElementById("move"); var Select = document.getElementById("select"); Add.onclick = function()&#123; alert('添加'); &#125;; Remove.onclick = function()&#123; alert('删除'); &#125;; Move.onclick = function()&#123; alert('移动'); &#125;; Select.onclick = function()&#123; alert('选择'); &#125;&#125; 上面实现的效果我就不多说了，很简单，4个按钮，点击每一个做不同的操作，那么至少需要4次dom操作，如果用事件委托，能进行优化吗？ 1234567891011121314151617181920212223window.onload = function()&#123; var oBox = document.getElementById("box"); oBox.onclick = function (ev) &#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLocaleLowerCase() == 'input')&#123; switch(target.id)&#123; case 'add' : alert('添加'); break; case 'remove' : alert('删除'); break; case 'move' : alert('移动'); break; case 'select' : alert('选择'); break; &#125; &#125; &#125;&#125; 用事件委托就可以只用一次dom操作就能完成所有的效果，比上面的性能肯定是要好一些的。 七、事件委托为新增节点添加事件现在讲的都是document加载完成的现有dom节点下的操作，那么如果是新增的节点，新增的节点会有事件吗？也就是说，一个新员工来了，他能收到快递吗？ 看一下正常的添加节点的方法： 1234567&lt;input type="button" name="" id="btn" value="添加" /&gt;&lt;ul id="ul1"&gt; &lt;li&gt;111&lt;/li&gt; &lt;li&gt;222&lt;/li&gt; &lt;li&gt;333&lt;/li&gt; &lt;li&gt;444&lt;/li&gt;&lt;/ul&gt; 现在是移入li，li变红，移出li，li变白，这么一个效果，然后点击按钮，可以向ul中添加一个li子节点: 123456789101112131415161718192021222324window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 这是一般的做法，但是你会发现，新增的li是没有事件的，说明添加子节点的时候，事件没有一起添加进去，这不是我们想要的结果，那怎么做呢？一般的解决方案会是这样，将for循环用一个函数包起来，命名为mHover，如下： 123456789101112131415161718192021222324252627window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; function mHover () &#123; //鼠标移入变红，移出变白 for(var i=0; i&lt;aLi.length;i++)&#123; aLi[i].onmouseover = function()&#123; this.style.background = 'red'; &#125;; aLi[i].onmouseout = function()&#123; this.style.background = '#fff'; &#125; &#125; &#125; mHover (); //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); mHover (); &#125;;&#125; 这里的oUl.getElementsByTagName(&#39;li&#39;);似乎能实时监听到子元素li的变化，这个小细节王二以前倒是没有注意到（后来想想，只是简单的对象的引用） 虽然功能实现了，看着还挺好，但实际上无疑是又增加了一个dom操作，在优化性能方面是不可取的，那么有事件委托的方式，能做到优化吗？ 1234567891011121314151617181920212223242526272829303132window.onload = function()&#123; var oBtn = document.getElementById("btn"); var oUl = document.getElementById("ul1"); var aLi = oUl.getElementsByTagName('li'); var num = 4; //事件委托，添加的子元素也有事件 oUl.onmouseover = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "red"; &#125; &#125;; oUl.onmouseout = function(ev)&#123; var ev = ev || window.event; var target = ev.target || ev.srcElement; if(target.nodeName.toLowerCase() == 'li')&#123; target.style.background = "#fff"; &#125; &#125;; //添加新节点 oBtn.onclick = function()&#123; num++; var oLi = document.createElement('li'); oLi.innerHTML = 111*num; oUl.appendChild(oLi); &#125;;&#125; 看，上面是用事件委托的方式，新添加的子元素是带有事件效果的，我们可以发现，当用事件委托的时候，根本就不需要去遍历元素的子节点，只需要给父级元素添加事件就好了，其他的都是在js里面的执行，这样可以大大的减少dom操作，这才是事件委托的精髓所在。 八、事件委托使用的一些特殊场景现在给一个场景 ul &gt; li &gt; div &gt; p，div占满li，p占满div，还是给ul绑定时间，需要判断点击的是不是li（假设li里面的结构是不固定的），那么e.target就可能是p，也有可能是div，这种情况你会怎么处理呢？ 那我们现在就再现一下这个场景： 1234567891011121314&lt;ul id="test"&gt; &lt;li&gt; &lt;p&gt;11111111111&lt;/p&gt; &lt;/li&gt; &lt;li&gt; &lt;div&gt; 22222222 &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;3333333333&lt;/span&gt; &lt;/li&gt; &lt;li&gt;4444444&lt;/li&gt;&lt;/ul&gt; 如上列表，有4个li，里面的内容各不相同，点击li，event对象肯定是当前点击的对象，怎么指定到li上，下面我直接给解决方案： 1234567891011var oUl = document.getElementById('test');oUl.addEventListener('click',function(ev)&#123; var target = ev.target; while(target !== oUl )&#123; if(target.tagName.toLowerCase() == 'li')&#123; console.log('li click~'); break; &#125; target = target.parentNode; &#125;&#125;) 核心代码是while循环部分，实际上就是一个递归调用，你也可以写成一个函数，用递归的方法来调用，同时用到冒泡的原理，从里往外冒泡，知道currentTarget为止，当当前的target是li的时候，就可以执行对应的事件了，然后终止循环，恩，没毛病！ 这里看不到效果，大家可以复制过去运行一下！ 九、总结那什么样的事件可以用事件委托，什么样的事件不可以用呢？ 适合用事件委托的事件：click，mousedown，mouseup，keydown，keyup，keypress。 值得注意的是，mouseover和mouseout虽然也有事件冒泡，但是处理它们的时候需要特别的注意，因为需要经常计算它们的位置，处理起来不太容易。 不适合的就有很多了，举个例子，mousemove，每次都要计算它的位置，非常不好把控，在不如说focus，blur之类的，本身就没用冒泡的特性，自然就不能用事件委托了。 参考博客：‘凌云之翼’的博客]]></content>
      <categories>
        <category>前端备忘</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有趣的算法面试题]]></title>
    <url>%2F2017%2F11%2F03%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天面试时遇到一道算法题，挺有趣的，在这里做一个分享 一、问题描述问题：已知一个字符串，请以字典序写出它的所有排列组合。 例如：’asd’的所有排列组就是[“ads”, “asd”, “das”, “dsa”, “sad”, “sda”]； 规定：字符串由小写字母组成，且无重复 二、解决方案这是个典型的排列组合问题，对于长度为n的字符串，排列的数组的长度为n!个。我们可以用递归来解决此类问题，参考如下代码： 123456789101112131415function test (str)&#123; var str = str.split('').sort().join(''); var arr = []; function demo (str,i='')&#123; if(str.length===1)&#123; arr.push(i+str); return; &#125; for(var x=0;x&lt;str.length;x++)&#123; demo(str.substring(0,x)+str.substring(x+1),i+str[x]); &#125; &#125; demo(str); return arr ;&#125; 三、优化事实上，以上的递归算法有大量的重复计算，例如： 对于abcdefg字符串，当字符串前两位确定时，比如，前两位字母是是a、b，那么后5个字母cdefg的排列组合只要计算一次，再加上前面的两位字母就好了。 但是，在上面的算法中，当前面的两位字母是ab或者ba时，算法都重新计算了一次cdefg的排列组合，这显然是不合理的。 这时候需要设计一个缓存，来保存已经计算过的字符串。 遗憾的是，今天王二的智商下线，想了半天没有想出如何设计这个缓存，等智商重新上线再来想吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有趣的canvas题目]]></title>
    <url>%2F2017%2F11%2F01%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84canvas%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天收到一份笔试邮件，关于canvas的，平时canvas接触的比较少，在这里做一个记录 一、题目描述 1.屏幕中随机产生n个蓝色大小不一的气泡，坐标随机 2.红色气泡跟随鼠标移动 3.当红色气泡会与蓝色气泡发生碰撞效果(类似桌球) 4.红色气泡会被屏幕边缘阻挡 5.蓝色气泡左右屏上下屏互通 6.蓝色气泡的运动及互动行为请自由发挥 二、解决方法代码的实现如下： 如果想看显示的运行效果，可以使劲的戳这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #canvas&#123; margin: 30px; border: 1px solid #000000; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script&gt; ! function() &#123; var the_canvas = document.getElementById('canvas'), //创建画布 context = the_canvas.getContext("2d"), blueBubble = new Image(), redBubble = new Image(), n = 20 , //蓝色泡泡的数量 arr = [], //储存蓝色泡泡的array maxRadius = 80, //泡泡的最大半径 minRadius = 40, //泡泡的最小半径 redBubbleRadius = 80, //红色泡泡的半径 canvasWidth = 800, //画布的宽度 canvasHeight = 600, //画布的高度 maxSpeed = 80 , //泡泡的最大速度（x,y向量坐标速度） minSpeed = 50 , //泡泡的最小速度（x,y向量坐标速度） current_point = &#123; x: null, //当前鼠标x y: null //当前鼠标y &#125;; //定时刷新方法 var refresh = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(func) &#123; window.setTimeout(func, 1000/60); &#125;; init(); getBubbles(); //图片加载完成后，开始绘画 blueBubble.onload = function()&#123; drawBubble(); &#125;; //生成指定个蓝圈圈，外加一个红圈圈 function getBubbles()&#123; for(var i=0;i&lt;=n;i++)&#123; var obj ; if(i===n)&#123; obj = getBubble(redBubbleRadius) ; obj.type = 'red' ; /*这段代码的本意是防止在初始化时红圈圈与蓝圈圈以外重叠在一起， * 但是有了下面 momentum下两行特殊的处理代码，这一段代码已经没有必要了。*/ /* if(!noRepeat (obj,arr))&#123; i -- ; continue ; &#125; */ &#125;else&#123; obj = getBubble() ; &#125; arr.push(obj); &#125; &#125; //定义画布大小以及加载图片资源文件 function init()&#123; //定义画布大小 the_canvas.width = canvasWidth || window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth; the_canvas.height = canvasHeight || window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; //加载泡泡 blueBubble.src = './img/blue-bubble.png'; redBubble.src = './img/red-bubble.png'; &#125; //随机生成小圆圈的方法，传入一个半径，如果不传，则半径大小随机生成 function getBubble (radius) &#123; radius = radius || Math.round((Math.random()*(maxRadius-minRadius)+minRadius)/2); //圈圈的半径 var x = Math.round(Math.random()*(the_canvas.width-2*radius)+radius), //圈圈的x坐标 y = Math.round(Math.random()*(the_canvas.height-2*radius)+radius), //圈圈的y坐标 vx = Math.round(Math.random()*(maxSpeed-minSpeed)+minSpeed)*(Math.random()&gt;0.5?1:-1), vy = Math.round(Math.random()*(maxSpeed-minSpeed)+minSpeed)*(Math.random()&gt;0.5?1:-1); return &#123; radius : radius , x : x , y : y , vx : vx , vy : vy , type : 'blue' &#125;; &#125; //确定红圈的位置，不能与篮圈重叠 function noRepeat (a1,arr) &#123; for(var x=0;x&lt;arr.length;x++)&#123; var x_dist, y_dist, dist; x_dist = a1.x - arr[x].x; //x轴距离 l y_dist = a1.y - arr[x].y; //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist; //总距离的平方 if(dist&lt;=Math.pow(a1.radius+arr[x].radius,2)) return false ; &#125; return true ; &#125; //监听鼠标的位置 window.onmousemove = function(e) &#123; e = e || window.event; current_point.x = e.layerX; current_point.y = e.layerY; &#125;; //为了算这个动画我又拾起了高中的动量守恒定律 function momentum (a1,a2) &#123; var x_dist, y_dist, dist,m1,m2,vx1,vy1,vx2,vy2; x_dist = a1.x - a2.x; //x轴距离 l y_dist = a1.y - a2.y; //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist; //总距离的平方 if(Math.pow(a1.radius+a2.radius,2)-dist&gt;0)&#123; /*下面两行的代码的作用是：防止红圈圈与蓝圈圈粘在一起； * 由于动画的刷新频率有限，当用鼠标移动红圈圈速度过快时， * 有可能红圈圈与蓝圈圈会重叠在一起，如果遇到这种情况，则把蓝圈圈移到红圈圈的外边*/ var temp = Math.sqrt(Math.pow(a1.radius+a2.radius,2)-y_dist * y_dist) ; a1.x - a2.x&gt;0?a1.x=a2.x+temp:a1.x=a2.x-temp ; /***end***/ m1 = Math.pow(a1.radius,2) ; m2 = Math.pow(a2.radius,2) ; vx1 = a1.vx ; vy1 = a1.vy ; vx2 = a2.vx ; vy2 = a2.vy ; a1.vx = ((m1-m2)*vx1+2*m2*vx2)/(m1+m2) ; a1.vy = ((m1-m2)*vy1+2*m2*vy2)/(m1+m2) ; a2.vx = (2*m1*vx1+(m2-m1)*vx2)/(m1+m2) ; a2.vy = (2*m1*vy1+(m2-m1)*vy2)/(m1+m2) ; &#125; &#125; //绘画的具体方法 function drawBubble()&#123; context.clearRect(0, 0, the_canvas.width, the_canvas.height); arr.forEach(function(item)&#123; item.x += item.vx/10 ; //移动速度太快了，这边除以个10 item.y += item.vy/10 ; if(item.type==='blue')&#123; item.x&gt;the_canvas.width &amp;&amp; (item.x-=the_canvas.width); item.x&lt;0 &amp;&amp; (item.x+=the_canvas.width); item.y&gt;the_canvas.height &amp;&amp; (item.y-=the_canvas.height); item.y&lt;0 &amp;&amp; (item.y+=the_canvas.height); context.drawImage(blueBubble, item.x-item.radius, item.y-item.radius, 2*item.radius, 2*item.radius); &#125; if(item.type==='red')&#123; arr.forEach(function(i)&#123; if(i.type==='blue')&#123; momentum(i,item); &#125; &#125;); item.vx *= item.x &gt; the_canvas.width-item.radius || item.x &lt; item.radius ? -1 : 1 ; item.vy *= item.y &gt; the_canvas.height-item.radius || item.y&lt; item.radius ? -1 : 1 ; if(current_point.x&gt;item.radius&amp;&amp;current_point.x&lt;the_canvas.width-item.radius&amp;&amp;current_point.y&gt;item.radius&amp;&amp;current_point.y&lt;the_canvas.height-item.radius)&#123; item.x = current_point.x; item.y = current_point.y; &#125; context.drawImage(redBubble, item.x-item.radius, item.y-item.radius, 2*item.radius, 2*item.radius); &#125; &#125;); refresh(drawBubble); &#125; &#125;() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要特别特别感谢的是 canvas-nest 这个开源库,从它的源代码里王二得到了很多灵感。什么？ 你不知道这个开源库是干嘛用的，看见网站背景的炫酷小点点了吗？就是这个开源库写的。 三、遗留问题这里的小球球的碰撞后的轨迹需要二维弹性碰撞下的动量定理，而王二物理不太好，只学过一维弹性碰撞下的动量定理，所以王二在方法里用的是一维弹性碰撞下的动量定理。 所以你会发现小球之间的碰撞有那么一丝丝不符合物理常识。没办法，王二最近智商不太好，等王二智商好一点了再解决这个问题。 如果读者你是物理大神，赐教一下哈！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（六）]]></title>
    <url>%2F2017%2F11%2F01%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python中文件的增删改读、操作目录、多进程、多线程中值得留意的地方。 一、读取文件如果想读取本地的文件，Python一行代码就能搞定： 1&gt;&gt;&gt; f = open('test.txt', 'r') 标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件；如果文件不存在，Python会抛出一个错误； 调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： 12&gt;&gt;&gt; f.read()'Hello, world!' 最后需要用close()方法关闭文件，文件对象不关闭的话会占用操作系统的资源。 1&gt;&gt;&gt; f.close() 二、修改或新建文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符&#39;w&#39;表示写入文件： 123&gt;&gt;&gt; f = open('test.txt', 'w')&gt;&gt;&gt; f.write('Hello, wanger!')&gt;&gt;&gt; f.close() 如果没有test.txt文件，Python会为我们创建一个test.txt文件。 这里务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。 需要注意的是，当用 f = open(&#39;test.txt&#39;, &#39;w&#39;) 时， Python会把原来 &#39;test.txt&#39; 里的文件清除。 三、删除文件如果要删除文件，需要用到python的内建模块os，参考如下代码： 12&gt;&gt;&gt; import os&gt;&gt;&gt; os.remove('test.txt') 如果要删除的文件不存在，Python会抛出一个错误； 四、创建或删除目录如果要创建目录，可以使用mkdir()方法，参考如下代码： 12345&gt;&gt;&gt; import os#创建testdir目录&gt;&gt;&gt; os.mkdir('testdir')#删除testdir目录&gt;&gt;&gt; os.rmdir('testdir') 以上代码会相对于路径生成（删除）一个空的testdir文件夹，如果想相对于决绝路径创建目录，参考以下代码： 12345678910# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'C:\\Users\\Administrator\\Desktop\\python'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'C:\\Users\\Administrator\\Desktop\\python\\testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('C:\\Users\\Administrator\\Desktop\\python\\testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('C:\\Users\\Administrator\\Desktop\\python\\testdir') 这里需要通过os.path.join()函数来连接路径，因为不同操作系统的路径分隔符也有所不同，Linux/Unix/Mac下为/，Windows下为\。 五、多进程、多线程多进程、多线程这一块没有仔细看，等以后有实际用到在详细研究。 这里先留一个大致的印象：在CPU密集型任务下，多进程更快，或者说效果更好；而IO密集型，多线程能有效提高效率。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（五）]]></title>
    <url>%2F2017%2F10%2F30%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python面向对象中类和实例、__init__方法、私有变量、继承、MixIn、判断对象类型、dir()、实例属性和类属性、__slots__方法、使用@property中值得留意的地方。 一、类和实例1、在Python中，定义类通过class关键字来实现： 12class Student(object): pass 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例通过类名+()实现： 123&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x000001FECADEE128&gt; 二、__init__方法通过定义一个特殊的__init__方法，在创建实例的时候，我们可以把一些类的属性绑定上去，参考如下代码： 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 这时候我们的的学生就有了自己的名字与分数： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 需要注意的是，__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 三、私有变量如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 98)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 那就一定不能从外部访问了吗？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量，但是最好别这么干。 四、继承在上述的类Student中 : 12class Student(object): pass 我们注意到Stuedent中紧跟着一对括号，括号中是object，那么Student就是从object上继承下来的。 如果想定义两个或多个父类那该怎么办呢？也很简单，写上两个就好了： 123456789class Animal(object): passclass Runnable(object): def run(self): print('Running...')class Dog(Animal, Runnable): pass 五、MixIn在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Dog除了继承自Animal外，再同时继承Runnable。这种设计通常称之为MixIn。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 个人认为MixIn的概念类似于Java中一个类可以添加多个接口这个概念。 六、判断对象类型我们可以使用type()、isinstance()来判断对象的类型，他们写起来就像这样： 123456789101112131415&gt;&gt;&gt; type(123)==type(456)True&gt;&gt;&gt; type(123)==intTrue&gt;&gt;&gt; type('abc')==type('123')True&gt;&gt;&gt; type('abc')==strTrue&gt;&gt;&gt; type('abc')==type(123)False&gt;&gt;&gt; isinstance('abc', str)True&gt;&gt;&gt; isinstance(123, int)True 七、使用dir()dir()这个函数算是惊艳到王二了，它返回一个包含字符串的list，获得一个传入对象的所有属性和方法： 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 当然，我们还可以通过getattr()、setattr()以及hasattr()来直接操作一个对象的状态。 八、实例属性和类属性在编码的时候，不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性，参考如下代码： 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = 'Student'...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 九、使用__slots__如果我们想要限制实例的属性,可以使用__slots__，参考如下代码： 1234567891011class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称#然后，我们试试&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score' 由于&#39;score&#39;没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 十、使用@propertyPython内置的@property装饰器可以把一个方法变成属性调用，参考如下代码： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 如果只定义getter方法，不定义setter方法，那它就是一个只读属性。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass学习小结]]></title>
    <url>%2F2017%2F10%2F30%2Fsass%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近有时间又看了一遍Sass的基础语法，这里主要记录了Sass基础语法中值得留意的地方，如果之前没有接触过sass，Sass 中文网的快速入门或许能帮助到你。 一、SCSS 与 Sass 异同SCSS 是 Sass3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。另外，SCSS 还能识别大部分 CSS hacks（一些 CSS 小技巧）和特定于浏览器的语法。 由于 SCSS 是 CSS 的扩展，因此，所有在 CSS 中正常工作的代码也能在 SCSS 中正常工作。也就是说，对于一个 Sass 用户，只需要理解 Sass 扩展部分如何工作的，就能完全理解 SCSS。大部分扩展，例如变量、parent references 和 指令都是一致的；唯一不同的是，SCSS 需要使用分号和花括号而不是换行和缩进。 例如，以下这段简单的 Sass 代码： 123#sidebar width: 30% background-color: #faa 只需添加花括号和分号就能转换为 SCSS 语法： 1234#sidebar &#123; width: 30%; background-color: #faa;&#125; 另外，SCSS 对空白符号不敏感。上面的代码也可以书写成下面的样子： 1#sidebar &#123;width: 30%; background-color: #faa&#125; 二、 变量名用中划线还是下划线？sass 并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使 compass 选择用中划线的命名方式，这并不影响你在使用 compass 的样式中用下划线的命名方式进行引用： 12345678910$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 三、子组合选择器和同层组合选择器：&gt;、+和~这些组合选择器可以毫不费力地应用到sass的规则嵌套中。可以把它们放在外层选择器后边，或里层选择器前边： 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; 四、静默注释sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟Java、ScriptJava等类 C 的语言中单行注释的语法相同，它们以 // 开头，注释内容直到行末: 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 五、混合器如果你的整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过sass的混合器实现大段样式的重用。 混合器使用 @mixin 标识符定义,这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段 sass 代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过 @include 来使用这个混合器，放在你希望的任何地方。@include 调用会把混合器中的所有样式提取出来放在 @include 被调用的地方。如果像下边这样写： 123456789101112131415notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass最终生成:.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 当然，混合器也可以使用sass的各种规则，变量、嵌套，随便你用。 更令人兴奋地是， 我们还可以给混合器传参，来定制混合器生成的精确样式。用起来很向js的函数： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被 @include 时，你可以把它当作一个css函数来传参。如果你像下边这样写： 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 噢，对了，我们还可以为混合器设置默认参数，是不是觉得用上了JS的ES6语法。 参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用，如下代码： 12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red), $hover和$visited也会被自动赋值为red。 参考文档sass 中文网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp入门示例]]></title>
    <url>%2F2017%2F10%2F27%2Fgulp%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最近在学习Gulp,自己也整理了一些小demo,你可以访问demo-gulp来下载这些demo,整理这些demo目的是帮自己快速了解gulp的一些基本功能（检查js语法和风格、压缩js文件、合并js文件、编译sass文件，压缩css，热更新文件，浏览器实时刷新）,如果你也有这方面的需求，这篇示例教程或许能帮到你 一、安装 Gulp在全局安装gulp npm install -g gulp 二、基础介绍gulp非常简单，实际上，gulp本身只提供了4个基础的API，它的大部分功能都是通过插件来完成的，接下来简单的介绍下这四个基础的API， gulp.task(name [, deps, fn]) gulp.src(globs[, options]) gulp.dest(path[, options]) gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb]) 在这里先不解释这四个API的具体用处，因为解释也太流于表面，我们先来看一些实例，或许看完这些实例，我们就能了解这些API的具体作用了。 三、压缩js文件demo01向我们展示了如何创建一个压缩js的gulp任务。 首先，我们需要在项目的根目录下创建一个gulpfile.js文件，我们在文件中写下如下配置文件： 12345678var gulp = require('gulp'), uglify = require('gulp-uglify');gulp.task('minify', function () &#123; gulp.src('js/app.js') .pipe(uglify()) .pipe(gulp.dest('build'))&#125;); 以上代码一下子就使用到了gulp四个api中的三个，简单来说，gulp.task()会启动一个任务，gulp.src()会将你要处理的文件加载进来，gulp.dest()会将处理好的文件输出到指定位置。如果想了解这些api的具体细节，可以参考Culp 中文网。 如果你克隆下了这些demo,在命令行中桥下如下代码： cd demo01 //进入demo01子文件夹 npm install //加载依赖 gulp minify //运行minify这个任务 你就会发现在根目录下会多出一个build文件夹，里面有一个压缩好的app.js，这就是从gulp任务里生成的压缩代码。 四、检查js语法，压缩并合并js文件当然gulp能做的并不仅仅是压缩js文件，配合一些插件的使用，gulp还有更多的功能，参考demo02，在它的目录下我们发现有如下的配置文件： 12345678910111213var gulp = require('gulp'), uglify = require('gulp-uglify'); jshint = require('gulp-jshint'); concat = require('gulp-concat');gulp.task('dealJS', function () &#123; gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(uglify()) .pipe(concat('app.js')) .pipe(gulp.dest('build'));&#125;); 其中，jshint()会审查我们的代码风格，uglify()会压缩我们的文件，concat()会合并我们的文件。 需要注意的是，gulp的设计理念基于unix的pipe(流)思想，所以在编写构建任务代码更加简洁，也利于开发人员的维护和阅读。 与gulp对比的grunt,则将代码分成了grunt.initConfig（任务执行）、grunt.loadNpmTasks（引入模块）、grunt.registerTask（定义任务名称）三部分,写起来就像下面这样： 1234567891011121314151617181920212223module.exports = function(grunt) &#123; // Project configuration. grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), uglify: &#123; options: &#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' &#125;, build: &#123; src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' &#125; &#125; &#125;); // 加载包含 "uglify" 任务的插件。 grunt.loadNpmTasks('grunt-contrib-uglify'); // 默认被执行的任务列表。 grunt.registerTask('default', ['uglify']);&#125;; 所以，单单从配置的容易程度，代码的可阅读性上来说，gulp是更加容易上手的。 五、编译sass并压缩cssgulp不仅仅能处理js，配合一些插件使用后，他还能处理css，例如demo03就可以编译sass并压缩css。 12345678910var gulp = require('gulp'), sass = require('gulp-sass'); minifyCSS = require('gulp-minify-css');gulp.task('dealCSS', function () &#123; gulp.src('scss/*.scss') .pipe(sass()) .pipe(minifyCSS()) .pipe(gulp.dest('build'))&#125;); 六、实时更新文件到现在，我们还有一个gulp的api没有用到————gulp.watch(),它可以监视文件，并且在文件发生改动时候做一些事情，参考demo04的配置文件： 12345678910111213var gulp = require('gulp'), uglify = require('gulp-uglify');gulp.task('minify', function () &#123; console.log("js文件夹里的文件正在重新编译...") gulp.src('js/*.js') .pipe(uglify()) .pipe(gulp.dest('build'))&#125;);gulp.task('watch', function () &#123; gulp.watch('js/*.js', ['minify']);&#125;); 启动watch任务后，每当js文件夹下的.js文件有变动时（变动代码未保存不算），就会触发minify文件，然后minify任务就会重新编译压缩js文件夹下的所有.js文件。 七、浏览器实时刷新虽然现在文件可以实时监听更新了，可是浏览器不会因为文件的变动而实时刷新，这时候我们可以借助gulp插件启动一个本地服务器来调试代码，参考demo05的配置文件： 12345678910111213141516171819202122232425var gulp = require('gulp'), sass = require('gulp-sass'); minifyCSS = require('gulp-minify-css'); connect = require('gulp-connect');gulp.task('dealCSS', function () &#123; gulp.src('scss/*.scss') .pipe(sass()) .pipe(minifyCSS()) .pipe(gulp.dest('build')) .pipe(connect.reload());&#125;);gulp.task('watch', function () &#123; gulp.watch('scss/*.scss', ['dealCSS']);&#125;);gulp.task('connect', function () &#123; connect.server(&#123; livereload: true &#125;);&#125;);gulp.task('livereload', [ 'connect', 'watch']); 启动livereload任务后，会触发另外两个任务connect与watch,其中connect会启动一个本地服务器，watch会监听scss文件夹下的.scss文件。在.scss文件发生变动后，watch任务会重新编译.scss文件，并触发connect.reload()方法，这个方法会让浏览器重新刷新，然后我们就可以自动刷新了。 八、默认任务每次gulp命令后面加一个任务名称会不会觉得超级烦？这时候只要以default为任务名称， 123gulp.task('default', function () &#123; // Your default task&#125;); 然后在命令行单单敲下gulp就能启动default任务了。 九、gulp-load-plugins每次gulpfile.js里需要require()那么多的依赖是不是也觉得超级烦？这个时候gulp-load-plugins可以解救我们，只要我们的package.json里有相关的依赖配置并且下载好了这些配置，那么我们就再也不需要require()那么多的依赖了，它写起来就像这样： 123456789101112var gulp = require('gulp'), gulpLoadPlugins = require('gulp-load-plugins'), plugins = gulpLoadPlugins();gulp.task('js', function () &#123; return gulp.src('js/*.js') .pipe(plugins.jshint()) .pipe(plugins.jshint.reporter('default')) .pipe(plugins.uglify()) .pipe(plugins.concat('app.js')) .pipe(gulp.dest('build'));&#125;); 生活就是这么美好，哈哈！ 参考文章Gulp – How To Build And Develop Websites By Callum Macrae]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载]Gulp资料大全 入门、插件、脚手架、包清单]]></title>
    <url>%2F2017%2F10%2F25%2F%E8%BD%AC%E8%BD%BD-Gulp%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8-%E5%85%A5%E9%97%A8%E3%80%81%E6%8F%92%E4%BB%B6%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6%E3%80%81%E5%8C%85%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[最近在学习Gulp,发现一个超级全的Gulp资料清单，在这里做一个分享。同时也要感谢原作者Pines-Cheng在github上的分享 awesome-gulp中文版 一份gulp的资源，插件和使用实例清单， 致力于打造更好的前端工程构建流程。 被老外的awesome 清单刺激到，觉得有必要翻译一份，为国产的程序员们做点事情，本清单将保持实时更新同步。PS:进都进来了，就顺便看看其他的吧: awesome-nodejs-cn awesome-react-cn awesome-npm-cn awesome-react-native-cn 项目的Github地址：awesome-react-cn,欢迎start。 翻译得仓促，如有问题，请提issues。 如果想贡献，请Pull Requests。 目录 资源 通用资源 官方文档 组织 入门教程 Gulp 入门 Gulp 4 入门 Gulp with Browserify Gulp with Angular Gulp with Angular and Browserify Gulp with Angular and Webpack Gulp with React and Browserify Gulp with Ember 其他资源 插件 编辑 编译 合并 压缩 优化 资源注入 模板 代码校验 实时加载 缓存 流控制 日志 测试 其他插件 脚手架 参考工程 Yeoman生成器 其他 资源通用资源 官网 Github库 插件注册 NPM模块 插件黑名单 官方文档 快速开始 API文档 CLI 文档 开始写一个插件 使用诀窍 组织 StackOverflow Twitter 入门教程Gulp入门 使用Gulp构建前端工程 通过Gulp.js轻松自动化构建你的前端工程 Gulp，让前端工程可视化 Gulp.js是什么？ 使用Gulp在你的HTML中直接插入Scripts和Styles标签 5节课学会使用Gulp.js 我是怎样摆脱前端工程的困扰的？ 第一次开始Gulp Task 为什么你不自己写一个Gulp插件？ 6个最好的从根本改善你的开发经验的Gulp实战练习 Gulp初学者教程 Gulp 4 入门 迁移到Gulp 4的例子 Gulp 4: 新的task执行系统 - gulp.parallel 和 gulp.series Gulp with Browserify Gulp + Browserify, the Gulp-y Way Gulp + Browserify 快速构建Browserify和Watchify Gulp with Angular Angular工程需要什么 - Gulp能提供什么 Gulp with Angular and Browserify 使用 Gulp, Node and Browserify构建先进的 AngularJS工程结构 Gulp with React and Browserify Browserify、Gulp 和 React Taking React to the Next Level: Mixins, Gulp, and Browserify Gulp with Ember 使用Gulp.js改进你的Ember.js工作流 其他资源 Gulp 备忘录 Gulp清单 插件编译 gulp-sass - 通过 libsass将Sass编译成 CSS gulp-ruby-sass - 通过 Ruby Sass将Sass编译成CSS gulp-compass - 通过 Ruby Sass和CompassSass编译成CSS gulp-less - Less编译成 CSS. gulp-stylus - Stylus 编译成 CSS. gulp-postcss - Pipe CSS 通过 PostCSS processors with a single parse. gulp-coffee - Coffeescript 编译成 JavaScript. gulp-typescript - TypeScript编译成JavaScript. gulp-react - Facebook React JSX 模板编译成JavaScript. webpack-stream - 将webpack集成在Gulp中使用。 gulp-babel - ES6编译成ES5 通过 babel. gulp-traceur - ES6编译成ES5 通过 Traceur. gulp-regenerator - ES6编译成ES5 通过 Regenerator. gulp-es6-transpiler - [过时的] ES6编译成ES5 通过 es6-transpiler. gulp-myth - Myth - a polyfill for future versions of the CSS spec. gulp-cssnext - [过时的] 使用下一代的 CSS 规范通过 cssnext. 合并 gulp-concat - 合并文件. 压缩 gulp-clean-css - 压缩 CSS 通过 clean-css. gulp-csso - 压缩 CSS 通过 CSSO. gulp-uglify - 压缩 JavaScript 通过 UglifyJS2. gulp-htmlmin - 压缩 HTML 通过 html-minifier. gulp-minify-html - 压缩 HTML 通过Minimize. gulp-imagemin - 压缩 PNG, JPEG, GIF and SVG 图片 通过 imagemin. gulp-svgmin - 通过Gulp压缩 SVG 文件 优化 gulp-uncss - 移除未使用的CSS选择器通过 UnCSS. gulp-css-base64 - 将CSS文件中所有的资源(有url()声明的)变成base64-encoded 数据的URI字符串 gulp-svg2png - 将SVGs转换成PNGs gulp-responsive - 生成不同尺寸的图片 gulp-svgstore -将svg files 合并成一个通过 元素 gulp-iconfont - 通过SVG icons创建 icon fonts 资源注入 gulp-useref - 解析HTML文件中特殊标签里面的script或style标签，合并成一个script或css文件，并替换。 gulp-inject - 将指定的css或js文件以标签的形式插入到HTML中的指定标志内。 wiredep - 将Bower依赖自动注入HTML文件中。 模板 gulp-angular-templatecache - 在$templateCache中联系并注册AngularJS模板 gulp-jade - Jade 转换成 HTML. gulp-handlebars - Handlebars模板转换成 JavaScript. gulp-hb - Handlebars 模板转换成 HTML. gulp-nunjucks - Nunjucks模板转换成JavaScript. gulp-dustjs - Dust模板转换成JavaScript. gulp-riot - Riot模板转换成JavaScript. gulp-markdown - Markdown → HTML. gulp-template - Lodash 模板转换成JavaScript. gulp-swig - Swig模板转换成HTML. gulp-remark - Gulp plugin for [remark]的Gulp插件(https://github.com/wooorm/remark) 通过插件处理markdown 代码校验 gulp-csslint - 通过CSSLint自动校验CSS. gulp-htmlhint - 通过HTMLHint校验HTML. gulp-jshint - 通过JSHint发现错误和潜在的问题. gulp-jscs - 通过jscs检查JavaScript代码风格. gulp-coffeelint - 一种用来保证CoffeeScript代码风格统一的检查。 gulp-tslint - gulp的TypeScript代码校验插件. gulp-eslint - ECMAScript/JavaScript代码校验. gulp-w3cjs - 通过w3cjs检验HTML. gulp-lesshint - 通过lesshint校验LESS. 实时加载 browser-sync - 保证多个浏览器或设备网页同步显示 (recipes). gulp-livereload - Gulp的实时加载插件. 缓存 gulp-changed - 仅让发生改变的文件通过. gulp-cached - 一个简单的文件内存缓存. gulp-remember - 记忆并回收通过了的文件. gulp-newer - 只让新的源码通过. 流控制 merge-stream - 合并多个流到一个插入的流. streamqueue - 逐渐输入队列的流. run-sequence - 按要求运行一些依赖的Gulptask. gulp-if - 按照条件运行task. 日志 gulp-notify - Gulp的通知插件. gulp-size - 显示你的项目的大小. gulp-debug - 通过调试文件流来观察那些文件通过了你的Gulp管道. 测试 gulp-mocha - 运行Mocha测试用例. gulp-jasmine - 在Node.js中运行Jasmine 2 测试用例. gulp-protractor - 为Protractor测试用例包裹Gulp. gulp-coverage - 为Node.js覆盖相对于运行的测试运行独立的报告. gulp-karma - 通过Gulp运行Karma测试用例. gulp-ava- 通过Gulp运行AVA 测试用例. 其他插件 gulp-util - 包含一系列有用插件. gulp-plumber - 防止错误引起管道中断Prevent pipe breaking caused by errors. gulp-load-plugins - 自动加载Gulp插件. main-bower-files - 构建时自动获取bower库的文件. autoprefixer - 解析CSS且根据规则添加浏览器兼容性前缀. gulp-sourcemaps - 提供source map支持. gulp-replace - Gulp的一个字符串替换插件. gulp-rename - 轻松重命名文件. gulp-rev - 在静态文件名的后面添加hash值，如: unicorn.css → unicorn-d41d8cd98f.css. del - 使用globs删除文件/文件夹. gulp-exec - 运行一个shell命令. gulp-strip-debug - 除去javascript代码中的console,alert,debugger声明. gulp-cssimport - 解析CSS文件，找到imports,将连接文件替换成imort声明. gulp-inline-css - 将HTML中的css属性放到style标签中. gulp-gh-pages - 将内容发布到GiHub有页面. gulp-ng-annotate - 通过ng-annotate添加Angular依赖注入. gulp-bump - 通过Gulp Bump任何semvar JSON版本. gulp-file-include - 通过Gulp Include文件. gulp-zip - 以ZIP格式压缩文件. gulp-git - 通过Gulp运行git命令. gulp-filter - 使用globbing过滤文件. gulp-preprocess - 基于自定义内容或环境配置预处理文件. 脚手架模板 web-starter-kit - Google的Web Starter Kit. gulp-plugin-boilerplate - 创建Gulp插件的开始模板. polymer-starter-kit -Polymer 1.0 应用的起点. este - 同构的web应用最全面的React/Flux开发栈和开始模板. mnml - 开发响应式HTML5/Sass项目的最小开始模板. kraken 一个轻量级的、移动端优先的前端开发开始模板. angularjs-gulp-browserify-boilerplate - 一个使用AngularJS, Sass, gulp, 和 Browserify技术的开始模板. hapi-ninja - 一个使用Node.js, Hapi, and Swig技术的开始模板. laravel-5-boilerplate - 一个Laravel 5 开始模板. react-starterkit - 包含react-router, Reflux, jest, webpack, gulp and Stylus的React开始模板. Yeoman生成器 generator-gulp-webapp - A 一个流行的web应用的gulp生成器. generator-gulp-angular - 使用Gulp的AngularJS 的Yeoman生成器. generator-react-gulp-browserify - 一个React库的Yeoman生成器，包含gulp, Browserify, Browsersync and Bootstrap. generator-node-gulp - 一个Node.js模块生成器，包含gulp和 Mocha. generator-gulp-bootstrap - 一个包含Bootstrap, gulp 和libsass的Yeoman生成器·. generator-angulpify - 一个包含AngularJS, gulp和Browserify的Yeoman生成器. generator-ionic-gulp - 一个Ionic工厂的Yeoman生成器. generator-gulp-plugin-boilerplate -一个输出 gulp plugin boilerplate的脚手架. generator-jekyllized - 一个包含gulp, Sass, AutoPrefixer,资源优化，缓存等的Jekyll工作流. 其他 elixir - 一个为你的应用定义基本的gulp任务的干净、灵活的API. gulp-app - 将Gulp作为一个应用(OS X). lmn-gulp-tasks - gulp任务的单元测试示例. gulp-chef - 一个优雅的、简单的重复使用gulp task的方法. 证书]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode上的一些算法题（二）]]></title>
    <url>%2F2017%2F10%2F24%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些关于股票的算法题，很有趣，在这里做一个分享 一、Best Time to Buy and Sell Stock II1、问题描述如下： Say you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1:1234Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2:1234Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. 2、这种情景相对简单，王二的解决方案如下： 12345678var maxProfit = function(prices) &#123; var min = 10000000 , out = 0; for(var x=0;x&lt;prices.length;x++)&#123; min = Math.min(min,prices[x]) out = Math.max(out,prices[x]-min) &#125; return out&#125;; 二、Best Time to Buy and Sell Stock III1、问题描述如下： Say you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete at most two transactions. Note:You may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). 这道题在第一次问题（只交易一次）的基础上变成交易两次，问题变得复杂了一些。 2、解决思路 于是写成如下代码：123456789101112131415161718192021222324var maxProfit = function(prices) &#123; var minIndex = 0,maxIndex=0; function temp(prices)&#123; var min = 1000000 , out = 0 ,tempMinIndex = 0; for(var x=0;x&lt;prices.length;x++)&#123; if(prices[x]&lt;min)&#123; min = prices[x] ; tempMinIndex = x ; &#125; if(prices[x]-min&gt;out)&#123; out = prices[x]-min ; maxIndex = x ; minIndex = tempMinIndex ; &#125; &#125; return out ; &#125; var a1 = temp(prices); var left = prices.slice(0,minIndex); var self = prices.slice(minIndex,maxIndex+1); var right = prices.slice(maxIndex+1); var a2 = Math.max(temp(left),temp(right),temp(self.reverse())) ; return a1+a2;&#125;; 123456789101112131415161718192021222324252627282930313233343536var maxProfit = function(prices, fee) &#123; total = 0 ; myIndex = 0 ; for(var i=myIndex;i&lt;prices.length-1;)&#123; if(myIndex===prices.length-1) break; tempIndex = myIndex; myPrice = undefined; sellPrice = 0; maxPrice = undefined; for(var x=myIndex;x&lt;prices.length;x++)&#123; tempIndex = x ; if(!myPrice || myPrice&gt;prices[x])&#123; myPrice = prices[x]; continue ; &#125; if(myPrice&lt;prices[x]-fee)&#123; break ; &#125; &#125; myIndex = tempIndex; maxPrice = Math.max(...prices.slice(myIndex)); for(var y=myIndex;y&lt;prices.length;y++)&#123; tempIndex = y ; if(sellPrice===maxPrice || sellPrice&gt;prices[y]+fee)&#123; break ; &#125; if(sellPrice&lt;prices[y])&#123; sellPrice = prices[y]; continue ; &#125; &#125; total += Math.max(sellPrice-myPrice-fee,0); myIndex = tempIndex; &#125; return total ;&#125; 123456789101112131415var maxProfit = function(prices, fee) &#123; var curMin = 10000000, curMax = 0, res = 0; for (var i = 0; i &lt; prices.length; ++i) &#123; if (prices[i] &lt; curMax - fee) &#123; if (curMax - curMin &gt; fee) res += curMax - curMin - fee; curMin = prices[i]; curMax = prices[i]; &#125; else &#123; curMin = Math.min(curMin, prices[i]); curMax = Math.max(curMax, prices[i]); &#125; &#125; if (curMax - curMin &gt; fee) res += curMax - curMin - fee; return res;&#125; Number.MAX_VALUE 四、12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var maxProfit = function(k, prices) &#123; console.time() ; var keyIndex = [0,prices.length-1] ; var whole = 0 ; function temp(prices,start,end,isReverse)&#123; var minIndex = 0,maxIndex=0; var min = 1000000 , out = 0 ,tempMinIndex = 0; if(!isReverse)&#123; for(var x=start;x&lt;=end;x++)&#123; if(prices[x]&lt;min)&#123; min = prices[x] ; tempMinIndex = x ; &#125; if(prices[x]-min&gt;out)&#123; out = prices[x]-min ; maxIndex = x ; minIndex = tempMinIndex ; &#125; &#125; &#125;else&#123; for(var x=end;x&gt;=start;x--)&#123; if(prices[x]&lt;min)&#123; min = prices[x] ; tempMinIndex = x ; &#125; if(prices[x]-min&gt;out)&#123; out = prices[x]-min ; maxIndex = x ; minIndex = tempMinIndex ; &#125; &#125; &#125; return [out,[maxIndex,minIndex]] ; &#125; for(var x=1;x&lt;=k;x++)&#123; var sell = 0 ; var currentIndex = [] ; var isReverse = true ; for(var y=0;y&lt;keyIndex.length;y++)&#123; if(y===0) continue ; isReverse = !isReverse ; var getVal = temp(prices,keyIndex[y-1],keyIndex[y],isReverse) ; if(sell&lt;getVal[0])&#123; sell = getVal[0] ; currentIndex = getVal[1] ; &#125; &#125; if(sell===0)&#123; //当遍历所有后,sell还是0的话，说明已经没有合适的对象了，于是退出循环 console.timeEnd() ; return whole ; &#125; keyIndex = keyIndex.concat(currentIndex) ; keyIndex.sort((x,y)=&gt;x&gt;y?1:-1) ; //这边的排序方法要特别注意 whole += sell ; &#125; console.timeEnd() ; return whole ;&#125;; 123456789101112131415161718192021222324252627282930var maxProfit = function(k, prices) &#123; console.time(); function quickSolve(prices) &#123; var len = prices.length, profit = 0; for (var i = 1; i &lt; len; i++) // as long as there is a price gap, we gain a profit. if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1]; return profit; &#125; var len = prices.length; if (k &gt;= len / 2) return quickSolve(prices); var t = new Array(k+1); for(var x=0;x&lt;t.length;x++)&#123; t[x] = new Array(len); for(var y=0;y&lt;t[x].length;y++)&#123; t[x][y] = 0 &#125; &#125; for (var i = 1; i &lt;= k; i++) &#123; var tmpMax = -prices[0]; for (var j = 1; j &lt; len; j++) &#123; t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax); tmpMax = Math.max(tmpMax, t[i - 1][j - 1] - prices[j]); &#125; &#125; console.timeEnd(); return t[k][len - 1];&#125;; 五、1234567891011121314151617181920212223242526272829303132//未完成var maxProfit = function(prices) &#123; var min = 10000000 ,max = 0,out=0 ; for(var x = 0 ; x&lt;prices.length ; x++)&#123; min = Math.min(min,prices[x]) ; max = Math.max(max,prices[x]) ; if(x===prices.length-1)&#123; console.log("-------") console.log(prices[x]) console.log(out) console.log(min,max) console.log("-------") out += max-min ; continue ; &#125; if(prices[x+1]&lt;prices[x])&#123; console.log("+++++++++") console.log(x) console.log("+++++++++") if(prices[x+2]-prices[x+1]&gt;(price[x-1]?prices[x]-prices[x-1]:0))&#123; out += (price[x-1]?prices[x-1]-min:0) ; console.log("######1:"+out) &#125;else&#123; out += prices[x]-min ; console.log("######2:"+out) x++ ; &#125; min = 10000000 ,max = 0 ; &#125; &#125; return out ;&#125; 参考文献：leetcode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（四）]]></title>
    <url>%2F2017%2F10%2F24%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python函数式编程中一些高阶函数、返回函数、匿名函数、装饰器、偏函数中值得留意的地方。 一、高阶函数1、mapmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 2、reducereduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 3、filterfilter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 例如，在一个list中，删掉偶数，只保留奇数，可以这么写：12345data = [1, 2, 4, 5, 6, 9, 10, 15]def is_odd(n): return n % 2 == 1list(filter(is_odd, data))# 结果: [1, 5, 9, 15] 需要注意的是，以上返回的序列是一个新的序列，原来的data序列不变。 4、用filter求素数 计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单： 首先，列出从2开始的所有自然数，构造一个序列： 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉： 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉： 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数5，然后用5把序列的5的倍数筛掉： 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 不断筛下去，就可以得到所有的素数。 用Python来实现这个算法，可以先构造一个从3开始的奇数序列： 12345def _odd_iter(): n = 1 while True: n = n + 2 yield n 注意这是一个生成器，并且是一个无限序列。 然后定义一个筛选函数： 12def _not_divisible(n): return lambda x: x % n &gt; 0 最后，定义一个生成器，不断返回下一个素数： 1234567def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。 由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件： 123456# 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break 注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。 5、 sortedsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，接收一个reverse函数来实现反向排序，参考如下代码： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 二、返回函数1、高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、闭包如果返回的函数依赖其父作用域，那么就形成了闭包。 3、另外需要注意的是，返回的函数并不会立刻执行，而是直到调用了f()才执行。参考如下代码：12345678910111213141516def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 我们发现，返回的结果都为9，原因就在于返回的函数引用了其父作用域的变量i，但它并非立刻执行。当for循环完成时，变量i已经变成了3，因此最终结果为9。 如果要解决此问题，再创建一个函数，用该函数的参数绑定循环变量当前的值，脱离对父作用域的依赖，参考如下代码： 1234567891011121314151617def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()4&gt;&gt;&gt; f3()9 三、匿名函数在Python中，对匿名函数提供了一些支持,下面的f(x)可以写成匿名函数lambda x: x * x 12def f(x): return x * x 四、装饰器1、在java中有个设计模式叫装饰者模式，可以扩充类的功能。在python中，要想实现类似的功能，可以使用“装饰器”（Decorator）。 2、参考如下简单的代码： 1234567891011121314def log(func): def hala(): print('在这里打印日志') return func() return hala@logdef now(): print('2015-3-25')now()#在这里打印日志#2015-3-25 简单来说。把@log放到now()函数的定义处，相当于执行了语句： now = log(now) 3、如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本： 12345678910111213141516def log(text): def decorator(func): def hala(): print('在这里打印日志'+text) return func() return hala return decorator@log('execute')def now(): print('2015-3-25')now()#在这里打印日志execute#2015-3-25 4、以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的&#39;now&#39;变成了&#39;hala&#39;： 12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个hala()函数名字就是&#39;hala&#39;，所以，需要把原始函数的__name__等属性复制到hala()函数中，否则，有些依赖函数签名的代码执行就会出错。 不需要编写hala.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下： 123456789101112import functoolsdef log(func): @functools.wraps(func) def hala(): print('在这里打印日志') return func() return hala@logdef now(): print('2015-3-25') 或者针对带参数的decorator： 1234567891011121314import functoolsdef log(text): def decorator(func): @functools.wraps(func) def hala(): print('在这里打印日志'+text) return func() return hala return decorator@log('execute')def now(): print('2015-3-25') 五、偏函数1、Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。 2、使用场景int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换： 12&gt;&gt;&gt; int('12345')12345 int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换： 1234&gt;&gt;&gt; int('12345', base=8)5349&gt;&gt;&gt; int('12345', 16)74565 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去： 12def int2(x, base=2): return int(x, base) 这样，我们转换二进制就非常方便了： 1234&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 我们使用偏函数也能解决上述问题，参考如下代码： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值： 12&gt;&gt;&gt; int2('1000000', base=10)1000000 实际上，在创建偏函数时，可以接收函数对象、args和*kw这3个参数，当传入： 1int2 = functools.partial(int, base=2) 实际上固定了int()函数的关键字参数base，也就是： 1int2('10010') 相当于： 12kw = &#123; 'base': 2 &#125;int('10010', **kw) 当传入： 1max2 = functools.partial(max, 10) 实际上会把10作为*args的一部分自动加到左边，也就是： 1max2(5, 6, 7) 相当于： 12args = (10, 5, 6, 7)max(*args) 结果为10。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（三）]]></title>
    <url>%2F2017%2F10%2F24%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python中切片、迭代、列表生成式、生成器、迭代器中值得留意的地方。 一、切片Python提供了切片（Slice）操作符，帮我们完成取一个list或tuple的部分元素的操作。Slice的常见用法参考如下代码： 1234567891011121314151617181920212223242526272829303132333435363738#先创建一个0-99的数列&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99]#可以通过切片轻松取出某一段数列。比如前10个数&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]#后10个数&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99]#前11-20个数&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19]#前10个数，每两个取一个&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8]#所有数，每5个取一个&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]#甚至什么都不写，只写[:]就可以原样复制一个list&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99]#tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2)#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 二、迭代1、默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 2、可以通过collections模块的Iterable类型再通过isinstance方法判断一个对象是否是可迭代对象,参考如下代码：1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 3、如果要对list实现下标循环，可以用Python内置的enumerate函数可以把一个list变成索引-元素对，参考如下代码：123456&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C 4、上面的for循环里，同时引用了两个变量，在Python里是很常见的，参考如下代码：123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 三、列表生成式1、在python基础语法小结（一）里，我们了解到用list(range(5))可以生成的序列从0开始小于5的整数: 12&gt;&gt;&gt;list(range(5))[ 0,1, 2, 3, 4] 但如果要生成[0x0, 1x1, 2x2, 3x3, 4x4]就会有些麻烦，需要用for循环：123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(5):... L.append(x * x)...&gt;&gt;&gt; L[0, 1, 4, 9, 16] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(5)][0, 1, 4, 9, 16] 2、for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 3、还可以使用两层循环，可以生成全排列：12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 4、列表生成式还可以使用两个变量来生成list：123&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] 四、生成器1、通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 2、要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： 12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; G = (x * x for x in range(10))&gt;&gt;&gt; G&lt;generator object &lt;genexpr&gt; at 0x000001D760F85BF8&gt;#而且用for迭代时，使用上去也没有差异&gt;&gt;&gt; for i in L:... print(i)0149162536496481&gt;&gt;&gt; for i in G:... print(i)0149162536496481 3、另外一个创建generator的方法是在一个函数定义中包含yield关键字,例如下面一个计算斐波拉契数列（Fibonacci）的函数： 12345678910111213141516def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; fib(6)112358'done' 只需要将其中的print(b)改为yield b,那么fib函数就变成generator： 1234567891011121314151617181920def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x000001D760F85CA8&gt;&gt;&gt;&gt; for i in f:... print(i)112358 五、迭代器1、凡是可作用于for循环的对象都是Iterable类型；例如集合数据类型，list、tuple、dict、set、str等；还有generator，包括生成器和带yield的generator function。 2、凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 3、集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。而generator既是Iterable类型也是Iterator类型。 3、王二认为，可以将Iterable类型比喻为本科生，Iterator类型比喻为硕士生，硕士生一定是本科生，但本科生不一定是研究生，本科生（Iterable）可以通过考研（iter()）变为研究生（Iterator）。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode上的一些算法题（一）]]></title>
    <url>%2F2017%2F10%2F23%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些关于字符串的有趣的算法题，在这里做一个分享 一、Longest Substring Without Repeating Characters1、问题描述如下 ： Given a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 原问题地址点这里 2、王二一开始的算法如下： 12345678910111213141516171819202122232425262728293031var lengthOfLongestSubstring = function(s) &#123; if (s.length===0) return; var element = &#123;&#125; ; var maxLength = 0 ; var currentLength = 0 ; var currentIndex = 0 ; for(var x=0;x&lt;s.length;x++)&#123; var i = s[x]; if(element.hasOwnProperty(i))&#123; var index = element[i] ; currentLength = 0 ; for(var temp of Object.entries(element))&#123; if(temp[1]&lt;=index)&#123; delete element[temp[0]] ; &#125;else&#123; currentLength++ ; &#125; &#125; element[i] = x ; currentLength++ ; &#125;else&#123; element[i] = x ; currentLength++ ; if(currentLength&gt;maxLength)&#123; maxLength = currentLength ; currentIndex = x ; &#125; &#125; &#125; return [maxLength,s.substr(currentIndex-maxLength+1,maxLength)] ;&#125; 算法的时间复杂度为O(n)，参考如下验证时间为O(n)的代码： 123456789101112131415161718192021222324function getRandomStr(len) &#123; //随机获取字符串，len为随机字符串的长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;var validate = function()&#123; var str = getRandomStr(100000) ; console.time('str100000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str100000') ; var str = getRandomStr(1000000) ; console.time('str1000000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str1000000') ;&#125;validate() ; 执行时间如下图所示： 3、王二的解决思路如下：把字符串看成一个游标，每for循环一次就相当于在游标上走一格，算法会设置一个element对象，每走一格，算法会判断element对象中有没有这一格的值。 如果没有，就会将这一格的值加入到element对象中，加完后再将element的长度与maxLength作比较，将较大值重新赋值给maxLength。 如果有，会将element对象中这一格之前的值都给清除掉。 4、不过leetcode上大神们有更巧妙的解决思路，参考如下（原文点击这里）： 12345678910111213public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if (map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; 大神的思路是这样的 ： the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. 5、于是王二参考大神的思路写下了如下的算法： 123456789101112131415161718var lengthOfLongestSubstring = function(s) &#123; if (s.length==0) return 0; var map = &#123;&#125;; var maxLength=0; var currentIndex = 0; for (var i=0, j=0; i&lt;s.length; ++i)&#123; if (map.hasOwnProperty(s[i]))&#123; j = Math.max(j,map[s[i]]+1); &#125; map[s[i]] = i; temp = Math.max(maxLength,i-j+1); if(temp&gt;maxLength)&#123; maxLength = temp ; currentIndex = i ; &#125; &#125; return [maxLength,s.substr(currentIndex-maxLength+1,maxLength)];&#125; 它的算法的时间复杂度为O(n)，而且执行效率更高，参考如下验证代码： 123456789101112131415161718192021222324function getRandomStr(len) &#123; //随机获取字符串，len为随机字符串的长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;var validate = function()&#123; var str = getRandomStr(100000) ; console.time('str100000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str100000') ; var str = getRandomStr(1000000) ; console.time('str1000000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str1000000') ;&#125;validate() ; 执行时间如下图所示： 二、Longest Palindromic Substring1、问题描述如下： Given a string s, find the longest palindromic substring in s. Example: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example: Input: “cbbd”Output: “bb” 原问题地址点这里 2、王二的算法如下： 123456789101112131415161718var longestPalindrome = function(s) &#123; s = ' '+s.split('').join(' ')+' '; var out = '' ; for(var x=0 ; x&lt;s.length ; x++)&#123; var temp = s[x] ; for(var y=1 ; y&lt;=x ; y++)&#123; if(s[x-y]===s[x+y])&#123; temp = s[x-y] + temp + s[x+y] ; &#125;else&#123; break ; &#125; &#125; if(out.length&lt;temp.length)&#123; out = temp ; &#125; &#125; return out.split(/\s+/).join('') ;&#125;; 该算法也是O(n)的时间复杂度。 在解决这个问题的时候，王二遇到了一个问题：上述代码如果直接for循环，那么遇到偶数个回文时就不会正确处理，那该怎么办呢？王二的解决方法是在单个字符之间插入空格，那么将空格算进去后，返回的回文数一定是奇数个，最后返回的时候再将空格都去除掉，问题就解决了。 最后推荐一个很好的刷题的网站leetcode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（二）]]></title>
    <url>%2F2017%2F10%2F21%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了函数中内置函数、参数返回值、默认函数、可变参数、关键字参数、递归函数中值得留意的地方。 一、函数1、python内置了很多有用的函数，我们可以直接从pyhton的官方网站中查看到。 2、如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass 3、python 的函数可以返回多个值，但其实就是一个tuple。 4、默认参数 python 的函数传的参数数量需要与函数定义参数的数量一致，如果不一致，就会报错，参考如下代码： 1234567891011121314def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s&gt;&gt;&gt; power(5, 3)125&gt;&gt;&gt; power(5)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: 'n' 为了避免这种情况，可以使用默认参数，参考如下代码： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 需要注意的是，设置默认参数时，必选参数在前，默认参数在后，否则Python的解释器会报错。另外，当默认参数的默认值是一个引用变量时，我们会很有可能掉进坑里，参考如下代码： 123def add_end(L=[]): L.append('END') return L 当正常调用时，结果似乎不错： 1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 当使用默认参数调用时，一开始结果也是对的： 12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了’END’后的list。 原因解释如下：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！ 在JS的ES6语法中，为函数设置默认参数时，不会出现以上Python中遇到的问题，在这一点上，JS和Python有差异 要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 现在，无论调用多少次，都不会有问题： 1234&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END'] 5、可变参数定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。Python还允许我们在list或tuple前面加一个号，把list或tuple的元素变成可变参数传进去。 6、关键字参数可变参数允许我们传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许我们可以传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。参考如下代码： 12def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 7、尾递归在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 这个时候可以使用尾递归来优化算法，王二认为，尾递归的核心要素在于函数return出来的东西不能对其父作用域有依赖关系 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（一）]]></title>
    <url>%2F2017%2F10%2F19%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了数据类型和变量、list 、tuple、循环、dict、set中值得留意的地方。 一、数据类型和变量1、在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。下表是开发中一些常用的转义字符： 转义字符 描述 \(在行尾时) 续行符 \\ 反斜杠符号 \&#39; 单引号 \&quot; 双引号 \n 换行 \t 横向制表符 2、如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，参考如下代码： 1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 3、如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容。 4、在python中，在Python中，布尔值的首字母是大写的（True，False） 5、在python3中，有两种除法： 一种除法是/,其计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12345&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 这一点和python2的语法有差异。 二、使用list1、list是一种有序的集合，可以随时添加和删除其中的元素。 2、用len()函数可以获得list元素的个数： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3 3、list可以用负数做索引，例如-1做索引，可以直接获取最后一个元素： 12&gt;&gt;&gt; classmates[-1]'Tracy' 4、append可以往list中追加元素到末尾。 5、也可以把元素插入到指定的位置，比如索引号为1的位置： 1234&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 6、pop 会删除list末尾的元素，如果要删除指定位置的元素，可以用pop(i)方法，其中i是索引位置。 7、如果要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： 123&gt;&gt;&gt; classmates[1] = &apos;Sarah&apos;&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 三、使用tuple1、tuple和list非常类似，但是tuple一旦初始化就不能修改。 2、如果要定义一个空的tuple，可以写成()；但是，要定义一个只有1个元素的tuple，如果你这么定义： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 四、循环1、如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数: 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 如果要计算0～100的和，可以参考如下代码： 1234sum = 0for x in range(101): sum = sum + xprint(sum) 五、使用dict1、Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 2、如果要删除dict中的一个key，可以用pop(key)方法，对应的value也会从dict中删除。 3、和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 六、使用set1、set中不可以放入可变对象，例如，下面代码会出错： 1234&gt;&gt;&gt; set([1, 1, 2, 2, [3], 3])Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; 这一点和JS里的Set有出入，在JS中，引用类型对象也可以放入Set对象中。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道算法题以及关于其时间复杂度的一些讨论]]></title>
    <url>%2F2017%2F10%2F19%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些算法题，其中有一个Two Sum的算法，其中涉及一些关于时间复杂度的问题，在这里做一个讨论 一、算法描述如下：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 如果想看leetcode上关于two sum的描述可以点这里 二、解决思路1、王二最开始写下了如下算法： 123456789101112function twoSum (nums,target) &#123; var out ; nums.forEach(function(element1,index1) &#123; nums.forEach(function(element2,index2)&#123; if(index2&lt;=index1) return ; if(element1+element2===target &amp;&amp; !out)&#123; out = [index1,index2] &#125; &#125;) &#125;); return out ;&#125; 但是以上算法有一个缺陷，Array.prototype.forEach在遍历数组时中途不能跳出循环，除非我手动抛出一个错误，但是这样就显得非常不优雅了。 2、于是王二想到了可以用for循环，代码如下： 123456789function twoSum (nums,target) &#123; for (var x=0; x&lt;nums.length;x++)&#123; for (var y=x+1; y&lt;nums.length;y++)&#123; if(nums[x]+nums[y]===target)&#123; return [x,y] ; &#125; &#125; &#125;&#125; 这样写的话，只要一找到符合条件的数组，就能跳出循环，相比第一种方法效率提高了不少。 3、不过王二觉得两层for循环是在是不太好看，甚至觉得有点low，一定有其他的解决方案，于是又细细思索了一下，改进了代码如下： 123456function twoSum (nums,target) &#123; for (var x=0; x&lt;nums.length;x++)&#123; var y = nums.lastIndexOf(target-nums[x]) if(y&gt;0) return x===y?undefined:[x,y] ; &#125;&#125; 这样写的话代码就显得优雅精悍的多了，但它本质上还是两层循环，时间复杂度仍然为O(n^2)，因为indexOf是数组的元素存在性检查方法。需要遍历所有元素来检查，此方法的时间复杂度是O(n) 参考如下验证时间为O(n^2)的代码：12345678910111213141516171819202122232425function largeArray(index) &#123; var arr = [] ; var count = 1 ; for(var x = 0;x&lt;index;x++)&#123; arr.push(count++); &#125; return arr ;&#125;function twoSum (nums,target) &#123; console.time() ; for (var x=0; x&lt;nums.length;x++)&#123; var y = nums.lastIndexOf(target-nums[x]) if(y&gt;0) &#123; return x===y?undefined:[x,y] ; &#125; &#125; console.timeEnd() ;&#125;//注意arr1与arr2分开执行var arr1 = largeArray(10000);//var arr2 = largeArray(100000);twoSum(arr1,10000000) //为10000000时，方法由于找不到适配的结果，所以会遍历所有情况//twoSum(arr2,10000000) 执行时间如下图所示： 可以发现在数组长度多了10倍的情况下，执行时间多了近100倍。 4、leetcode上有大神用java写下了如下代码(链接在这里)：12345678910111213public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; if (map.containsKey(target - numbers[i])) &#123; result[1] = i + 1; result[0] = map.get(target - numbers[i]); return result; &#125; map.put(numbers[i], i + 1); &#125; return result;&#125; 它的时间复杂度为O(n)，原因是作者巧妙地运用了HashMap的containsKey()方法，由于HashMap使用哈希表来存储元素，所以在查询key时，其时间复杂度为O(1)。 5、于是我也用js复原了一下上面的java算法，参考如下：123456789function twoSum (nums,target) &#123; var obj = &#123;&#125;; for (var x=0; x&lt;nums.length;x++)&#123; if(obj.hasOwnProperty(target-nums[x])) &#123; return [obj[target-nums[x]],x] ; &#125; obj[nums[x]]=x; &#125;&#125; 这里的Object.prototype.hasOwnProperty类似java中HashMap的containsKey()方法，时间复杂度为O(1)；所以以上代码的时间复杂度也变成了O(n) 参考如下验证时间为O(n)的代码：1234567891011121314151617181920212223242526function largeArray(index) &#123; var arr = [] ; var count = 1 ; for(var x = 0;x&lt;index;x++)&#123; arr.push(count++); &#125; return arr ;&#125;function twoSum (nums,target) &#123; console.time() ; var obj = &#123;&#125;; for (var x=0; x&lt;nums.length;x++)&#123; if(obj.hasOwnProperty(target-nums[x])) &#123; return [obj[target-nums[x]],x] ; &#125; obj[nums[x]]=x; &#125; console.timeEnd() ;&#125;//注意arr1与arr2分开执行var arr1 = largeArray(10000);//var arr2 = largeArray(100000);twoSum(arr1,10000000) //为10000000时，方法由于找不到适配的结果，所以会遍历所有情况//twoSum(arr2,10000000) 执行时间如下图所示： 可以发现在数组长度多了10倍的情况下，执行时间也只多了不到10倍。 二、小结上述代码中，在数组长度很大的情况下，时间复杂度为O(n^2)与时间复杂度为O(n)的执行效率相差了近万倍，有时候会严重地影响性能，从这一点来看，以后写算法的时候要特别注意算法的时间复杂度； 参考文章：leetcodesegmentfaultCSDN”旧时光“的博客]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式踩坑小结]]></title>
    <url>%2F2017%2F10%2F12%2FCSS%E6%A0%B7%E5%BC%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近做了一些项目，在CSS方面遇到了不少坑，在这里做一个小结 一、iOS上的Safari没有滑动惯性在开发iphone微信端的时候，如果给一个div设置样式为滑动,样式如下：123div&#123; overflow-y:scroll ;&#125; 会发现Safari的滑动很僵硬，这时候可以用以下样式来解决：123div&#123; -webkit-overflow-scrolling: touch;&#125; 二、去除iphone中点击按钮会出现一个半透明的灰色背景的问题在开发iphone微信端的时候，同样发现，如果点击一个按钮，按钮会出现一个半透明的灰色背景，这时候可以用以下样式来解决： 123a,img,button,input,textarea,div&#123; -webkit-tap-highlight-color:rgba(255,255,255,0); &#125; 三、div中保留文本的空格、换行以及tab字符的处理在后台用textarea标签写入文本放入前端显示的时候，发现之前在textarea中的文本都被格式化了（浏览器默认把文本中的空格、换行以及tab字符都处理掉了），如果想保留文本的格式，可以用以下样式来解决： 123div&#123; white-space: pre-wrap;&#125; 需要特别注意的是，white-space有五种值可以选择，normal、pre 、nowrap 、pre-wrap、pre-wrap,每一种值都有不同的表现形式，其中： normal 是 white-space 的默认值； pre 会保留文本中额外的空格, 而且会保留文本中的换行； nowrap 不会保留文本中额外的空格，而且会禁止文本中的换行； pre-wrap 会保留文本中额外的空格, 而且会让文本正常的换行； pre-line 不会保留文本中额外的空格，但是会让文本正常的换行； 这样解释读者会有一些迷惑，接下来用代码进一步说明，参考如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;style&gt; .a&#123; white-space: pre &#125; .b&#123; white-space: nowrap &#125; .c&#123; white-space: pre-wrap &#125; .d&#123; white-space: pre-line &#125; .e&#123; white-space: normal &#125;&lt;/style&gt;&lt;div class="a"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="b"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="c"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="d"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="e"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt; 这里我们要特地留意一下 pre 与 pre-wrap 的区别，正常情况下，两者的现实没有差异，如下图： 但是如果将窗口拉窄,我们会发现，pre-wrap会让文本根据窗口宽窄自动换行，而pre的换行不会受窗口宽窄影响： 四、让盒子里的字超出长度后，可以缩略显示变成点点点1、在 div 框里的内容超出长度后，我们可以让超出部分的内容变成点点点，样式如下： 12345div&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;&#125; 然后我们就能获得我们想要的样式： 1234567891011121314151617&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .ellipsis&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; &#125;&lt;/style&gt;&lt;div class="a"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt; 效果图如下： 2、但是如果我们想让div里的内容两行或者三行之后再显示点点点，我们应该怎么办呢？如果你也有疑惑，可以参考如下代码： 123456789101112131415161718&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="a"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt; 效果图如下： 这时候变成三行后再省略也相当简单，直接将 -webkit-line-clamp 变成 3 就行了。 3、特别特别需要注意的是，如果遇到丧心病狂的测试，他会给出一长串连续的英文字符，那么以上代码有可能会失效，这时候就需要word-break: break-all; 来帮助我们，参考如下代码： 1234567891011121314151617181920212223242526272829&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .break&#123; word-break: break-all ; &#125; .ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="a"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a break ellipsis"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a break"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt; 效果图如下： 五、word-wrap和word-break的区别1、word-wrap和word-break都能使过长的字符串断开，防止其溢出，那他们两的区别又是什么呢？ 2、我们先从MDN文档里了解它们的概要： CSS 属性 word-break 指定了怎样在单词内断行。他的属性有： normal 使用默认的断行规则。 break-all 对于non-CJK (CJK 指中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 CSS 属性 word-wrap 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。他的属性有： normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被被分割的单词会被强制分割换行。 3、仅仅看解释并不能看出什么头绪，接下来用代码来演示他们的差异，代码如下： 12345678910111213141516171819202122&lt;style&gt;.a&#123; width:100px; border: 1px solid gray;&#125;.break&#123; word-break: break-all ;&#125;.wrap&#123; word-wrap: break-word ;&#125;&lt;/style&gt;&lt;div class="a"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt;&lt;hr&gt;&lt;div class="a break"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt;&lt;hr&gt;&lt;div class="a wrap"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt; 效果图如下： 我们发现，当使用word-wrap: break-word;时，如果这个时候文本溢出，它会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话才会进行单词内的断句。而使用word-break:break-all时，他会直接进行单词内的断句。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.keys、Object.values、Object.entries的使用方法]]></title>
    <url>%2F2017%2F10%2F11%2FJS%E4%B8%ADObject-keys%E3%80%81Object-values%E3%80%81Object-entries%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.keys、Object.values、Object.entries的使用方法 一、大致了解首先我们需要了解的是Object.keys是ES5中引入的的方法，在ES2017中，引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段。 需要注意的是，Object.keys(),Object.values(),Object.entries()都会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致( 区别在于 for...in 还会循环枚举原型链中的属性 )。 参考一些代码：1234567let obj = &#123; a: 1, b: 2, c: 3 &#125;;Object.keys(obj); // ['a','b','c']Object.values(obj); // [1,2,3]Object.entries(obj); // [['a',1],['b',2],['c',3]] 我们会发现，Object.keys会返回参数对象自身的所有可遍历属性的键名形成的数组，Object.values会返回参数对象自身的所有可遍历属性的键值形成的数组，Object.entries会返回参数对象自身的所有可遍历属性的键值对数组形成的数组 二、其他一些例子再来看一些Object.keys、Object.values、Object.entries的其他使用方法：123456789101112131415161718192021222324252627/* Array 对象 */ var arr = ["a", "b", "c"];console.log(Object.keys(arr)); // ["0", "1", "2"]console.log(Object.values(arr)); // ["a", "b", "c"]console.log(Object.entries(arr)); // [["0", "a"], ["1", "b"], ["2", "c"]]/* 类数组 对象 */ var obj = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;console.log(Object.keys(obj)); // ["0", "1", "2"]console.log(Object.values(obj)); // ["a", "b", "c"]console.log(Object.entries(obj)); // [["0", "a"], ["1", "b"], ["2", "c"]]/* 类数组 对象, 随机排序 */var obj1 = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;; console.log(Object.keys(obj1)); // ["2", "7", "100"]console.log(Object.values(obj1)); // ["b", "c", "a"]console.log(Object.entries(obj1)); // [["2", "b"],["7", "c"],["100", "a"]]/* a 是个不可枚举的属性 */ var obj2 = &#123;&#125;Object.defineProperty(obj2,'a', &#123; value : "hala"&#125;);obj2.b = "heihei";console.log(Object.keys(obj2)); // ['b']console.log(Object.values(obj2)); // ['heihei']console.log(Object.entries(obj2)); // [["b", "heihei"]] 三、注意点在ES5里，如果传入的参数不是对象（而是一个原始值），那么它会抛出 TypeError。但是在ES2015中，非对象的参数将被强制转换为一个对象，参考如下代码：12345678Object.keys("foo"); // TypeError: "foo" is not an object (ES5 code)Object.keys("foo");// ["0", "1", "2"] (ES2015 code)Object.values("foo"); // TypeError: "foo" is not an object (ES5 code)Object.values("foo");// ["f", "o", "0"] (ES2015 code)Object.entries("foo"); // TypeError: "foo" is not an object (ES5 code)Object.entries("foo");// [["0", "f"],["1", "o"],["2", "o"]] (ES2015 code) 四、Object.entries的另外用法new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以很容易的将Object转换为Map,参考如下代码： 123var obj = &#123; foo: "bar", baz: 42 &#125;; var map = new Map(Object.entries(obj));console.log(map); // Map &#123; foo: "bar", baz: 42 &#125; 参考文档MDN web docs阮一峰ES6语法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.create的使用方法]]></title>
    <url>%2F2017%2F10%2F10%2FJS%E4%B8%ADObject-defineProperty%E4%B8%8EObject-create%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%952%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.create的使用方法 一、Object.create1、Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象，语法如下： Object.create(proto, [ propertiesObject ]) 其中： proto一个对象，新创建对象的原型 propertiesObject可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。 函数将返回一个定原型对象上添加新属性后的新对象 如果 propertiesObject 参数不是 null 也不是对象，则抛出一个 TypeError 异常。 2、一些例子： 1234var a = &#123;v:41&#125;var b = Object.create(a)b.__proto__ === a //true //Object.create返回的对象的原型是其第一个参数。 123o = &#123;&#125;;// 以字面量方式创建的空对象就相当于:o = Object.create(Object.prototype); 12345678910111213141516o = Object.create(Object.prototype, &#123; // foo会成为所创建对象的数据属性 foo: &#123; writable:true, configurable:true, value: "hello" &#125;, // bar会成为所创建对象的访问器属性 bar: &#123; configurable: false, get: function() &#123; return 10 &#125;, set: function(value) &#123; console.log("Setting `o.bar` to", value); &#125; &#125;&#125;); 1234567891011121314// 创建一个以另一个空对象为原型,且拥有一个属性p的对象o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:o.p = 24o.p //42o.q = 12for (var prop in o) &#123; //for..in..不可枚举 console.log(prop)&#125;//"q"delete o.p // Nothing happens 123456789//创建一个可写的,可枚举的,可配置的属性po2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;); 3、使用 Object.create 实现类式继承,参考如下代码： 1234567891011121314151617181920212223242526272829//Shape - superclassfunction Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info("Shape moved.");&#125;;// Rectangle - subclassfunction Rectangle() &#123; Shape.call(this); //call super constructor.&#125;// subclass extends superclassRectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // trueconsole.log('Is rect an instance of Shape?', rect instanceof Shape); // truerect.move(1, 1); //Outputs, "Shape moved." 如果有兴趣了解用其他方式实现类继承，可以参考我的这篇博客理解原型链; 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.defineProperty的使用方法]]></title>
    <url>%2F2017%2F10%2F10%2FJS%E4%B8%ADObject-defineProperty%E4%B8%8EObject-create%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.defineProperty的使用方法 一、Object.defineProperty1、Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，语法如下： Object.defineProperty(obj, prop, descriptor) 其中： obj是需要被操作的目标对象 prop是目标对象需要定义或修改的属性的名称 descriptor是将被定义或修改的属性的描述符 函数将返回被传递给函数的对象 2、一个简单的实例： 12var o = &#123;&#125;;Object.defineProperty(o, "a", &#123;value : 37&#125;); //&#123;a: 37&#125; 上述代码中，我们用Object.defineProperty为对象o创建的了一个新属性a,它的值为37，但是我们也发现了一些问题，参考如下代码： 12345var o = &#123;&#125;;Object.defineProperty(o, "a", &#123;value : 37&#125;); //&#123;a: 37&#125;console.log(o.a); // 打印 37o.a = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）console.log(o.a); // 打印 37， 赋值不起作用。 我们发现，对o.a赋值似乎不起作用，原来Object.defineProperty的第三个参数descriptor有很多属性描述符，其中就有是否能被赋值运算符改变value的属性描述符。 3、具体的属性描述符如下： configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中(可以被for..in..遍历)。默认为 false。 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。 get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 4、这时候我们改造一下代码，如下： 12345678910var o = &#123;&#125;;Object.defineProperty(o, "a", &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;); //&#123;a: 37&#125;console.log(o.a); // 打印 37o.a = 25;console.log(o.a); // 打印 25 这样的话我们就可以正确地为属性赋值了。 5、需要注意的是，对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一；不能同时是两者。参考如下： 如果两者同时使用，会报如下错误： 12345678var o = &#123;&#125;;Object.defineProperty(o, "conflict", &#123; value: 0x9f91102, get: function() &#123; return 0xdeadbeef; &#125; &#125;);//Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 6、在这里，我们需要特别注意 configurable 这个属性描述符，如果它的值为false，那么除了 writable 外，其他特性都不能被修改(包括其自身)，并且 writable 只能从 true 修改为 false，而且数据和存取描述符也不能相互切换。 如果尝试修改，会报如下错误： 12345678910111213141516171819var o = &#123;&#125;;Object.defineProperty(o, "a", &#123; get : function()&#123;return 1;&#125;, configurable : false &#125;);// throws a TypeErrorObject.defineProperty(o, "a", &#123;configurable : true&#125;); // throws a TypeErrorObject.defineProperty(o, "a", &#123;enumerable : true&#125;); // throws a TypeError (set was undefined previously) Object.defineProperty(o, "a", &#123;set : function()&#123;&#125;&#125;); // throws a TypeError (even though the new get does exactly the same thing) Object.defineProperty(o, "a", &#123;get : function()&#123;return 1;&#125;&#125;);// throws a TypeErrorObject.defineProperty(o, "a", &#123;value : 12&#125;);console.log(o.a); // logs 1delete o.a; // Nothing happensconsole.log(o.a); // logs 1 7、最后，我们又要留意一下存取描述符set与get，vuejs的底层就是通过set与get监听数据变动来实现mvvm的双向绑定的，参考如下代码： 12345678910111213141516171819202122232425262728293031function observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125;var obj = &#123;a:'10',b:'20'&#125;observe(obj)obj.a // '10'obj.a = '100' // 哈哈哈，监听到值变化了 10 --&gt; 100// '100' 参考文档MDN web docs Snandy 的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让input里面placeholder水平居中]]></title>
    <url>%2F2017%2F10%2F10%2F%E8%AE%A9input%E9%87%8C%E9%9D%A2placeholder%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[有时候我们想让input里面placeholder水平居中，这个时候我们可以这样做 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; input&#123; width: 200px; height: 30px; color:#333; &#125; input::-ms-input-placeholder&#123;text-align: center;&#125; input::-webkit-input-placeholder&#123;text-align: center;&#125; &lt;/style&gt; &lt;body&gt; &lt;input placeholder="用户名" /&gt; &lt;/body&gt;&lt;/html&gt; 参考文章：知乎问题“如何让input里面placeholder水平居中？”]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器原生API实现Base64编码转换]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9FAPI%E5%AE%9E%E7%8E%B0Base64%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近发现浏览器的两个原生API atob()、btoa() 可以实现编码转换 1、代码如下：12btoa("hello world"); // "aGVsbG8gd29ybGQ="atob("aGVsbG8gd29ybGQ="); // "hello world" 2017-11-01添加 如果转换的字符串中有中文的话，编码转换会失败，这时候就需要window.encodeURIComponent和window.decodeURIComponent的帮助了： 1234567var str = "China，中国";window.btoa(window.encodeURIComponent(str))//"Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ="window.decodeURIComponent(window.atob('Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ='))//"China，中国" 2、再科（bai）普(du) 一下base64的编码原理： 转码过程例子：38=46内存1个字节占8位转前： s 1 3先转成ascii：对应 115 49 512进制： 01110011 00110001 001100116个一组（4组） 011100110011000100110011然后才有后面的 011100 110011 000100 110011然后计算机是8位8位的存数 6不够，自动就补两个高位0了所有有了 高位补0科学计算器输入 00011100 00110011 00000100 00110011得到 28 51 4 51查对下照表 c z E z 3、如果好奇atob()与btoa()的具体实现，可参考如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220/* * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $ * * Licensed under the BSD 3-Clause License. * http://opensource.org/licenses/BSD-3-Clause * * References: * http://en.wikipedia.org/wiki/Base64 */(function(global) &#123; 'use strict'; // existing version for noConflict() var _Base64 = global.Base64; var version = "2.3.2"; // if node.js, we use Buffer var buffer; if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; try &#123; buffer = require('buffer').Buffer; &#125; catch (err) &#123;&#125; &#125; // constants var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; var b64tab = function(bin) &#123; var t = &#123;&#125;; for (var i = 0, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i; return t; &#125;(b64chars); var fromCharCode = String.fromCharCode; // encoder stuff var cb_utob = function(c) &#123; if (c.length &lt; 2) &#123; var cc = c.charCodeAt(0); return cc &lt; 0x80 ? c : cc &lt; 0x800 ? (fromCharCode(0xc0 | (cc &gt;&gt;&gt; 6)) + fromCharCode(0x80 | (cc &amp; 0x3f))) : (fromCharCode(0xe0 | ((cc &gt;&gt;&gt; 12) &amp; 0x0f)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 6) &amp; 0x3f)) + fromCharCode(0x80 | ( cc &amp; 0x3f))); &#125; else &#123; var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00); return (fromCharCode(0xf0 | ((cc &gt;&gt;&gt; 18) &amp; 0x07)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 12) &amp; 0x3f)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 6) &amp; 0x3f)) + fromCharCode(0x80 | ( cc &amp; 0x3f))); &#125; &#125;; var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g; var utob = function(u) &#123; return u.replace(re_utob, cb_utob); &#125;; var cb_encode = function(ccc) &#123; var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) &lt;&lt; 16 | ((ccc.length &gt; 1 ? ccc.charCodeAt(1) : 0) &lt;&lt; 8) | ((ccc.length &gt; 2 ? ccc.charCodeAt(2) : 0)), chars = [ b64chars.charAt( ord &gt;&gt;&gt; 18), b64chars.charAt((ord &gt;&gt;&gt; 12) &amp; 63), padlen &gt;= 2 ? '=' : b64chars.charAt((ord &gt;&gt;&gt; 6) &amp; 63), padlen &gt;= 1 ? '=' : b64chars.charAt(ord &amp; 63) ]; return chars.join(''); &#125;; var btoa = global.btoa ? function(b) &#123; return global.btoa(b); &#125; : function(b) &#123; return b.replace(/[\s\S]&#123;1,3&#125;/g, cb_encode); &#125;; var _encode = buffer ? buffer.from &amp;&amp; buffer.from !== Uint8Array.from ? function (u) &#123; return (u.constructor === buffer.constructor ? u : buffer.from(u)) .toString('base64') &#125; : function (u) &#123; return (u.constructor === buffer.constructor ? u : new buffer(u)) .toString('base64') &#125; : function (u) &#123; return btoa(utob(u)) &#125; ; var encode = function(u, urisafe) &#123; return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function(m0) &#123; return m0 == '+' ? '-' : '_'; &#125;).replace(/=/g, ''); &#125;; var encodeURI = function(u) &#123; return encode(u, true) &#125;; // decoder stuff var re_btou = new RegExp([ '[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]&#123;2&#125;', '[\xF0-\xF7][\x80-\xBF]&#123;3&#125;' ].join('|'), 'g'); var cb_btou = function(cccc) &#123; switch(cccc.length) &#123; case 4: var cp = ((0x07 &amp; cccc.charCodeAt(0)) &lt;&lt; 18) | ((0x3f &amp; cccc.charCodeAt(1)) &lt;&lt; 12) | ((0x3f &amp; cccc.charCodeAt(2)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(3)), offset = cp - 0x10000; return (fromCharCode((offset &gt;&gt;&gt; 10) + 0xD800) + fromCharCode((offset &amp; 0x3FF) + 0xDC00)); case 3: return fromCharCode( ((0x0f &amp; cccc.charCodeAt(0)) &lt;&lt; 12) | ((0x3f &amp; cccc.charCodeAt(1)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(2)) ); default: return fromCharCode( ((0x1f &amp; cccc.charCodeAt(0)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(1)) ); &#125; &#125;; var btou = function(b) &#123; return b.replace(re_btou, cb_btou); &#125;; var cb_decode = function(cccc) &#123; var len = cccc.length, padlen = len % 4, n = (len &gt; 0 ? b64tab[cccc.charAt(0)] &lt;&lt; 18 : 0) | (len &gt; 1 ? b64tab[cccc.charAt(1)] &lt;&lt; 12 : 0) | (len &gt; 2 ? b64tab[cccc.charAt(2)] &lt;&lt; 6 : 0) | (len &gt; 3 ? b64tab[cccc.charAt(3)] : 0), chars = [ fromCharCode( n &gt;&gt;&gt; 16), fromCharCode((n &gt;&gt;&gt; 8) &amp; 0xff), fromCharCode( n &amp; 0xff) ]; chars.length -= [0, 0, 2, 1][padlen]; return chars.join(''); &#125;; var atob = global.atob ? function(a) &#123; return global.atob(a); &#125; : function(a)&#123; return a.replace(/[\s\S]&#123;1,4&#125;/g, cb_decode); &#125;; var _decode = buffer ? buffer.from &amp;&amp; buffer.from !== Uint8Array.from ? function(a) &#123; return (a.constructor === buffer.constructor ? a : buffer.from(a, 'base64')).toString(); &#125; : function(a) &#123; return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString(); &#125; : function(a) &#123; return btou(atob(a)) &#125;; var decode = function(a)&#123; return _decode( String(a).replace(/[-_]/g, function(m0) &#123; return m0 == '-' ? '+' : '/' &#125;) .replace(/[^A-Za-z0-9\+\/]/g, '') ); &#125;; var noConflict = function() &#123; var Base64 = global.Base64; global.Base64 = _Base64; return Base64; &#125;; // export Base64 global.Base64 = &#123; VERSION: version, atob: atob, btoa: btoa, fromBase64: decode, toBase64: encode, utob: utob, encode: encode, encodeURI: encodeURI, btou: btou, decode: decode, noConflict: noConflict &#125;; // if ES5 is available, make Base64.extendString() available if (typeof Object.defineProperty === 'function') &#123; var noEnum = function(v)&#123; return &#123;value:v,enumerable:false,writable:true,configurable:true&#125;; &#125;; global.Base64.extendString = function () &#123; Object.defineProperty( String.prototype, 'fromBase64', noEnum(function () &#123; return decode(this) &#125;)); Object.defineProperty( String.prototype, 'toBase64', noEnum(function (urisafe) &#123; return encode(this, urisafe) &#125;)); Object.defineProperty( String.prototype, 'toBase64URI', noEnum(function () &#123; return encode(this, true) &#125;)); &#125;; &#125; // // export Base64 to the namespace // if (global['Meteor']) &#123; // Meteor.js Base64 = global.Base64; &#125; // module.exports and AMD are mutually exclusive. // module.exports has precedence. if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports.Base64 = global.Base64; &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], function()&#123; return global.Base64 &#125;); &#125; // that's it!&#125;)( typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this); 以上代码是GitHub上js-base64的开源代码，感兴趣的同学可以戳这里]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS格式化日期函数]]></title>
    <url>%2F2017%2F10%2F01%2FJS%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在JAVA中用SimpleDateFormat对象可以格式化日期，JS中没有原生方法，这个时候可以考虑自己写一个 代码如下： 12345678910111213141516171819202122/** 对Date的扩展，将 Date 转化为指定格式的String 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 例子： * (new Date()).parse("yyyy-MM-dd hh:mm:ss.S") ==&gt; 2006-07-02 08:09:04.423 * (new Date()).parse("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 */Date.prototype.parse=function(fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125; 另一种写法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 例子： * (new Date()).pattern("yyyy-MM-dd hh:mm:ss.S")==&gt; 2006-07-02 08:09:04.423 * (new Date()).pattern("yyyy-MM-dd E HH:mm:ss") ==&gt; 2009-03-10 二 20:09:04 * (new Date()).pattern("yyyy-MM-dd EE hh:mm:ss") ==&gt; 2009-03-10 周二 08:09:04 * (new Date()).pattern("yyyy-MM-dd EEE hh:mm:ss") ==&gt; 2009-03-10 星期二 08:09:04 * (new Date()).pattern("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 */ Date.prototype.pattern=function(fmt) &#123; var o = &#123; "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "h+" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 "H+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒 &#125;; var week = &#123; "0" : "/u65e5", "1" : "/u4e00", "2" : "/u4e8c", "3" : "/u4e09", "4" : "/u56db", "5" : "/u4e94", "6" : "/u516d" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? "/u661f/u671f" : "/u5468") : "")+week[this.getDay()+""]); &#125; for(var k in o)&#123; if(new RegExp("("+ k +")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length))); &#125; &#125; return fmt; &#125; 参考博客‘一路前行’的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC上如何自由切换python2和python3并正确使用pip]]></title>
    <url>%2F2017%2F10%2F01%2FMAC%E4%B8%8A%E5%A6%82%E4%BD%95%E8%87%AA%E7%94%B1%E5%88%87%E6%8D%A2python2%E5%92%8Cpython3%E5%B9%B6%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8pip%2F</url>
    <content type="text"><![CDATA[MAC上默认的Python版本是2的版本，这时候怎么才能用上3的语法呢？用pip安装依赖的时候怎么才能根据不同的版本安装不同的依赖库呢？如果你对此也有疑问，或许这篇文章能帮助你 一、下载Python3最新版本如果还没有下载python3最新的版本，可以进入python的官网进行下载。 二、正确的使用Python3进行编译一开始以为用上Python3需要一些特殊的操作，后来发现自己还是 too young too simple sometimes native，事实上，不需要什么特殊的操作，要用Python2就用Python命令编译，就像下面这样： python ./demo.py 要用Python3就用Python3命令编译，就像下面这样： python3 ./demo.py 就这么简单。 三、安装pippip是python的包管理工具，类似node.js中的npm,在MAC中，安装pip很简单，输入如下命令即可安装： sudo easy_install pip 四、在python2和python3上正确的使用pip对于 Linux ## sudo pip install sth 或者明确版本 sudo pip2 install sthsudo pip3 install sthsudo python2 -m pip install sthsudo /path/to/python -m pip install sth 对于 Windows NT ##如果仅安装 python2 pip install sth 如果安装有 python3, 则需要明确 pip 版本 py -2 -m pip install sthpy -3 -m pip install sth 这一条参考的是知乎上同时装了Python3和Python2，怎么用pip？下Johnny Wong的回答,如果还有疑问，可以点进去了解详情。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE浏览器跳转报400错误的问题]]></title>
    <url>%2F2017%2F09%2F30%2FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%B3%E8%BD%AC%E6%8A%A5400%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近开发中，遇到一个问题，在Chrome中可以正常跳转的链接在IE中跳转就会报400错误 如果URL的参数中带有中文，那么在IE中，则很有可能会报400错误，这个时候正确的做法是用js自带的encodeURL对URL进行编码，后传到另个一面后再用decodeURL进行解码。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS转换HTML转义符]]></title>
    <url>%2F2017%2F09%2F30%2FJS%E8%BD%AC%E6%8D%A2HTML%E8%BD%AC%E4%B9%89%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前两天在公司写代码，在后台请求的数据放到前台时显示错乱，检查后发现如果文本里有&lt;,后面再紧跟字母的话，html就会显示错误，要解决这个问题，可以对文本里的特殊字符进行转义 一、去掉html标签123function removeHtmlTab(tab) &#123; return tab.replace(/&lt;[^&lt;&gt;]+?&gt;/g,'');//删除所有HTML标签&#125; 二、普通字符转换成转意符123function html2Escape(sHtml) &#123; return sHtml.replace(/[&lt;&gt;&amp;"]/g,function(c)&#123;return &#123;'&lt;':'&amp;lt;','&gt;':'&amp;gt;','&amp;':'&amp;amp;','"':'&amp;quot;'&#125;[c];&#125;);&#125; 三、转意符换成普通字符1234function escape2Html(str) &#123; var arrEntities=&#123;'lt':'&lt;','gt':'&gt;','nbsp':' ','amp':'&amp;','quot':'"'&#125;; return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(all,t)&#123;return arrEntities[t];&#125;);&#125; 三、&nbsp;转成空格1234function nbsp2Space(str) &#123; var arrEntities = &#123;'nbsp' : ' '&#125;; return str.replace(/&amp;(nbsp);/ig, function(all, t)&#123;return arrEntities[t]&#125;)&#125; 四、回车转为br标签123function return2Br(str) &#123; eturn str.replace(/\r?\n/g,"&lt;br /&gt;");&#125; 五、去除开头结尾换行,并将连续3次以上换行转换成2次换行123456function trimBr(str) &#123; str=str.replace(/((\s|&amp;nbsp;)*\r?\n)&#123;3,&#125;/g,"\r\n\r\n");//限制最多2次换行 str=str.replace(/^((\s|&amp;nbsp;)*\r?\n)+/g,'');//清除开头换行 str=str.replace(/((\s|&amp;nbsp;)*\r?\n)+$/g,'');//清除结尾换行 return str;&#125; 六、将多个连续空格合并成一个空格1234function mergeSpace(str) &#123; str=str.replace(/(\s|&amp;nbsp;)+/g,' '); return str;&#125; 参考博客：SJY之家]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js过滤emoji表情符号]]></title>
    <url>%2F2017%2F09%2F30%2Fjs%E8%BF%87%E6%BB%A4emoji%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[有时候，在手机的输入框输入emoji，插入数据库时会报错，这时候有一个解决方案是用js正则把emoji表情给过滤掉 unicode定义的emoji是四个字符，而Mysql的utf8编码最多3个字节，所以数据插不进去。所以数据库会报错： SQLException: Incorrect string value 这时候有三种解决方案： 把emoji直接过滤掉； 将Mysql的编码从utf8转换成utf8mb4; unicode emoji转义为softbank的emoji; 这次只讨论第一种方案, 以下是正则代码,很简短，只有一行：1name = name.replace(/\ud83c[\udf00-\udfff]|\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g, ""); 参考博客：“逸学堂”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取随机字符串]]></title>
    <url>%2F2017%2F09%2F29%2F%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[如何获取一段随机字符串？下面的方法或许能帮到你 123456789101112131415 /** * Get the a random string * @param &#123;integer&#125; len length of the random string * @return &#123;string&#125; */function getStrRandom(len) &#123; //len为字符串长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS字符串截取函数slice(),substring(),substr()的区别]]></title>
    <url>%2F2017%2F09%2F28%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E5%87%BD%E6%95%B0slice-substring-substr%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在JS中,slice()、substring()、substr()都有截取字符串的作用，那他们有哪些用法上的区别呢？如果你也有疑惑，这篇文章或许能够帮助到你。 一、substring()substring()方法返回一个索引和另一个索引之间的字符串，语法如下： str.substring(indexStart, [indexEnd]) 下面有六点需要注意： substring()从提取的字符indexStart可达但不包括 indexEnd 如果indexStart 等于indexEnd，substring()返回一个空字符串。 如果indexEnd省略，则将substring()字符提取到字符串的末尾。 如果任一参数小于0或是NaN，它被视为为0。 如果任何一个参数都大于stringName.length，则被视为是stringName.length。 如果indexStart大于indexEnd，那么效果substring()就好像这两个论点被交换了一样； 例如，str.substring(1, 0) == str.substring(0, 1) 以下是一些示例代码：123456789var str = 'abcdefghij';console.log('(1, 2): ' + str.substring(1, 2)); // '(1, 2): b'console.log('(1, 1): ' + str.substring(1, 1)); // '(1, 1): 'console.log('(-3, 2): ' + str.substring(-3, 2)); // '(-3, 2): ab'console.log('(-3): ' + str.substring(-3)); // '(-3): abcdefghij'console.log('(1): ' + str.substring(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.substring(-20, 2)); // '(-20, 2): ab'console.log('(2, 20): ' + str.substring(2, 20)); // '(2, 20): cdefghij'console.log('(20, 2): ' + str.substring(20, 2)); // '(20, 2): cdefghij' 二、substr()substr()方法返回从指定位置开始的字符串中指定字符数的字符，语法如下： str.substr(start, [length]) 下面有四点需要注意： substr()会从start获取长度为length字符（如果截取到字符串的末尾，则会停止截取）。 如果start是正的并且大于或等于字符串的长度，则substr()返回一个空字符串。 若start为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。 如果length为0或为负数，substr()返回一个空字符串。如果length省略，则将substr()字符提取到字符串的末尾。 以下是一些示例代码：1234567var str = 'abcdefghij';console.log('(1, 2): ' + str.substr(1, 2)); // '(1, 2): bc'console.log('(-3, 2): ' + str.substr(-3, 2)); // '(-3, 2): hi'console.log('(-3): ' + str.substr(-3)); // '(-3): hij'console.log('(1): ' + str.substr(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.substr(-20, 2)); // '(-20, 2): ab'console.log('(20, 2): ' + str.substr(20, 2)); // '(20, 2): ' 需要注意的是，Microsoft的JScript不支持起始索引的负值。如果要使用此功能，可以使用以下兼容性代码来解决此错误： 12345678910111213141516171819// only run when the substr() function is brokenif ('ab'.substr(-1) != 'b') &#123; /** * Get the substring of a string * @param &#123;integer&#125; start where to start the substring * @param &#123;integer&#125; length how many characters to return * @return &#123;string&#125; */ String.prototype.substr = function(substr) &#123; return function(start, length) &#123; // call the original method return substr.call(this, // did we get a negative start, calculate how much it is from the beginning of the string // adjust the start parameter for negative value start &lt; 0 ? this.length + start : start, length) &#125; &#125;(String.prototype.substr);&#125; 三、substring()与substr()的主要区别substring()方法的参数表示起始和结束索引，substr()方法的参数表示起始索引和要包含在生成的字符串中的字符的长度,示例如下： 123var text = 'Mozilla';console.log(text.substring(2,5)); // =&gt; "zil"console.log(text.substr(2,3)); // =&gt; "zil" 四、slice()slice()方法返回一个索引和另一个索引之间的字符串，语法如下： str.slice(beginIndex[, endIndex]) 下面有三点需要注意： 若beginIndex为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。 如果beginIndex大于或等于字符串的长度，则slice()返回一个空字符串。 如果endIndex省略，则将slice()字符提取到字符串的末尾。如果为负，它被视为strLength + endIndex其中strLength是字符串的长度。 以下是一些示例代码：1234567891011var str = 'abcdefghij';console.log('(1, 2): ' + str.slice(1, 2)); // '(1, 2): b'console.log('(-3, 2): ' + str.slice(-3, 2)); // '(-3, 2): 'console.log('(-3, 9): ' + str.slice(-3, 9)); // '(-3, 9): hi'console.log('(-3): ' + str.slice(-3)); // '(-3): hij'console.log('(-3，-1): ' + str.slice(-3，-1)); // '(-3，-1): hi'console.log('(0，-1): ' + str.slice(0，-1)); // '(0，-1): abcdefghi'console.log('(1): ' + str.slice(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.slice(-20, 2)); // '(-20, 2): ab'console.log('(20): ' + str.slice(20)); // '(20): 'console.log('(20, 2): ' + str.slice(20, 2)); // '(20, 2): ' 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何进行对象的深拷贝]]></title>
    <url>%2F2017%2F09%2F21%2FJS%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在JS中，一般的=号传递的都是对象/数组的引用，并没有真正地拷贝一个对象，那如何进行对象的深度拷贝呢？如果你对此也有疑问，这篇文章或许能够帮助到你。 一、对象引用、浅层拷贝与深层拷贝的区别js的对象引用传递理解起来很简单，参考如下代码：12345var a = &#123;name:'wanger'&#125;var b = a ;a===b // trueb.name = 'zhangsan'a.name //'zhangan' 上述代码中，使用了=进行赋值，于是b指向了a所指向的栈的对象，也就是a与b指向了同一个栈对象，所以在对b.name赋值时，a.name也发生了变化。为了避免上面的情况，可以对对象进行拷贝，代码如下： 12345var a = &#123;name:'wanger'&#125;var b = Object.assign(&#123;&#125;, a)a===b // falseb.name = 'zhangsan'a.name //'wanger' 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆，这时候a与b指向的是不同的栈对象，所以对b.name重新复制也不会影响到a.name。但是如果a.name是一个对象的引用，而不是一个字符串，那么上面的代码也会遇到一些问题，参考如下代码： 12345var a = &#123;name:&#123;firstName:'wang',lastName:'er'&#125;&#125;var b = Object.assign(&#123;&#125;, a)a===b // falseb.name.firstName = 'zhang'a.name.firstName //'zhang' b.name.firstName又影响到了a.name.firstName，这是因为Object.assign()方法只是浅层拷贝，a.name是一个栈对象的引用，赋值给b时，b.name也同样是这个栈对象的引用，很多时候，我们不想让这种事情发生，所以我们就需要用到对象的深拷贝。 二、使用JSON.parse（）与JSON.stringify（）对对象进行拷贝通常情况下，我们可以使用JSON.parse（）与 JSON.stringify（）实现对象的深克隆，如下： 123var clone = function (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; 这种方法只适用于纯数据json对象的深度克隆，因为有些时候，这种方法也有缺陷，参考如下代码： 12345var clone = function (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var a = &#123;a:function()&#123;console.log('hello world')&#125;,b:&#123;c:1&#125;,c:[1,2,3],d:"wanger",e:new Date(),f:null,g:undefined&#125;var b = clone(a) 打印如下：我们发现，上述的方法会忽略值为function以及undefied的字段，而且对date类型的支持也不太友好。 更要紧的是，上述方法只能克隆原始对象自身的值，不能克隆它继承的值，参考如下代码： 1234567function Person (name) &#123; this.name = name&#125;var wanger = new Person('王二')var newwanger = clone(wanger)wanger.constructor === Person // truenewwanger.constructor === Object // true 打印如下： 我们发现，克隆的对象的构造函数已经变成了Object,而原来的对象的构造是Person。 三、目前没有发现bug的对象深拷贝方法王二在网上参考了不少文章，方法都不尽完美，于是在前人基础上改造了一下，方法如下，目前没有发现有什么bug： 12345678910111213var clone = function (obj) &#123; if(obj === null) return null if(typeof obj !== 'object') return obj; if(obj.constructor===Date) return new Date(obj); var newObj = new obj.constructor (); //保持继承链 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //不遍历其原型链上的属性 var val = obj[key]; newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合 &#125; &#125; return newObj; &#125;; 这里有三点需要注意：1、用new obj.constructor ()构造函数新建一个空的对象，而不是使用{}或者[],这样可以保持原形链的继承；2、用obj.hasOwnProperty(key)来判断属性是否来自原型链上，因为for..in..也会遍历其原型链上的可枚举属性。3、上面的函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 arguments.callee。4、以上方法并没有对 function 做拷贝。 2017-10-03添加，之前没有考虑正则对象的问题，这里做一下修改： 1234567891011121314var clone = function (obj) &#123; if(obj === null) return null if(typeof obj !== 'object') return obj; if(obj.constructor===Date) return new Date(obj); if(obj.constructor === RegExp) return new RegExp(obj); var newObj = new obj.constructor (); //保持继承链 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //不遍历其原型链上的属性 var val = obj[key]; newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合 &#125; &#125; return newObj; &#125;; 2018-08-24添加，还可以使用 MessageChannel实现深克隆： 如果所需拷贝的对象含有内置类型并且不包含函数，可以使用 MessageChannel，参考如下代码： 12345678910111213function structuralClone(obj) &#123; return new Promise(resolve =&gt; &#123; const &#123;port1, port2&#125; = new MessageChannel(); port2.onmessage = ev =&gt; resolve(ev.data); port1.postMessage(obj); &#125;);&#125;var obj = &#123;a: 1, b: &#123; c: b&#125;&#125;// 注意该方法是异步的// 可以处理 undefined 和循环引用对象var clone = await structuralClone(obj); 此方法参考自InterviewMap;关于 MessageChannel 的用法，可以参考这篇文章]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中apply、call、bind的用法]]></title>
    <url>%2F2017%2F09%2F20%2FJS%E4%B8%ADapply%E3%80%81call%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[apply()和call()都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）,bind()会创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 一、了解apply()的作用1、先来一个实例123456789var wanger = &#123; name: '王二', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;wanger.age(); // 17年调用是22,18年调用就变成23了 上面的对象定义了一个wanger对象，里面有个age方法，当调用age方法时，就可以得到王二的年龄；这时候，下面又来了一个张三:1234var zhangsan = &#123; name: '张三', birth: 1992,&#125;; 他没有age方法，但他也想知道自己的年龄，那该怎么办呢？或许我们可以借用王二的age方法来帮助张三知道自己的年龄，这时候，apply()就能帮到我们：1wanger.age.apply(zhangsan); //17年调用是25,18年调用就变成26了 上面apply()中的zhangsan成功地调用到了wanger的age方法。 在MDN中，是这么解释apply方法的： 在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 二、apply()与call()的区别 call()方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组 王二和张三要获得期末考试语文和数学加起来的成绩，如下代码所示：1234567891011var wanger = &#123; name: '王二', score: function (x,y) &#123; return x+y ; &#125;&#125;;var zhangsan = &#123; name: '张三',&#125;;wanger.score.apply(zhangsan,[100,98]); //198wanger.score.call(zhangsan,100,98); //198 以上两种方法都能获得张三的成绩； 两个方法用途差不多，为什么还要分成两个方法呢？还有那个谁，对，apply,还要放个数组进去，累不累啊？ 但是设计者这样设计是有用途的，参考如下代码： 1234567891011121314var wanger = &#123; name: '王二', score: function () &#123; return [...arguments].reduce((x,y)=&gt;x+y) ; //获得传入成绩的总和 &#125;&#125;;var zhangsan = &#123; name: '张三',&#125;;wanger.score.apply(zhangsan,[100,98,95]); //293wanger.score.call(zhangsan,100,98,95); //293wanger.score.apply(zhangsan,[100,98,95,96]); //389wanger.score.call(zhangsan,100,98,95,96); //389 当传入的的参数的值不固定时，call()的灵活性就明显不如apply()了，apply()只要传一个数组就搞定了。 三、bind()是干什么用的在MDN中，是这么解释bind方法的： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 可以参考如下代码：1234567891011121314var wanger = &#123; name: '王二', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;var zhangsan = &#123; name: '张三', birth: 1992,&#125;;var getAge = wanger.age.bind(zhangsan); getAge() ; 这里bind()与call(),apply()有一个重要的区别：bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 四、总结 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 参考文献：MDN web docs廖雪峰的官方网站“chokcoco”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解原型链]]></title>
    <url>%2F2017%2F09%2F18%2F%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在JS中，原型链有时候让人觉得很胡里花哨，又是prototype、__proto__又是各种指向什么的，让人觉得很头疼。如果你也有这种感觉，或许这篇文章可以帮助到你 一、认识原型1、先来一串代码 123456789var Person = function(msg)&#123; this.msg = msg;&#125;var person1 = new Person("wanger")person1.constructor===Person; //truePerson === Person.prototype.constructor; //trueperson1.__proto__ === Person.prototype; //trueperson1.__proto__.constructor === person1.constructor //true 看晕了吧？是不是很胡里花哨？不用担心，其实一张图就能了明白这其中的关系： 蓝色的是构造函数 绿色的是构造函数实例出来的对象 橙色的是构造函数的prototype,也是构造函数实例出来的对象的原型（它其实也是一个对象） 2、这里特别要注意的是prototype与__proto__的区别，prototype是函数才有的属性，而__proto__是每个对象都有的属性。(__proto__不是一个规范属性，只是部分浏览器实现了此属性，对应的标准属性是[[Prototype]])。 二、认识原型链1、我们刚刚了解了原型，那原型链在哪儿呢？不要着急，再上一张图： 通过这张图我们可以了解到,person1的原型链是： person1 —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 2、事实上，函数也是一个对象，所以，Person的原型链是： Person —-&gt; Function.prototype —-&gt; Object.prototype —-&gt; null 由于Function.prototype定义了apply()等方法，因此，Person就可以调用apply()方法。 3、如果把原型链的关系都显示清楚，那会复杂一些，如下图： 这里需要特别注意的是：所有函数的原型都是Function.prototype,包括Function构造函数和Object构造函数（如图中的标红部分） 三、原型链的继承1、假设我们要基于Person扩展出Student，Student的构造如下：12345function Student(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Person构造函数不等于继承了Person，Student创建的对象的原型是： new Student() —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null 示意图如下所示： 必须想办法把原型链修改为： new Student() —-&gt; Student.prototype —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 示意图如下所示： 那我们应该怎么修改呢？仔细观察两张图的差异，我们会发现，如果我们将Student的prototype改成person1对象不就大功告成了？于是有了下面的代码： 1Student.prototype = person1 ; 但是这时候有个问题:1Student.prototype.constructor === Student; //false 原来Student.prototype(即person1)的constructor指向的还是Person，这时候还需要我们再改一下代码：1Student.prototype.constructor = Student; 这样就能把Student的原型链顺利的修改为： new Student() —-&gt; Student.prototype —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 了； 完整的代码显示如下：1234567891011var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;var person1 = new Person("wanger")Student.prototype = person1 ;Student.prototype.constructor = Student; 三、用以上原型链继承带来的问题1、如果在控制台执行一遍上述的代码，我们会发现一些问题，如图所示： Student.prototype上含有之前person1带有的属性，那么，这样的继承的方法就显得不那么完美了 2、这个时候，我们可以借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Person.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Person.prototype:F.prototype = Person.prototype;// 把Student的原型指向一个新的F对象，F对象的原型正好指向Person.prototype:Student.prototype = new F();// 把Student原型的构造函数修复为Student:Student.prototype.constructor = Student;// 继续在Student原型（就是new F()对象）上定义方法：Student.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建wanger:var wanger = new Student(&#123; name: '王二', grade: 9&#125;);wanger.msg; // '王二'wanger.grade; // 9// 验证原型:wanger.__proto__ === Student.prototype; // truewanger.__proto__.__proto__ === Person.prototype; // true// 验证继承关系:wanger instanceof Student; // truewanger instanceof Person; // true 这其中主要用到了一个空函数F作为过桥函数。为什么道爷会用过桥函数？用过桥函数F(){}主要是为了清空构造的属性。如果有些原Person的构造用不到，那么过桥函数将是一个好的解决方案 这样写的话，Student.prototype上就没有任何自带的私有属性，这是理想的继承的方法 3、如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 123456function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 封装后，写起来就像这样：123456789var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;inherits(Student,Person) ; 这样再一封装的话，代码就很完美了。 事实上，我们也可以在inherits中使用Object.create()来进行操作，代码如下：1234function inherits(Child, Parent) &#123; Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;&#125; 如果有兴趣了解Object.create()的其他用法，可以参考我的这篇博客JS中Object.create的使用方法; 四、ES6的新关键字class在ES6中，新的关键字class，extends被正式被引入，它采用的类似java的继承写法，写起来就像这样：123456789class Student extends Person &#123; constructor(name, grade) &#123; super(msg); // 记得用super调用父类的构造方法! this.grade = grade || 1; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 这样写的话会更通俗易懂，继承也相当方便。读者可以进入廖雪峰的官方网站详细了解class的用法 参考文献：廖雪峰的官方网站]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vue-cli 中用 proxyTable 解决开发环境的跨域问题]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%9C%A8-vue-cli-%E4%B8%AD%E7%94%A8-proxyTable-%E8%A7%A3%E5%86%B3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端开发工程中难免会遇到跨域问题，如果你用的是vue，不要担心，官方手脚架早已帮你准备好了解决方案 如果读者还不太了解 vue-cil , 或许vue-cil文档可以帮助到你 , 事实上,文档中就有用 proxyTable 进行代理请求的相关介绍 关键代码在 config/index.js 写下以下关键代码 ： 12345678910111213141516// config/index.jsmodule.exports = &#123; // ... dev: &#123; proxyTable: &#123; // proxy all requests starting with /api to jsonplaceholder '/api': &#123; target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125; 上面的示例将代理请求 /api/posts/test 到 http://jsonplaceholder.typicode.com/posts/test 实际开发中的配置王二在开发中进行的如下的配置： 123456789proxyTable: &#123; "/middleware": &#123; target: "http://192.168.2.57:80", pathRewrite: &#123; '^/middleware': '/patient/1070/middleware' &#125;, changeOrigin: true, &#125;&#125;, 这样就会将代理请求 /middleware/balabala 到 http://192.168.2.57:80/patient/1070/middleware/balabala 需要注意的是，这这种代理请求只适用于开发环境，其背后的设置来自于其使用的插件http-proxy-middleware，有兴趣可以了解了解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS验证身份证的合法性]]></title>
    <url>%2F2017%2F09%2F12%2Fjs%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%2F</url>
    <content type="text"><![CDATA[最近公司业务需求需要验证身份证的合法性，以下分享一个可以判断身份合法性的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function IdentityCodeValid(code) &#123; function cap (str)&#123; //如果身份证验证中有x,则变为X再做判断； var temp = str.split(""); temp.forEach(function(i,index)&#123;if(i==='x')&#123;temp[index]="X"&#125;&#125;);return temp.join(""); &#125; var code = cap(code); var copycode = code ; var city=&#123;11:"北京",12:"天津",13:"河北",14:"山西",15:"内蒙古",21:"辽宁",22:"吉林",23:"黑龙江 ",31:"上海",32:"江苏",33:"浙江",34:"安徽",35:"福建",36:"江西",37:"山东",41:"河南",42:"湖北 ",43:"湖南",44:"广东",45:"广西",46:"海南",50:"重庆",51:"四川",52:"贵州",53:"云南",54:"西藏 ",61:"陕西",62:"甘肃",63:"青海",64:"宁夏",65:"新疆",71:"台湾",81:"香港",82:"澳门",91:"国外 "&#125;; var tip = ""; var pass= true; if(!code || !/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/i.test(code))&#123; tip = "身份证号格式错误"; pass = false; &#125; else if(!city[code.substr(0,2)])&#123; tip = "地址编码错误"; pass = false; &#125; else&#123; //18位身份证需要验证最后一位校验位 if(code.length == 18)&#123; code = code.split(''); //∑(ai×Wi)(mod 11) //加权因子 var factor = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ]; //校验位 var parity = [ 1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2 ]; var sum = 0; var ai = 0; var wi = 0; for (var i = 0; i &lt; 17; i++) &#123; ai = code[i]; wi = factor[i]; sum += ai * wi; &#125; var last = parity[sum % 11]; if(parity[sum % 11] != code[17])&#123; tip = "校验位错误"; pass =false; &#125; &#125; &#125; //判断出生日期是否合法 function check(date)&#123; //date 传 例如：2013-01-01、2013/01/01、2013/01/32、2013/02/29 return (new Date(date).getDate()==date.substring(date.length-2)); &#125; function getDate(code)&#123; //得到类似2013-01-01、2013/01/01、2013/01/32、2013/02/29的日期格式 var date = '' ; if(code.length===18)&#123; date = code.substring(6,14) &#125;else if(code.length===15)&#123; date = '19'+code.substring(6,12) &#125;else&#123; return ''; &#125; date = date.substr(0,4)+'-'+date.substr(4,2)+'-'+date.substr(6,2); return date; &#125; if(!check(getDate(copycode)))&#123; pass = false ; tip = "日期格式不正确" &#125;// if(!pass) alert(tip); return pass;&#125; 参考文献“懒惰的肥兔”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的一般原理]]></title>
    <url>%2F2017%2F08%2F14%2Fjsonp%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器中，由于有 同源策略 的存在，ajax跨域请求数据往往失败，这时候JSONP或许会帮到我们 由于同源策略，一般来说位于server1.example.com的网页无法与不是 server1.example.com的服务器沟通,这时候Jsonp可以帮助我们进行跨域的数据交互,另一个解决这个问题的新方法是CORS，咱们今天主要聊聊Jsonp。 一、JSONP是怎么产生的1、由于同源策略的存在，Ajax直接请求数据存在跨域无权限访问的问题。2、但我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 二、JSONP的客户端具体实现不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现： 1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。远程服务器remoteserver.com根目录下有个remote.js文件代码如下：1alert('我是远程文件'); 本地服务器localserver.com下有个jsonp.html页面代码如下：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。远程服务器remoteserver.com根目录下remote.js文件代码如下：1localHandler(&#123;"result":"我是远程js带来的数据"&#125;); 本地服务器localserver.com下jsonp.html页面代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; var localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;; &lt;/script&gt; &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。看jsonp.html页面的代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：12345flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这里没有写flightHandler这个函数，但是也运行成功了，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时自动帮你生成回调函数并把数据取出来供success属性方法来调用。 三、其他注意点1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 文章转载自“随它去吧”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将特殊英文字符转为中文字符]]></title>
    <url>%2F2017%2F08%2F14%2F%E5%B0%86%E7%89%B9%E6%AE%8A%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B8%BA%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[有时候将前台的数据传到后台，再从后台读取时，由于有特殊英文字符，会出现json转为对象出错的情况，这时候，一种解决方案就是在传到后台之前，将特殊的英文字符转为中文字符 以下是一个英文字符转为中文字符的简单方法 1234function replaceSpecialJson(str)&#123; var res = str.replace(/\"/g,"“").replace(/\[/g,"【").replace(/\]/g,"】").replace(/\&#123;/g,"｛").replace(/\&#125;/g,"｝") ; return res ;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解事件冒泡]]></title>
    <url>%2F2017%2F08%2F14%2F%E4%BA%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[事件冒泡是前端er经常会遇到的问题，那在这里我们来用简短的代码来了解一下到底什么是事件冒泡 在这里我们主要讨论 event.stopPropagation() 与 event.preventDefault() 的区别，先来一段可执行的代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;div onclick="alert('我是最外层-1');"&gt; &lt;div onclick="alert('我是中间层-1');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-1');" id="test1"&gt;点击我-1&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div onclick="alert('我是最外层-2');"&gt; &lt;div onclick="alert('我是中间层-2');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-2');" id="test2"&gt;点击我-2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div onclick="alert('我是最外层-3');"&gt; &lt;div onclick="alert('我是中间层-3');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-3');" id="test3"&gt;点击我-3&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;script&gt; $("#test1").click(function(event) &#123; event.stopPropagation(); &#125;); $("#test2").click(function(event) &#123; event.preventDefault(); &#125;); $("#test3").click(function(event) &#123; return false ; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; event.stopPropagation();事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转） event.preventDefault();如果把它放在头部A标签的click事件中，点击“点击我”。会发现它依次弹出：我是最里层—-我是中间层—-我是最外层，但最后却没有跳转到百度它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） return false; (1)、在 jQuery 中，return false； 会同时阻止事件冒泡和默认行为（比如刚才它就没有执行超链接的跳转） (2)、在 on + 监听事件 中，return false；会阻止默认行为，不会停止冒泡； (3)、在 addEventListener 中， 两者都不会阻止； 对于return false;,可以参考如下代码： 1234567891011121314151617181920212223&lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt;&lt;div id='div' onclick='alert("div");'&gt; &lt;ul onclick='alert("ul");'&gt; &lt;li id='ul-a' onclick='alert("li");'&gt; &lt;a href="http://wangyulue.com/" id="testB"&gt;caibaojian.com&lt;/a&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt;// (1)、都不会触发// $("#testB").on("click",function()&#123;// return false;// &#125;)// (2)、都会触发// var a = document.getElementById("testB");// a.addEventListener('click', function()&#123;// return false;// &#125;);// (3)、会阻止默认行为，不会停止冒泡document.getElementById("testB").onclick = function () &#123; return false;&#125;;&lt;/script&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过FileReader将图片转为Base64编码]]></title>
    <url>%2F2017%2F08%2F14%2F%E9%80%9A%E8%BF%87FileReader%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BABase64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如果我们想将图片转为base64编码，可以通过H5的FileReader接口来达成目标 封装好的方法 1234567891011121314151617/*** @param &#123;string&#125; dom input[name='file']的dom对象* @param &#123;function&#125; fn 回调函数*/function get_base64(dom,fn) &#123; var file = dom.files[0]; if(!file) return ; if(!window.FileReader)&#123; console.log("当前浏览器不支持FileReader！"); return; &#125; r = new FileReader(); r.onload = function()&#123; if(fn) fn(r) ; &#125;; r.readAsDataURL(file);&#125; 再来一段可执行的html代码，大家可以动手试试哈 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input accept="image/*" id="upload_file" type="file"&gt; &lt;textarea id="base64_output" style="min-width:800px;min-height: 500px;"&gt;&lt;/textarea&gt; &lt;script type="text/javascript"&gt; function $_(id) &#123; return document.getElementById(id); &#125; $_("upload_file").onchange = function () &#123; var dom = $_('upload_file'); get_base64(dom,function(r)&#123; $_('base64_output').value = r.result; &#125;); &#125;; function get_base64(dom,fn) &#123; var file = dom.files[0]; if(!file) return ; if(!window.FileReader)&#123; console.log("当前浏览器不支持FileReader！"); return; &#125; r = new FileReader(); r.onload = function()&#123; if(fn) fn(r) ; &#125;; r.readAsDataURL(file); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高亮文本里的关键字]]></title>
    <url>%2F2017%2F08%2F14%2F%E9%AB%98%E4%BA%AE%E6%96%87%E6%9C%AC%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[如何高亮html代码里的关键字？下面的方法或许能帮到你 封装好的方法 12345678910111213141516171819202122/*** @param &#123;string&#125; data 要搜索的文本* @param &#123;string&#125; key 要高亮的关键词* @param &#123;string&#125; bgColor 背景颜色，默认orange*/function keyLight(data, key, bgColor)&#123; var sText = data ; bgColor = bgColor || "orange", sKey = "&lt;span style='background-color: "+bgColor+";'&gt;"+key+"&lt;/span&gt;", num = -1, rStr = new RegExp(key, "g"), rHtml = new RegExp("\&lt;.*?\&gt;","ig"), //匹配html元素 aHtml = sText.match(rHtml); //存放html元素的数组 sText = sText.replace(rHtml, '&#123;~&#125;'); //替换html标签 sText = sText.replace(rStr,sKey); //替换key sText = sText.replace(/&#123;~&#125;/g,function()&#123; //恢复html标签 num++; return aHtml[num]; &#125;); return sText;&#125; 再来一段可执行的html代码，大家可以动手试试哈 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;div&gt;测试一&lt;/div&gt; &lt;div&gt;测试二&lt;/div&gt; &lt;div&gt;测试三&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function keyLight(data, key, bgColor)&#123; var sText = data ; bgColor = bgColor || "orange", sKey = "&lt;span style='background-color: "+bgColor+";'&gt;"+key+"&lt;/span&gt;", num = -1, rStr = new RegExp(key, "g"), rHtml = new RegExp("\&lt;.*?\&gt;","ig"), //匹配html元素 aHtml = sText.match(rHtml); //存放html元素的数组 sText = sText.replace(rHtml, '&#123;~&#125;'); //替换html标签 sText = sText.replace(rStr,sKey); //替换key sText = sText.replace(/&#123;~&#125;/g,function()&#123; //恢复html标签 num++; return aHtml[num]; &#125;); return sText; &#125; var html = document.getElementById("test").innerHTML ; document.getElementById("test").innerHTML = keyLight(html,'试') ; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解ES6中的Promise]]></title>
    <url>%2F2017%2F08%2F10%2F%E7%90%86%E8%A7%A3ES6%E4%B8%AD%E7%9A%84Promise%2F</url>
    <content type="text"><![CDATA[在ES6中，Promise被列为正式规范，Promise可以规范化回调，避免回调地狱 一、Promise的作用在ajax请求数据的过程中，我们可以异步拿到我们想要的数据，然后在回调中做相应的数据处理。这样做看上去并没有什么麻烦，但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就需要在回调函数中再写一个异步请求，然后在这个异步函数的回调函数里在写相应的数据处理。要是连续嵌套个三四层，往往就很恶心了。写起来就像下面这样：12345678910111213141516171819202122232425$.ajax(&#123; type:'get', url:'url_1', data: 'data' success : function(res)&#123; //相应的数据处理 var data = res.data $.ajax(&#123; type:'get', url:'url_2', data: data success : function(res)&#123; //相应的数据处理 $.ajax(&#123; type:'get', url:'url_3', data: data success : function(res)&#123; //相应的数据处理 &#125; &#125;) &#125; &#125;) &#125;&#125;) 在这种情况下Promise就能发挥它的威力了； 二、来一个实例先不谈语法，下面先来一个实例，建立感性的认识 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; function a(data)&#123; return new Promise(function(resolve,reject)&#123; console.log("我是从上一个回调函数里传过来的数据",data) ; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'http://api.money.126.net/data/feed/0000001,1399001', //jsonp跨域调用上证与深证的股票指数 data:&#123; &#125;, success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; console.log("Error:") ; console.log(res) ; reject(res) ; &#125; &#125;) &#125;); &#125; function b(data)&#123; return new Promise(function(resolve,reject)&#123; console.log("我是从上一个回调函数里传过来的数据",data) ; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'https://api.douban.com/v2/movie/top250', //跨域调用豆top250的电影 success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; console.log("Error:") ; console.log(res) ; reject(res) &#125; &#125;) &#125;); &#125; a().then(b).then(a).then(b).catch(function(a)&#123;console.log("final Error:",a)&#125;) ; &lt;/script&gt;&lt;/html&gt; 打印结果如下所示： 可以发现，Promise 通过简单的链式调用就能得到之前多层回调才能达成的效果;而且从代码的结构来看，有效地减小了各个请求之间的耦合; 三、深入Promise别的不谈，先打印一下 Promise , console.dir(Promise) , 看看它究竟是哪号人物： 原来 Promise 本身是一个构造函数，自己身上有 all、 reject、 resolve 这几个的方法，在其 prototype 上有 then 、 catch 这两个方法。那么用Promise new出来的对象也会有 then 、 catch 这两个方法。 四、注意上面实例中的resolve与reject1、我们发现，在 new Promise(function(resolve,reject){}) 里传了两个方法 resolve 、 reject 作为参数，这两个方法通常会在函数的回调里被用到。一旦执行到resolve() 或者 reject() ，那么这个函数会停止执行，然后触发后面的 then() 或者 catch() 方法。准确一点来说，执行到resolve() 会触发 then() 方法，执行到 reject() 会触发 catch() 方法。 2、resolve 和 reject 方法里可以传入参数 ，就像 resolve(data) 和 reject(data) 。 如果这样做 ，那么在后面的 then() 或者 catch() 里传入一个带参数的函数 ， 就像 then(function(data){}) 或者 catch(function(data){}) ， 就能得到 data 的数据 。 3、说的再专业一些，Promise 对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 这三种状态不受外界影响，而且状态只能从 pending 改变为 resolved 或者rejected ，并且不可逆。在 Promise 对象的构造函数中，resolve 和 reject 就是用来处理Promise的状态变化。一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 或者 catch 方法里面，而不应该直接写在 resolve() 或 reject() 的后面 (事实的情况是，resolve() 或 reject() 的后面的代码也不会执行)。 五、new Promise() 里的函数是立刻执行的需要注意的的是，new Promise() 里的函数是立刻执行的 ，也就是说 ，当你执行下面这段代码时，就已经开始执行异步请求了： 123456789101112131415161718&lt;script&gt;new Promise(function(resolve,reject)&#123; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'http://api.money.126.net/data/feed/0000001,1399001', data:&#123; &#125;, success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; reject(res) ; &#125; &#125;)&#125;);&lt;/script&gt; 这也是为什么，在上面第二段的实例中，需要用 a() 和 b() 函数把 new Promise() 给包起来 六、then() 函数的返回值一定是 Promise 对象还需要注意的的是，then() 函数的返回值一定是 Promise 对象，哪怕手动 return 一个值也无济于事，如下面的代码，照样能运行成功：1a().then(function ()&#123;console.log("hello");return 1&#125;).then(b) ; 这也解释了为什么我们可以链式调用 then() 函数。 七、Promise.all()与Promise.race()的用法想要从两个不同的 ajax 请求里分别获得信息，这两个任务是可以并行执行的，就可以用 Promise.all() 实现： 123456789101112131415161718&lt;script&gt;var p1 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;var p2 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;// 同时执行p1和p2，并在它们都完成后执行thenvar start = function()&#123; Promise.all([p1(), p2()]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2'] &#125;);&#125;&lt;/script&gt; 有些时候，多个异步任务是为了容错。比如，分别发两个不同的 ajax 请求读取用户的个人信息，只需要获得先返回的结果即可，这种情况下，就可以用Promise.race() 实现： 1234567891011121314151617&lt;script&gt;var p1 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;var p2 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;var start = function()&#123; Promise.all([p1(), p2()]).then(function (results) &#123; console.log(results); // 'P1' &#125;);&#125;&lt;/script&gt; 由于 p1 执行较快，Promise 的 then() 将获得结果 &#39;P1&#39; 。 p2 仍在继续执行，但执行结果将被丢弃。 如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。 参考文献：阮一峰ES6入门廖雪峰的官方网站sitepoint“吕大豹”的博客园]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>ES6</tag>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webApp调用百度地图API获取当前位置以及其他的一些操作]]></title>
    <url>%2F2017%2F08%2F09%2FwebApp%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近公司有业务需求，需要获得当前位置与各个医院的距离，在这里我主要调用百度地图的API接口，以下做一个总结 一、先上一个简单的实例1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;HTML5调用百度地图API&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=GG3pK0aFOLuRioYyTFhG75tOD2hBZ0CG"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style="margin:50px 10px;"&gt; &lt;div style="width:600px;height:480px;border:1px solid gray;margin:30px auto" id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; /** * 写了一个map方法用以调出地图 * @param &#123;number&#125; x 经度 * @param &#123;number&#125; y 纬度，这个例子里写的是上海的经纬度 * @param &#123;String&#125; dom 要渲染的dom的id * @param &#123;Object&#125; size 地图的放大级别，范围0-19 */ function map(x,y,dom,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); &#125; map(121.48789949,31.24916171,"container"); &lt;/script&gt;&lt;/html&gt; 其中需要注意的是引用的 script 标签里的 GG3pK0aFOLuRioYyTFhG75tOD2hBZ0CG 这个秘钥是需要自己注册申请的，这里给一个注册的传送门，当然在测试中使用王二的这个秘钥也没有关系 二、并不一定需要经纬度，地名也是OK的将上面代码的第22行换成如下试试： 1map.centerAndZoom("南京",15); //中心点坐标可以是经纬度，也可以是地名 三、有时候我们需要一个标注，如下图所示 这时候可以在插入两行代码： 12var marker = new BMap.Marker(point); // 创建标注map.addOverlay(marker); // 将标注添加到地图中 写完整起来就像这样：12345678function map(x,y,dom,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); var marker = new BMap.Marker(point); map.addOverlay(marker);&#125;map(121.48789949,31.24916171,"container"); 四、有时候我们还需要一个标签，如下图所示 这时候可以插入如下的代码： 12345678910111213141516var label = new BMap.Label("上海浦西", &#123; //新建一个标签，并设置标签文本 offset: new BMap.Size(15, -25) //设置标签的偏移量&#125;);label.setStyle(&#123; //为标签设置样式 width: "80px", color: '#fff', background: '#ff8355', border: '1px solid "#ff8355"', borderRadius: "5px", textAlign: "center", height: "26px", lineHeight: "26px"&#125;);marker.setLabel(label); // 为标注添加一个标签 写成方法就像下面这样：12345678910111213141516171819202122function map(x,y,dom,text,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); var label = new BMap.Label(text, &#123; offset: new BMap.Size(15, -25) &#125;); label.setStyle(&#123; width: "80px", color: '#fff', background: '#ff8355', border: '1px solid "#ff8355"', borderRadius: "5px", textAlign: "center", height: "26px", lineHeight: "26px" &#125;); var marker = new BMap.Marker(point); marker.setLabel(label); map.addOverlay(marker);&#125;map(121.48789949,31.24916171,"container","上海浦西"); 五、获取当前的经纬度获取当前的经纬度直接调用下面这个方法就好了：123456789101112function getCurrentPosition() &#123; var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(r)&#123; //回调函数里有当前经纬度的信息 if(this.getStatus() == BMAP_STATUS_SUCCESS)&#123; console.log(r.point) ; &#125; else &#123; alert('failed:'+this.getStatus()); &#125; &#125;)&#125;getCurrentPosition() ; 不过回调的时间会长一些，2s左右 六、通过两地的经纬度获取两地的距离这里用到了一些数学和地理知识：12345678910function distance (start,end) &#123; // var x1 = (Math.PI/180)*start.y; var x2 = (Math.PI/180)*end.y; var y1 = (Math.PI/180)*start.x; var y2 = (Math.PI/180)*end.x; var R = 6371 ; //地球半径 var dis = Math.acos(Math.sin(x1)*Math.sin(x2)+Math.cos(x1)*Math.cos(x2)*Math.cos(y2-y1))*R; return dis.toFixed(2) ; //四舍五入保留两位小数，返回string类型&#125;distance(&#123;x:0,y:0&#125;,&#123;x:0,y:1&#125;) //算出经度为0，纬度为0 与 经度为0，纬度为1 两点之间的距离 七、百度地图API其他的一些功能，例如搜索、给出出行路线12345678910111213141516171819202122232425262728//创建信息窗口对象var infoWindow = new BMap.InfoWindow("I am here");map.openInfoWindow(infoWindow,point);//在地图中添加折线var polyline = new BMap.Polyline([ new BMap.Point(x,y), new BMap.Point(x+0.01,y+0.01) ],&#123;strokeColor:"blue", strokeWeight:6, strokeOpacity:0.5&#125;);map.addOverlay(polyline); //在地图中添加搜索功能var local = new BMap.LocalSearch(map, &#123; renderOptions:&#123; map: map &#125;&#125;);local.search("天安门");//给出地图的路线var driving = new BMap.DrivingRoute(map, &#123; renderOptions: &#123; map: map, autoViewport: true &#125;&#125;);driving.search("中关村", "天安门"); 感兴趣的话可以尝试一下，时间有限，回家睡觉，就不一一列举了。 2017-09-16 增 需要注意的的是，如在本地起服务器，地址是localhost的话，有时候会定位失败。这时候可以尝试把localhost换成本机的IP地址再试一下。 参考文献百度地图API文档许鸿飞的博客“莫水千留”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>百度地图API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat服务器配置虚拟目录]]></title>
    <url>%2F2017%2F08%2F09%2FTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前两天配置Tomcat服务器老是起不起来，后来在孙老板的帮助下配置成功，这里做一个备忘 1、如何配置虚拟目录？ 找到 Tomcat 所在的文件目录，在其下有一个 bin\server.xml 文件,在 &lt;Host&gt;&lt;/Host&gt; 里的最后一行，加入如下代码 1&lt;Context path="/" docBase="C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\app"/&gt; 写完整了就像这样： 1234567&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="/" docBase="C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\app"/&gt;&lt;/Host&gt; 其中的 docBase 的值就是要配的虚拟目录，注意要写成绝对路径,另外要注意的就是字符串要做转义处理 \ 转义成 \\ 2、如果起不起来怎么办？这时候 log 文件夹下的日志或许能帮助我们了解到底报了什么错。很多情况下报错的原因是端口被暂用，这时候只要在 server.xml 下改一下相应的端口号就好啦！ 需要注意的是，server.xml 下配置不止一个端口号，有时候改了只改了一个端口号，可能仍然会报错，这时候就要修改其他被占用的端口号。 想要了解tomcat各个端口的实际意义，可以参考以下链接 “风的脚步”的CSDN博客]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>后台备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JS获得浏览器的各种高度与宽度]]></title>
    <url>%2F2017%2F08%2F07%2F%E9%80%9A%E8%BF%87JS%E8%8E%B7%E5%BE%97%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E5%BA%A6%E4%B8%8E%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[简单整理一下js可以获得的各种浏览器的高度 1234567891011121314151617181920212223242526272829function Query () &#123; //1、浏览器窗口大小 console.log("浏览器（显示网页）窗口的宽：window.innerWidth -&gt;"+window.innerWidth) ; console.log("浏览器（显示网页）窗口的高：window.innerHeight -&gt;"+window.innerHeight) ; console.log("浏览器的宽：window.outerWidth -&gt;"+window.outerWidth) ; console.log("浏览器的高：window.outerHeight -&gt;"+window.outerHeight) ; //2、dom元素相关 console.log("body元素的宽：document.body.clientWidth -&gt;"+document.body.clientWidth) ; console.log("body元素的高：document.body.clientHeight -&gt;"+document.body.clientHeight) ; console.log("body元素的宽(包括边线的宽)：document.body.offsetWidth -&gt;"+document.body.offsetWidth) ; console.log("body元素的高(包括边线的宽)：document.body.offsetHeight -&gt;"+document.body.offsetHeight) ; //dom元素相对于其父定位元素顶部的距离：dom.offsetTop (dom为dom对象的引用)(包括边线的宽) //dom元素相对于其父定位元素左边的距离：dom.offsetLeft (dom为dom对象的引用)(包括边线的宽) console.log("body元素内部子元素的宽：document.body.scrollWidth -&gt;"+document.body.scrollWidth) ; console.log("body元素内部子元素的高：document.body.scrollHeight -&gt;"+document.body.scrollHeight) ; console.log("html元素内部子元素被卷去的高(is_writeable)：document.documentElement.scrollTop -&gt;"+document.documentElement.scrollTop ) ; console.log("html元素内部子元素被卷去的左(is_writeable)：document.documentElement.scrollLeft -&gt;"+document.documentElement.scrollLeft ) ; //3、电脑屏幕相关 console.log("浏览器（外部）与电脑屏幕左边的距离：window.screenLeft -&gt;"+window.screenLeft) ; console.log("浏览器（外部）与电脑屏幕顶部的距离：window.screenTop -&gt;"+window.screenTop ) ; console.log("浏览器（外部）与电脑屏幕左边的距离：window.screenX -&gt;"+window.screenX) ; console.log("浏览器（外部）与电脑屏幕顶部的距离：window.screenY -&gt;"+window.screenY ) ; console.log("电脑屏幕的高：window.screen.height -&gt;"+window.screen.height ) ; console.log("电脑屏幕的宽：window.screen.width -&gt;"+window.screen.width ) ; console.log("浏览器屏幕可用工作区最大高度（最大化后的可用高度）(最大化后似乎与window.innerHeight相差几个px，不太准)：window.screen.availHeight -&gt;"+window.screen.availHeight ) ; console.log("浏览器屏幕可用工作区最大宽度（最大化后的可用宽度）：window.screen.availWidth -&gt;"+window.screen.availWidth ) ;&#125;Query() ;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过css样式禁止事件&禁止图标]]></title>
    <url>%2F2017%2F08%2F07%2F%E9%80%9A%E8%BF%87csss%E6%A0%B7%E5%BC%8F%E7%A6%81%E6%AD%A2%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候，我们只想显示页面给用户看，而不想让用户有任何操作，这时候，在css中写入样式 pointer-events:none 就能达到想要的效果 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .test1&#123; cursor: not-allowed; &#125; .test2&#123; pointer-events:none; &#125; .test3&#123; cursor: not-allowed; pointer-events:none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button class="test1" onclick="con()"&gt;按钮一&lt;/button&gt; &lt;button class="test2" onclick="con()"&gt;按钮二&lt;/button&gt; &lt;button class="test3" onclick="con()"&gt;按钮二&lt;/button&gt; &lt;br&gt; &lt;input class='test1' type='text' onclick="con()"/&gt; &lt;input class='test2' type='text' onclick="con()"/&gt; &lt;input class='test3' type='text' onclick="con()"/&gt; &lt;/body&gt; &lt;script&gt; function con()&#123; alert("show here!") ; &#125; &lt;/script&gt;&lt;/html&gt; 不过需要注意的是，由于设置了 pointer-events:none 把所有点击事件全部禁掉了，所有的 cursor 也没有了,所以原本可以通过 cursor: not-allowed 显示的禁止图标也不会再显示了]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端备忘</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用闭包或者setInterval实现一个计时器]]></title>
    <url>%2F2017%2F08%2F07%2F%E7%94%A8%E9%97%AD%E5%8C%85%E6%88%96%E8%80%85setInterval%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在开发业务中，有时候需要手机获取验证码，一般情况下，在点击 获取验证码 后，会有一个60秒倒计时的需求，这时候可以用以下两个方法来实现 通过JS中的 闭包 的来实现，代码如下： 12345678910111213function countDown(time)&#123; var time = time||60 ; //默认60s倒计时 var fn = function()&#123; if(time&gt;0)&#123; setTimeout(fn,1000) ; console.log(time--+'s') ; &#125;else&#123; console.log('end') ; &#125; &#125;; return fn ;&#125;countDown()() ; //运行方法 也可以通过JS中的 setInterval 方法来实现，代码如下： 123456789101112function countDown(time)&#123; var time = time||10 ; var fn = setInterval(function()&#123; if(time&gt;0)&#123; console.log(time--+'s') ; &#125;else&#123; console.log('end') ; clearInterval(fn); &#125; &#125;,1000)&#125;countDown() ; //运行方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中查询URL字符串中的参数]]></title>
    <url>%2F2017%2F08%2F03%2FJS%E4%B8%AD%E6%9F%A5%E8%AF%A2URL%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[原生JS中的 location.search 可以返回从问号到 URL 末尾的所有内容，但是访问其中的每个字符串参数却很麻烦。这时候，可以创建一个函数，用以解析查询字符串 1234567891011121314151617181920212223242526function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, //在 for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到 args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这样getQueryStringArgs()方法就会返回包含所有URL参数的一个对象。 参考文献JavaScript高级程序设计（第3版）P207]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo设置博文置顶]]></title>
    <url>%2F2017%2F07%2F31%2Fhexo%E8%AE%BE%E7%BD%AE%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%2F</url>
    <content type="text"><![CDATA[有时候我们需要置顶自己的某篇博文，这时候我们可以手动修改node_moudles文件夹下的相关代码 修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为如下所示： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加相应的 top 值，数值越大文章就会越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 参考文献Moorez的简书]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
        <tag>转载</tag>
      </tags>
  </entry>
</search>
