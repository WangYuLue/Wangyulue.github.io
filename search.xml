<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[python基础语法小结（一）]]></title>
    <url>%2F2017%2F10%2F19%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了数据类型和变量、list 、tuple、循环、dict、set中值得留意的地方。 一、数据类型和变量1、在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。下表是开发中一些常用的转义字符： 转义字符 描述 \(在行尾时) 续行符 \\ 反斜杠符号 \&#39; 单引号 \&quot; 双引号 \n 换行 \t 横向制表符 2、如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，参考如下代码： 1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 3、如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容。 4、在python中，在Python中，布尔值的首字母是大写的（True，False） 5、在python3中，有两种除法： 一种除法是/,其计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12345&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 这一点和python2的语法有差异。 二、使用list1、list是一种有序的集合，可以随时添加和删除其中的元素。 2、用len()函数可以获得list元素的个数： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3 3、list可以用负数做索引，例如-1做索引，可以直接获取最后一个元素： 12&gt;&gt;&gt; classmates[-1]'Tracy' 4、append可以往list中追加元素到末尾。 5、也可以把元素插入到指定的位置，比如索引号为1的位置： 1234&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 6、pop 会删除list末尾的元素，如果要删除指定位置的元素，可以用pop(i)方法，其中i是索引位置。 7、如果要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： 123&gt;&gt;&gt; classmates[1] = &apos;Sarah&apos;&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 三、使用tuple1、tuple和list非常类似，但是tuple一旦初始化就不能修改。 2、如果要定义一个空的tuple，可以写成()；但是，要定义一个只有1个元素的tuple，如果你这么定义： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 四、循环1、如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数: 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 如果要计算0～100的和，可以参考如下代码： 1234sum = 0for x in range(101): sum = sum + xprint(sum) 五、使用dict1、Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 2、如果要删除dict中的一个key，可以用pop(key)方法，对应的value也会从dict中删除。 3、和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 六、使用set1、set中不可以放入可变对象，例如，下面代码会出错： 1234&gt;&gt;&gt; set([1, 1, 2, 2, [3], 3])Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; 这一点和JS里的Set有出入，在JS中，引用类型对象也可以放入Set对象中。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道算法题以及关于其时间复杂度的一些讨论]]></title>
    <url>%2F2017%2F10%2F19%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些算法题，其中有一个Two Sum的算法，其中涉及一些关于时间复杂度的问题，在这里做一个讨论 一、算法描述如下：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 如果想看leetcode上关于two sum的描述可以点这里 二、解决思路1、王二最开始写下了如下算法： 123456789101112function twoSum (nums,target) &#123; var out ; nums.forEach(function(element1,index1) &#123; nums.forEach(function(element2,index2)&#123; if(index2&lt;=index1) return ; if(element1+element2===target &amp;&amp; !out)&#123; out = [index1,index2] &#125; &#125;) &#125;); return out ;&#125; 但是以上算法有一个缺陷，Array.prototype.forEach在遍历数组时中途不能跳出循环，除非我手动抛出一个错误，但是这样就显得非常不优雅了。 2、于是王二想到了可以用for循环，代码如下： 123456789function twoSum (nums,target) &#123; for (var x=0; x&lt;nums.length;x++)&#123; for (var y=x+1; y&lt;nums.length;y++)&#123; if(nums[x]+nums[y]===target)&#123; return [x,y] ; &#125; &#125; &#125;&#125; 这样写的话，只要一找到符合条件的数组，就能跳出循环，相比第一种方法效率提高了不少。 3、不过王二觉得两层for循环是在是不太好看，甚至觉得有点low，一定有其他的解决方案，于是又细细思索了一下，改进了代码如下： 123456function twoSum (nums,target) &#123; for (var x=0; x&lt;nums.length;x++)&#123; var y = nums.lastIndexOf(target-nums[x]) if(y&gt;0) return x===y?undefined:[x,y] ; &#125;&#125; 这样写的话代码就显得优雅精悍的多了，但它本质上还是两层循环，时间复杂度仍然为O(n^2)，因为indexOf是数组的元素存在性检查方法。需要遍历所有元素来检查，此方法的时间复杂度是O(n) 参考如下验证时间为O(n^2)的代码：12345678910111213141516171819202122232425function largeArray(index) &#123; var arr = [] ; var count = 1 ; for(var x = 0;x&lt;index;x++)&#123; arr.push(count++); &#125; return arr ;&#125;function twoSum (nums,target) &#123; console.time() ; for (var x=0; x&lt;nums.length;x++)&#123; var y = nums.lastIndexOf(target-nums[x]) if(y&gt;0) &#123; return x===y?undefined:[x,y] ; &#125; &#125; console.timeEnd() ;&#125;//注意arr1与arr2分开执行var arr1 = largeArray(10000);//var arr2 = largeArray(100000);twoSum(arr1,10000000) //为10000000时，方法由于找不到适配的结果，所以会遍历所有情况//twoSum(arr2,10000000) 执行时间如下图所示： 可以发现在数组长度多了10倍的情况下，执行时间多了近100倍。 4、leetcode上有大神用java写下了如下代码(链接在这里)：12345678910111213public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; if (map.containsKey(target - numbers[i])) &#123; result[1] = i + 1; result[0] = map.get(target - numbers[i]); return result; &#125; map.put(numbers[i], i + 1); &#125; return result;&#125; 它的时间复杂度为O(n)，原因是作者巧妙地运用了HashMap的containsKey()方法，由于HashMap使用哈希表来存储元素，所以在查询key时，其时间复杂度为O(1)。 5、于是我也用js复原了一下上面的java算法，参考如下：123456789function twoSum (nums,target) &#123; var obj = &#123;&#125;; for (var x=0; x&lt;nums.length;x++)&#123; if(obj.hasOwnProperty(target-nums[x])) &#123; return [obj[target-nums[x]],x] ; &#125; obj[nums[x]]=x; &#125;&#125; 这里的Object.prototype.hasOwnProperty类似java中HashMap的containsKey()方法，时间复杂度为O(1)；所以以上代码的时间复杂度也变成了O(n) 参考如下验证时间为O(n)的代码：1234567891011121314151617181920212223242526function largeArray(index) &#123; var arr = [] ; var count = 1 ; for(var x = 0;x&lt;index;x++)&#123; arr.push(count++); &#125; return arr ;&#125;function twoSum (nums,target) &#123; console.time() ; var obj = &#123;&#125;; for (var x=0; x&lt;nums.length;x++)&#123; if(obj.hasOwnProperty(target-nums[x])) &#123; return [obj[target-nums[x]],x] ; &#125; obj[nums[x]]=x; &#125; console.timeEnd() ;&#125;//注意arr1与arr2分开执行var arr1 = largeArray(10000);//var arr2 = largeArray(100000);twoSum(arr1,10000000) //为10000000时，方法由于找不到适配的结果，所以会遍历所有情况//twoSum(arr2,10000000) 执行时间如下图所示： 可以发现在数组长度多了10倍的情况下，执行时间也只多了不到10倍。 二、小结上述代码中，在数组长度很大的情况下，时间复杂度为O(n^2)与时间复杂度为O(n)的执行效率相差了近万倍，有时候会严重地影响性能，从这一点来看，以后写算法的时候要特别注意算法的时间复杂度； 参考文章：leetcodesegmentfaultCSDN”旧时光“的博客]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式踩坑小结]]></title>
    <url>%2F2017%2F10%2F12%2FCSS%E6%A0%B7%E5%BC%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近做了一些项目，在CSS方面遇到了不少坑，在这里做一个小结 一、iOS上的Safari没有滑动惯性在开发iphone微信端的时候，如果给一个div设置样式为滑动,样式如下：123div&#123; overflow-y:scroll ;&#125; 会发现Safari的滑动很僵硬，这时候可以用以下样式来解决：123div&#123; -webkit-overflow-scrolling: touch;&#125; 二、去除iphone中点击按钮会出现一个半透明的灰色背景的问题在开发iphone微信端的时候，同样发现，如果点击一个按钮，按钮会出现一个半透明的灰色背景，这时候可以用以下样式来解决： 123a,img,button,input,textarea,div&#123; -webkit-tap-highlight-color:rgba(255,255,255,0); &#125; 三、div中保留保留文本的空格、换行以及tab字符的处理在后台用textarea标签写入文本放入前端显示的时候，发现之前在textarea中的文本都被格式化了（浏览器默认把文本中的空格、换行以及tab字符都处理掉了），如果想保留文本的格式，可以用以下样式来解决： 123div&#123; white-space: pre-wrap;&#125; 需要特别注意的是，white-space有五种值可以选择，normal、pre 、nowrap 、pre-wrap、pre-wrap,每一种值都有不同的表现形式，其中： normal 是 white-space 的默认值； pre 会保留文本中额外的空格, 而且会保留文本中的换行； nowrap 不会保留文本中额外的空格，而且会禁止文本中的换行； pre-wrap 会保留文本中额外的空格, 而且会让文本正常的换行； pre-line 不会保留文本中额外的空格，但是会让文本正常的换行； 这样解释读者会有一些迷惑，接下来用代码进一步说明，参考如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;style&gt; .a&#123; white-space: pre &#125; .b&#123; white-space: nowrap &#125; .c&#123; white-space: pre-wrap &#125; .d&#123; white-space: pre-line &#125; .e&#123; white-space: normal &#125;&lt;/style&gt;&lt;div class="a"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="b"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="c"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="d"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="e"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt; 这里我们要特地留意一下 pre 与 pre-wrap 的区别，正常情况下，两者的现实没有差异，如下图： 但是如果将窗口拉窄,我们会发现，pre-wrap会让文本根据窗口宽窄自动换行，而pre的换行不会受窗口宽窄影响： 四、让盒子里的字超出长度后，可以缩略显示变成点点点1、在 div 框里的内容超出长度后，我们可以让超出部分的内容变成点点点，样式如下： 12345div&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;&#125; 然后我们就能获得我们想要的样式： 1234567891011121314151617&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .ellipsis&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; &#125;&lt;/style&gt;&lt;div class="a"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt; 效果图如下： 2、但是如果我们想让div里的内容两行或者三行之后再显示点点点，我们应该怎么办呢？如果你也有疑惑，可以参考如下代码： 123456789101112131415161718&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="a"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt; 效果图如下： 这时候变成三行后再省略也相当简单，直接将 -webkit-line-clamp 变成 3 就行了。 3、特别特别需要注意的是，如果遇到丧心病狂的测试，他会给出一长串连续的英文字符，那么以上代码有可能会失效，这时候就需要word-break: break-all; 来帮助我们，参考如下代码： 1234567891011121314151617181920212223242526272829&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .break&#123; word-break: break-all ; &#125; .ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="a"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a break ellipsis"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a break"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt; 效果图如下： 五、word-wrap和word-break的区别1、word-wrap和word-break都能使过长的字符串断开，防止其溢出，那他们两的区别又是什么呢？ 2、我们先从MDN文档里了解它们的概要： CSS 属性 word-break 指定了怎样在单词内断行。他的属性有： normal 使用默认的断行规则。 break-all 对于non-CJK (CJK 指中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 CSS 属性 word-wrap 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。他的属性有： normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被被分割的单词会被强制分割换行。 3、仅仅看解释并不能看出什么头绪，接下来用代码来演示他们的差异，代码如下： 12345678910111213141516171819202122&lt;style&gt;.a&#123; width:100px; border: 1px solid gray;&#125;.break&#123; word-break: break-all ;&#125;.wrap&#123; word-wrap: break-word ;&#125;&lt;/style&gt;&lt;div class="a"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt;&lt;hr&gt;&lt;div class="a break"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt;&lt;hr&gt;&lt;div class="a wrap"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt; 效果图如下： 我们发现，当使用word-wrap: break-word;时，如果这个时候文本溢出，它会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话才会进行单词内的断句。而使用word-break:break-all时，他会直接进行单词内的断句。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.keys、Object.values、Object.entries的使用方法]]></title>
    <url>%2F2017%2F10%2F11%2FJS%E4%B8%ADObject-keys%E3%80%81Object-values%E3%80%81Object-entries%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.keys、Object.values、Object.entries的使用方法 一、大致了解首先我们需要了解的是Object.keys是ES5中引入的的方法，在ES2017中，引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段。 需要注意的是，Object.keys(),Object.values(),Object.entries()都会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致( 区别在于 for...in 还会循环枚举原型链中的属性 )。 参考一些代码：1234567let obj = &#123; a: 1, b: 2, c: 3 &#125;;Object.keys(obj); // ['a','b','c']Object.values(obj); // [1,2,3]Object.entries(obj); // [['a',1],['b',2],['c',3]] 我们会发现，Object.keys会返回参数对象自身的所有可遍历属性的键名形成的数组，Object.values会返回参数对象自身的所有可遍历属性的键值形成的数组，Object.entries会返回参数对象自身的所有可遍历属性的键值对数组形成的数组 二、其他一些例子再来看一些Object.keys、Object.values、Object.entries的其他使用方法：123456789101112131415161718192021222324252627/* Array 对象 */ var arr = ["a", "b", "c"];console.log(Object.keys(arr)); // ["0", "1", "2"]console.log(Object.values(arr)); // ["a", "b", "c"]console.log(Object.entries(arr)); // [["0", "a"], ["1", "b"], ["2", "c"]]/* 类数组 对象 */ var obj = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;console.log(Object.keys(obj)); // ["0", "1", "2"]console.log(Object.values(obj)); // ["a", "b", "c"]console.log(Object.entries(obj)); // [["0", "a"], ["1", "b"], ["2", "c"]]/* 类数组 对象, 随机排序 */var obj1 = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;; console.log(Object.keys(obj1)); // ["2", "7", "100"]console.log(Object.values(obj1)); // ["b", "c", "a"]console.log(Object.entries(obj1)); // [["2", "b"],["7", "c"],["100", "a"]]/* a 是个不可枚举的属性 */ var obj2 = &#123;&#125;Object.defineProperty(obj2,'a', &#123; value : "hala"&#125;);obj2.b = "heihei";console.log(Object.keys(obj2)); // ['b']console.log(Object.values(obj2)); // ['heihei']console.log(Object.entries(obj2)); // [["b", "heihei"]] 三、注意点在ES5里，如果传入的参数不是对象（而是一个原始值），那么它会抛出 TypeError。但是在ES2015中，非对象的参数将被强制转换为一个对象，参考如下代码：12345678Object.keys("foo"); // TypeError: "foo" is not an object (ES5 code)Object.keys("foo");// ["0", "1", "2"] (ES2015 code)Object.values("foo"); // TypeError: "foo" is not an object (ES5 code)Object.values("foo");// ["f", "o", "0"] (ES2015 code)Object.entries("foo"); // TypeError: "foo" is not an object (ES5 code)Object.entries("foo");// [["0", "f"],["1", "o"],["2", "o"]] (ES2015 code) 四、Object.entries的另外用法new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以很容易的将Object转换为Map,参考如下代码： 123var obj = &#123; foo: "bar", baz: 42 &#125;; var map = new Map(Object.entries(obj));console.log(map); // Map &#123; foo: "bar", baz: 42 &#125; 参考文档MDN web docs阮一峰ES6语法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.create的使用方法]]></title>
    <url>%2F2017%2F10%2F10%2FJS%E4%B8%ADObject-defineProperty%E4%B8%8EObject-create%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%952%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.create的使用方法 一、Object.create1、Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象，语法如下： Object.create(proto, [ propertiesObject ]) 其中： proto一个对象，新创建对象的原型 propertiesObject可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。 函数将返回一个定原型对象上添加新属性后的新对象 如果 propertiesObject 参数不是 null 也不是对象，则抛出一个 TypeError 异常。 2、一些例子： 1234var a = &#123;v:41&#125;var b = Object.create(a)b.__proto__ === a //true //Object.create返回的对象的原型是其第一个参数。 123o = &#123;&#125;;// 以字面量方式创建的空对象就相当于:o = Object.create(Object.prototype); 12345678910111213141516o = Object.create(Object.prototype, &#123; // foo会成为所创建对象的数据属性 foo: &#123; writable:true, configurable:true, value: "hello" &#125;, // bar会成为所创建对象的访问器属性 bar: &#123; configurable: false, get: function() &#123; return 10 &#125;, set: function(value) &#123; console.log("Setting `o.bar` to", value); &#125; &#125;&#125;); 1234567891011121314// 创建一个以另一个空对象为原型,且拥有一个属性p的对象o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:o.p = 24o.p //42o.q = 12for (var prop in o) &#123; //for..in..不可枚举 console.log(prop)&#125;//"q"delete o.p // Nothing happens 123456789//创建一个可写的,可枚举的,可配置的属性po2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;); 3、使用 Object.create 实现类式继承,参考如下代码： 1234567891011121314151617181920212223242526272829//Shape - superclassfunction Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info("Shape moved.");&#125;;// Rectangle - subclassfunction Rectangle() &#123; Shape.call(this); //call super constructor.&#125;// subclass extends superclassRectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // trueconsole.log('Is rect an instance of Shape?', rect instanceof Shape); // truerect.move(1, 1); //Outputs, "Shape moved." 如果有兴趣了解用其他方式实现类继承，可以参考我的这篇博客理解原型链; 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.defineProperty的使用方法]]></title>
    <url>%2F2017%2F10%2F10%2FJS%E4%B8%ADObject-defineProperty%E4%B8%8EObject-create%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.defineProperty的使用方法 一、Object.defineProperty1、Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，语法如下： Object.defineProperty(obj, prop, descriptor) 其中： obj是需要被操作的目标对象 prop是目标对象需要定义或修改的属性的名称 descriptor是将被定义或修改的属性的描述符 函数将返回被传递给函数的对象 2、一个简单的实例： 12var o = &#123;&#125;;Object.defineProperty(o, "a", &#123;value : 37&#125;); //&#123;a: 37&#125; 上述代码中，我们用Object.defineProperty为对象o创建的了一个新属性a,它的值为37，但是我们也发现了一些问题，参考如下代码： 12345var o = &#123;&#125;;Object.defineProperty(o, "a", &#123;value : 37&#125;); //&#123;a: 37&#125;console.log(o.a); // 打印 37o.a = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）console.log(o.a); // 打印 37， 赋值不起作用。 我们发现，对o.a赋值似乎不起作用，原来Object.defineProperty的第三个参数descriptor有很多属性描述符，其中就有是否能被赋值运算符改变value的属性描述符。 3、具体的属性描述符如下： configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中(可以被for..in..遍历)。默认为 false。 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。 get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 4、这时候我们改造一下代码，如下： 12345678910var o = &#123;&#125;;Object.defineProperty(o, "a", &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;); //&#123;a: 37&#125;console.log(o.a); // 打印 37o.a = 25;console.log(o.a); // 打印 25 这样的话我们就可以正确地为属性赋值了。 5、需要注意的是，对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一；不能同时是两者。其中，数据描述符和存取描述符均具有以下可选键值：configurable，enumerable，value，writable存取描述符同时具有以下可选键值：get，set。 如果两者同时使用，会报如下错误： 12345678var o = &#123;&#125;;Object.defineProperty(o, "conflict", &#123; value: 0x9f91102, get: function() &#123; return 0xdeadbeef; &#125; &#125;);//Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 6、在这里，我们需要特别注意 configurable 这个属性描述符，如果它的值为false，那么除了 writable 外，其他特性都不能被修改(包括其自身)，并且 writable 只能从 true 修改为 false，而且数据和存取描述符也不能相互切换。 如果尝试修改，会报如下错误： 12345678910111213141516171819var o = &#123;&#125;;Object.defineProperty(o, "a", &#123; get : function()&#123;return 1;&#125;, configurable : false &#125;);// throws a TypeErrorObject.defineProperty(o, "a", &#123;configurable : true&#125;); // throws a TypeErrorObject.defineProperty(o, "a", &#123;enumerable : true&#125;); // throws a TypeError (set was undefined previously) Object.defineProperty(o, "a", &#123;set : function()&#123;&#125;&#125;); // throws a TypeError (even though the new get does exactly the same thing) Object.defineProperty(o, "a", &#123;get : function()&#123;return 1;&#125;&#125;);// throws a TypeErrorObject.defineProperty(o, "a", &#123;value : 12&#125;);console.log(o.a); // logs 1delete o.a; // Nothing happensconsole.log(o.a); // logs 1 7、最后，我们又要留意一下存取描述符set与get，vuejs的底层就是通过set与get监听数据变动来实现mvvm的双向绑定的，参考如下代码： 12345678910111213141516171819202122232425262728293031function observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125;var obj = &#123;a:'10',b:'20'&#125;observe(obj)obj.a // '10'obj.a = '100' // 哈哈哈，监听到值变化了 10 --&gt; 100// '100' 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让input里面placeholder水平居中]]></title>
    <url>%2F2017%2F10%2F10%2F%E8%AE%A9input%E9%87%8C%E9%9D%A2placeholder%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[有时候我们想让input里面placeholder水平居中，这个时候我们可以这样做 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; input&#123; width: 200px; height: 30px; color:#333; &#125; input::-ms-input-placeholder&#123;text-align: center;&#125; input::-webkit-input-placeholder&#123;text-align: center;&#125; &lt;/style&gt; &lt;body&gt; &lt;input placeholder="用户名" /&gt; &lt;/body&gt;&lt;/html&gt; 参考文章：知乎问题“如何让input里面placeholder水平居中？”]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器原生API实现Base64编码转换]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9FAPI%E5%AE%9E%E7%8E%B0Base64%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近发现浏览器的两个原生API atob()、btoa() 可以实现编码转换 1、代码如下：12btoa("hello world"); // "aGVsbG8gd29ybGQ="atob("aGVsbG8gd29ybGQ="); // "hello world" 2、再科（bai）普(du) 一下base64的编码原理： 转码过程例子：38=46内存1个字节占8位转前： s 1 3先转成ascii：对应 115 49 512进制： 01110011 00110001 001100116个一组（4组） 011100110011000100110011然后才有后面的 011100 110011 000100 110011然后计算机是8位8位的存数 6不够，自动就补两个高位0了所有有了 高位补0科学计算器输入 00011100 00110011 00000100 00110011得到 28 51 4 51查对下照表 c z E z 3、如果好奇atob()与btoa()的具体实现，可参考如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220/* * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $ * * Licensed under the BSD 3-Clause License. * http://opensource.org/licenses/BSD-3-Clause * * References: * http://en.wikipedia.org/wiki/Base64 */(function(global) &#123; 'use strict'; // existing version for noConflict() var _Base64 = global.Base64; var version = "2.3.2"; // if node.js, we use Buffer var buffer; if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; try &#123; buffer = require('buffer').Buffer; &#125; catch (err) &#123;&#125; &#125; // constants var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; var b64tab = function(bin) &#123; var t = &#123;&#125;; for (var i = 0, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i; return t; &#125;(b64chars); var fromCharCode = String.fromCharCode; // encoder stuff var cb_utob = function(c) &#123; if (c.length &lt; 2) &#123; var cc = c.charCodeAt(0); return cc &lt; 0x80 ? c : cc &lt; 0x800 ? (fromCharCode(0xc0 | (cc &gt;&gt;&gt; 6)) + fromCharCode(0x80 | (cc &amp; 0x3f))) : (fromCharCode(0xe0 | ((cc &gt;&gt;&gt; 12) &amp; 0x0f)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 6) &amp; 0x3f)) + fromCharCode(0x80 | ( cc &amp; 0x3f))); &#125; else &#123; var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00); return (fromCharCode(0xf0 | ((cc &gt;&gt;&gt; 18) &amp; 0x07)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 12) &amp; 0x3f)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 6) &amp; 0x3f)) + fromCharCode(0x80 | ( cc &amp; 0x3f))); &#125; &#125;; var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g; var utob = function(u) &#123; return u.replace(re_utob, cb_utob); &#125;; var cb_encode = function(ccc) &#123; var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) &lt;&lt; 16 | ((ccc.length &gt; 1 ? ccc.charCodeAt(1) : 0) &lt;&lt; 8) | ((ccc.length &gt; 2 ? ccc.charCodeAt(2) : 0)), chars = [ b64chars.charAt( ord &gt;&gt;&gt; 18), b64chars.charAt((ord &gt;&gt;&gt; 12) &amp; 63), padlen &gt;= 2 ? '=' : b64chars.charAt((ord &gt;&gt;&gt; 6) &amp; 63), padlen &gt;= 1 ? '=' : b64chars.charAt(ord &amp; 63) ]; return chars.join(''); &#125;; var btoa = global.btoa ? function(b) &#123; return global.btoa(b); &#125; : function(b) &#123; return b.replace(/[\s\S]&#123;1,3&#125;/g, cb_encode); &#125;; var _encode = buffer ? buffer.from &amp;&amp; buffer.from !== Uint8Array.from ? function (u) &#123; return (u.constructor === buffer.constructor ? u : buffer.from(u)) .toString('base64') &#125; : function (u) &#123; return (u.constructor === buffer.constructor ? u : new buffer(u)) .toString('base64') &#125; : function (u) &#123; return btoa(utob(u)) &#125; ; var encode = function(u, urisafe) &#123; return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function(m0) &#123; return m0 == '+' ? '-' : '_'; &#125;).replace(/=/g, ''); &#125;; var encodeURI = function(u) &#123; return encode(u, true) &#125;; // decoder stuff var re_btou = new RegExp([ '[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]&#123;2&#125;', '[\xF0-\xF7][\x80-\xBF]&#123;3&#125;' ].join('|'), 'g'); var cb_btou = function(cccc) &#123; switch(cccc.length) &#123; case 4: var cp = ((0x07 &amp; cccc.charCodeAt(0)) &lt;&lt; 18) | ((0x3f &amp; cccc.charCodeAt(1)) &lt;&lt; 12) | ((0x3f &amp; cccc.charCodeAt(2)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(3)), offset = cp - 0x10000; return (fromCharCode((offset &gt;&gt;&gt; 10) + 0xD800) + fromCharCode((offset &amp; 0x3FF) + 0xDC00)); case 3: return fromCharCode( ((0x0f &amp; cccc.charCodeAt(0)) &lt;&lt; 12) | ((0x3f &amp; cccc.charCodeAt(1)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(2)) ); default: return fromCharCode( ((0x1f &amp; cccc.charCodeAt(0)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(1)) ); &#125; &#125;; var btou = function(b) &#123; return b.replace(re_btou, cb_btou); &#125;; var cb_decode = function(cccc) &#123; var len = cccc.length, padlen = len % 4, n = (len &gt; 0 ? b64tab[cccc.charAt(0)] &lt;&lt; 18 : 0) | (len &gt; 1 ? b64tab[cccc.charAt(1)] &lt;&lt; 12 : 0) | (len &gt; 2 ? b64tab[cccc.charAt(2)] &lt;&lt; 6 : 0) | (len &gt; 3 ? b64tab[cccc.charAt(3)] : 0), chars = [ fromCharCode( n &gt;&gt;&gt; 16), fromCharCode((n &gt;&gt;&gt; 8) &amp; 0xff), fromCharCode( n &amp; 0xff) ]; chars.length -= [0, 0, 2, 1][padlen]; return chars.join(''); &#125;; var atob = global.atob ? function(a) &#123; return global.atob(a); &#125; : function(a)&#123; return a.replace(/[\s\S]&#123;1,4&#125;/g, cb_decode); &#125;; var _decode = buffer ? buffer.from &amp;&amp; buffer.from !== Uint8Array.from ? function(a) &#123; return (a.constructor === buffer.constructor ? a : buffer.from(a, 'base64')).toString(); &#125; : function(a) &#123; return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString(); &#125; : function(a) &#123; return btou(atob(a)) &#125;; var decode = function(a)&#123; return _decode( String(a).replace(/[-_]/g, function(m0) &#123; return m0 == '-' ? '+' : '/' &#125;) .replace(/[^A-Za-z0-9\+\/]/g, '') ); &#125;; var noConflict = function() &#123; var Base64 = global.Base64; global.Base64 = _Base64; return Base64; &#125;; // export Base64 global.Base64 = &#123; VERSION: version, atob: atob, btoa: btoa, fromBase64: decode, toBase64: encode, utob: utob, encode: encode, encodeURI: encodeURI, btou: btou, decode: decode, noConflict: noConflict &#125;; // if ES5 is available, make Base64.extendString() available if (typeof Object.defineProperty === 'function') &#123; var noEnum = function(v)&#123; return &#123;value:v,enumerable:false,writable:true,configurable:true&#125;; &#125;; global.Base64.extendString = function () &#123; Object.defineProperty( String.prototype, 'fromBase64', noEnum(function () &#123; return decode(this) &#125;)); Object.defineProperty( String.prototype, 'toBase64', noEnum(function (urisafe) &#123; return encode(this, urisafe) &#125;)); Object.defineProperty( String.prototype, 'toBase64URI', noEnum(function () &#123; return encode(this, true) &#125;)); &#125;; &#125; // // export Base64 to the namespace // if (global['Meteor']) &#123; // Meteor.js Base64 = global.Base64; &#125; // module.exports and AMD are mutually exclusive. // module.exports has precedence. if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports.Base64 = global.Base64; &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], function()&#123; return global.Base64 &#125;); &#125; // that's it!&#125;)( typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this); 以上代码是GitHub上js-base64的开源代码，感兴趣的同学可以戳这里]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS格式化日期函数]]></title>
    <url>%2F2017%2F10%2F01%2FJS%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在JAVA中用SimpleDateFormat对象可以格式化日期，JS中没有原生方法，这个时候可以考虑自己写一个 代码如下： 12345678910111213141516171819202122/** 对Date的扩展，将 Date 转化为指定格式的String 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 例子： * (new Date()).Format("yyyy-MM-dd hh:mm:ss.S") ==&gt; 2006-07-02 08:09:04.423 * (new Date()).Format("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 * Date.prototype.Format = function (fmt) &#123; //author: meizz */ var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125; 另一种写法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 例子： * (new Date()).pattern("yyyy-MM-dd hh:mm:ss.S")==&gt; 2006-07-02 08:09:04.423 * (new Date()).pattern("yyyy-MM-dd E HH:mm:ss") ==&gt; 2009-03-10 二 20:09:04 * (new Date()).pattern("yyyy-MM-dd EE hh:mm:ss") ==&gt; 2009-03-10 周二 08:09:04 * (new Date()).pattern("yyyy-MM-dd EEE hh:mm:ss") ==&gt; 2009-03-10 星期二 08:09:04 * (new Date()).pattern("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 */ Date.prototype.pattern=function(fmt) &#123; var o = &#123; "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "h+" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 "H+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒 &#125;; var week = &#123; "0" : "/u65e5", "1" : "/u4e00", "2" : "/u4e8c", "3" : "/u4e09", "4" : "/u56db", "5" : "/u4e94", "6" : "/u516d" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? "/u661f/u671f" : "/u5468") : "")+week[this.getDay()+""]); &#125; for(var k in o)&#123; if(new RegExp("("+ k +")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length))); &#125; &#125; return fmt; &#125; 参考博客‘一路前行’的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC上如何自由切换python2和python3并正确使用pip]]></title>
    <url>%2F2017%2F10%2F01%2FMAC%E4%B8%8A%E5%A6%82%E4%BD%95%E8%87%AA%E7%94%B1%E5%88%87%E6%8D%A2python2%E5%92%8Cpython3%E5%B9%B6%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8pip%2F</url>
    <content type="text"><![CDATA[MAC上默认的Python版本是2的版本，这时候怎么才能用上3的语法呢？用pip安装依赖的时候怎么才能根据不同的版本安装不同的依赖库呢？如果你对此也有疑问，或许这篇文章能帮助你 一、下载Python3最新版本如果还没有下载python3最新的版本，可以进入python的官网进行下载。 二、正确的使用Python3进行编译一开始以为用上Python3需要一些特殊的操作，后来发现自己还是 too young too simple sometimes native，事实上，不需要什么特殊的操作，要用Python2就用Python命令编译，就像下面这样： python ./demo.py 要用Python3就用Python3命令编译，就像下面这样： python3 ./demo.py 就这么简单。 三、安装pippip是python的包管理工具，类似node.js中的npm,在MAC中，安装pip很简单，输入如下命令即可安装： sudo easy_install pip 四、在python2和python3上正确的使用pip对于 Linux ## sudo pip install sth 或者明确版本 sudo pip2 install sthsudo pip3 install sthsudo python2 -m pip install sthsudo /path/to/python -m pip install sth 对于 Windows NT ##如果仅安装 python2 pip install sth 如果安装有 python3, 则需要明确 pip 版本 py -2 -m pip install sthpy -3 -m pip install sth 这一条参考的是知乎上同时装了Python3和Python2，怎么用pip？下Johnny Wong的回答,如果还有疑问，可以点进去了解详情。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE浏览器跳转报400错误的问题]]></title>
    <url>%2F2017%2F09%2F30%2FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%B3%E8%BD%AC%E6%8A%A5400%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近开发中，遇到一个问题，在Chrome中可以正常跳转的链接在IE中跳转就会报400错误 如果URL的参数中带有中文，那么在IE中，则很有可能会报400错误，这个时候正确的做法是用js自带的encodeURL对URL进行编码，后传到另个一面后再用decodeURL进行解码。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS转换HTML转义符]]></title>
    <url>%2F2017%2F09%2F30%2FJS%E8%BD%AC%E6%8D%A2HTML%E8%BD%AC%E4%B9%89%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前两天在公司写代码，在后台请求的数据放到前台时显示错乱，检查后发现如果文本里有&lt;,后面再紧跟字母的话，html就会显示错误，要解决这个问题，可以对文本里的特殊字符进行转义 一、去掉html标签123function removeHtmlTab(tab) &#123; return tab.replace(/&lt;[^&lt;&gt;]+?&gt;/g,'');//删除所有HTML标签&#125; 二、普通字符转换成转意符123function html2Escape(sHtml) &#123; return sHtml.replace(/[&lt;&gt;&amp;"]/g,function(c)&#123;return &#123;'&lt;':'&amp;lt;','&gt;':'&amp;gt;','&amp;':'&amp;amp;','"':'&amp;quot;'&#125;[c];&#125;);&#125; 三、转意符换成普通字符1234function escape2Html(str) &#123; var arrEntities=&#123;'lt':'&lt;','gt':'&gt;','nbsp':' ','amp':'&amp;','quot':'"'&#125;; return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(all,t)&#123;return arrEntities[t];&#125;);&#125; 三、&nbsp;转成空格1234function nbsp2Space(str) &#123; var arrEntities = &#123;'nbsp' : ' '&#125;; return str.replace(/&amp;(nbsp);/ig, function(all, t)&#123;return arrEntities[t]&#125;)&#125; 四、回车转为br标签123function return2Br(str) &#123; eturn str.replace(/\r?\n/g,"&lt;br /&gt;");&#125; 五、去除开头结尾换行,并将连续3次以上换行转换成2次换行123456function trimBr(str) &#123; str=str.replace(/((\s|&amp;nbsp;)*\r?\n)&#123;3,&#125;/g,"\r\n\r\n");//限制最多2次换行 str=str.replace(/^((\s|&amp;nbsp;)*\r?\n)+/g,'');//清除开头换行 str=str.replace(/((\s|&amp;nbsp;)*\r?\n)+$/g,'');//清除结尾换行 return str;&#125; 六、将多个连续空格合并成一个空格1234function mergeSpace(str) &#123; str=str.replace(/(\s|&amp;nbsp;)+/g,' '); return str;&#125; 参考博客：SJY之家]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js过滤emoji表情符号]]></title>
    <url>%2F2017%2F09%2F30%2Fjs%E8%BF%87%E6%BB%A4emoji%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[有时候，在手机的输入框输入emoji，插入数据库时会报错，这时候有一个解决方案是用js正则把emoji表情给过滤掉 unicode定义的emoji是四个字符，而Mysql的utf8编码最多3个字节，所以数据插不进去。所以数据库会报错： SQLException: Incorrect string value 这时候有三种解决方案： 把emoji直接过滤掉； 将Mysql的编码从utf8转换成utf8mb4; unicode emoji转义为softbank的emoji; 这次只讨论第一种方案, 以下是正则代码,很简短，只有一行：1name = name.replace(/\ud83c[\udf00-\udfff]|\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g, ""); 参考博客：“逸学堂”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取随机字符串]]></title>
    <url>%2F2017%2F09%2F29%2F%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[如何获取一段随机字符串？下面的方法或许能帮到你 123456789101112131415 /** * Get the a random string * @param &#123;integer&#125; len length of the random string * @return &#123;string&#125; */function getStrRandom(len) &#123; //len为字符串长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS字符串截取函数slice(),substring(),substr()的区别]]></title>
    <url>%2F2017%2F09%2F28%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E5%87%BD%E6%95%B0slice-substring-substr%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在JS中,slice()、substring()、substr()都有截取字符串的作用，那他们有哪些用法上的区别呢？如果你也有疑惑，这篇文章或许能够帮助到你。 一、substring()substring()方法返回一个索引和另一个索引之间的字符串，语法如下： str.substring(indexStart, [indexEnd]) 下面有六点需要注意： substring()从提取的字符indexStart可达但不包括 indexEnd 如果indexStart 等于indexEnd，substring()返回一个空字符串。 如果indexEnd省略，则将substring()字符提取到字符串的末尾。 如果任一参数小于0或是NaN，它被视为为0。 如果任何一个参数都大于stringName.length，则被视为是stringName.length。 如果indexStart大于indexEnd，那么效果substring()就好像这两个论点被交换了一样； 例如，str.substring(1, 0) == str.substring(0, 1) 以下是一些示例代码：123456789var str = 'abcdefghij';console.log('(1, 2): ' + str.substring(1, 2)); // '(1, 2): b'console.log('(1, 1): ' + str.substring(1, 1)); // '(1, 1): 'console.log('(-3, 2): ' + str.substring(-3, 2)); // '(-3, 2): ab'console.log('(-3): ' + str.substring(-3)); // '(-3): abcdefghij'console.log('(1): ' + str.substring(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.substring(-20, 2)); // '(-20, 2): ab'console.log('(2, 20): ' + str.substring(2, 20)); // '(2, 20): cdefghij'console.log('(20, 2): ' + str.substring(20, 2)); // '(20, 2): cdefghij' 二、substr()substr()方法返回从指定位置开始的字符串中指定字符数的字符，语法如下： str.substr(start, [length]) 下面有四点需要注意： substr()会从start获取长度为length字符（如果截取到字符串的末尾，则会停止截取）。 如果start是正的并且大于或等于字符串的长度，则substr()返回一个空字符串。 若start为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。 如果length为0或为负数，substr()返回一个空字符串。如果length省略，则将substr()字符提取到字符串的末尾。 以下是一些示例代码：1234567var str = 'abcdefghij';console.log('(1, 2): ' + str.substr(1, 2)); // '(1, 2): bc'console.log('(-3, 2): ' + str.substr(-3, 2)); // '(-3, 2): hi'console.log('(-3): ' + str.substr(-3)); // '(-3): hij'console.log('(1): ' + str.substr(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.substr(-20, 2)); // '(-20, 2): ab'console.log('(20, 2): ' + str.substr(20, 2)); // '(20, 2): ' 需要注意的是，Microsoft的JScript不支持起始索引的负值。如果要使用此功能，可以使用以下兼容性代码来解决此错误： 12345678910111213141516171819// only run when the substr() function is brokenif ('ab'.substr(-1) != 'b') &#123; /** * Get the substring of a string * @param &#123;integer&#125; start where to start the substring * @param &#123;integer&#125; length how many characters to return * @return &#123;string&#125; */ String.prototype.substr = function(substr) &#123; return function(start, length) &#123; // call the original method return substr.call(this, // did we get a negative start, calculate how much it is from the beginning of the string // adjust the start parameter for negative value start &lt; 0 ? this.length + start : start, length) &#125; &#125;(String.prototype.substr);&#125; 三、substring()与substr()的主要区别substring()方法的参数表示起始和结束索引，substr()方法的参数表示起始索引和要包含在生成的字符串中的字符的长度,示例如下： 123var text = 'Mozilla';console.log(text.substring(2,5)); // =&gt; "zil"console.log(text.substr(2,3)); // =&gt; "zil" 四、slice()slice()方法返回一个索引和另一个索引之间的字符串，语法如下： str.slice(beginIndex[, endIndex]) 下面有三点需要注意： 若beginIndex为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。 如果beginIndex大于或等于字符串的长度，则slice()返回一个空字符串。 如果endIndex省略，则将slice()字符提取到字符串的末尾。如果为负，它被视为strLength + endIndex其中strLength是字符串的长度。 以下是一些示例代码：1234567891011var str = 'abcdefghij';console.log('(1, 2): ' + str.slice(1, 2)); // '(1, 2): b'console.log('(-3, 2): ' + str.slice(-3, 2)); // '(-3, 2): 'console.log('(-3, 9): ' + str.slice(-3, 9)); // '(-3, 9): hi'console.log('(-3): ' + str.slice(-3)); // '(-3): hij'console.log('(-3，-1): ' + str.slice(-3，-1)); // '(-3，-1): hi'console.log('(0，-1): ' + str.slice(0，-1)); // '(0，-1): abcdefghi'console.log('(1): ' + str.slice(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.slice(-20, 2)); // '(-20, 2): ab'console.log('(20): ' + str.slice(20)); // '(20): 'console.log('(20, 2): ' + str.slice(20, 2)); // '(20, 2): ' 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何进行对象的深拷贝]]></title>
    <url>%2F2017%2F09%2F21%2FJS%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在JS中，一般的=号传递的都是对象/数组的引用，并没有真正地拷贝一个对象，那如何进行对象的深度拷贝呢？如果你对此也有疑问，这篇文章或许能够帮助到你。 一、对象引用、浅层拷贝与深层拷贝的区别js的对象引用传递理解起来很简单，参考如下代码：12345var a = &#123;name:'wanger'&#125;var b = a ;a===b // trueb.name = 'zhangsan'a.name //'zhangan' 上述代码中，使用了=进行赋值，于是b指向了a所指向的栈的对象，也就是a与b指向了同一个栈对象，所以在对b.name赋值时，a.name也发生了变化。为了避免上面的情况，可以对对象进行拷贝，代码如下： 12345var a = &#123;name:'wanger'&#125;var b = Object.assign(&#123;&#125;, a)a===b // falseb.name = 'zhangsan'a.name //'wanger' 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆，这时候a与b指向的是不同的栈对象，所以对b.name重新复制也不会影响到a.name。但是如果a.name是一个对象的引用，而不是一个字符串，那么上面的代码也会遇到一些问题，参考如下代码： 12345var a = &#123;name:&#123;firstName:'wang',lastName:'er'&#125;&#125;var b = Object.assign(&#123;&#125;, a)a===b // falseb.name.firstName = 'zhang'a.name.firstName //'zhang' b.name.firstName又影响到了a.name.firstName，这是因为Object.assign()方法只是浅层拷贝，a.name是一个栈对象的引用，赋值给b时，b.name也同样是这个栈对象的引用，很多时候，我们不想让这种事情发生，所以我们就需要用到对象的深拷贝。 二、使用JSON.parse（）与JSON.stringify（）对对象进行拷贝通常情况下，我们可以使用JSON.parse（）与 JSON.stringify（）实现对象的深克隆，如下： 123var clone = function (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; 这种方法只适用于纯数据json对象的深度克隆，因为有些时候，这种方法也有缺陷，参考如下代码： 12345var clone = function (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var a = &#123;a:function()&#123;console.log('hello world')&#125;,b:&#123;c:1&#125;,c:[1,2,3],d:"wanger",e:new Date(),f:null,g:undefined&#125;var b = clone(a) 打印如下：我们发现，上述的方法会忽略值为function以及undefied的字段，而且对date类型的支持也不太友好。 更要紧的是，上述方法只能克隆原始对象自身的值，不能克隆它继承的值，参考如下代码： 1234567function Person (name) &#123; this.name = name&#125;var wanger = new Person('王二')var newwanger = clone(wanger)wanger.constructor === Person // truenewwanger.constructor === Object // true 打印如下： 我们发现，克隆的对象的构造函数已经变成了Object,而原来的对象的构造是Person。 三、目前没有发现bug的对象深拷贝方法王二在网上参考了不少文章，方法都不尽完美，于是在前人基础上改造了一下，方法如下，目前没有发现有什么bug： 12345678910111213var clone = function (obj) &#123; if(obj === null) return null if(typeof obj !== 'object') return obj; if(obj.constructor===Date) return new Date(obj); var newObj = new obj.constructor (); //保持继承链 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //不遍历其原型链上的属性 var val = obj[key]; newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合 &#125; &#125; return newObj; &#125;; 这里有三点需要注意：1、用new obj.constructor ()构造函数新建一个空的对象，而不是使用{}或者[],这样可以保持原形链的继承；2、用obj.hasOwnProperty(key)来判断属性是否来自原型链上，因为for..in..也会遍历其原型链上的可枚举属性。3、上面的函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 arguments.callee。 2017-10-03添加，之前没有考虑正则对象的问题，这里做一下修改： 1234567891011121314var clone = function (obj) &#123; if(obj === null) return null if(typeof obj !== 'object') return obj; if(obj.constructor===Date) return new Date(obj); if(obj.constructor === RegExp) return new RegExp(obj); var newObj = new obj.constructor (); //保持继承链 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //不遍历其原型链上的属性 var val = obj[key]; newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合 &#125; &#125; return newObj; &#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中apply、call、bind的用法]]></title>
    <url>%2F2017%2F09%2F20%2FJS%E4%B8%ADapply%E3%80%81call%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[apply()和call()都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）,bind()会创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 一、了解apply()的作用1、先来一个实例123456789var wanger = &#123; name: '王二', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;wanger.age(); // 17年调用是22,18年调用就变成23了 上面的对象定义了一个wanger对象，里面有个age方法，当调用age方法时，就可以得到王二的年龄；这时候，下面又来了一个张三:1234var zhangsan = &#123; name: '张三', birth: 1992,&#125;; 他没有age方法，但他也想知道自己的年龄，那该怎么办呢？或许我们可以借用王二的age方法来帮助张三知道自己的年龄，这时候，apply()就能帮到我们：1wanger.age.apply(zhangsan); //17年调用是25,18年调用就变成26了 上面apply()中的zhangsan成功地调用到了wanger的age方法。 在MDN中，是这么解释apply方法的： 在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 二、apply()与call()的区别 call()方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组 王二和张三要获得期末考试语文和数学加起来的成绩，如下代码所示：1234567891011var wanger = &#123; name: '王二', score: function (x,y) &#123; return x+y ; &#125;&#125;;var zhangsan = &#123; name: '张三',&#125;;wanger.score.apply(zhangsan,[100,98]); //198wanger.score.call(zhangsan,100,98); //198 以上两种方法都能获得张三的成绩； 两个方法用途差不多，为什么还要分成两个方法呢？还有那个谁，对，apply,还要放个数组进去，累不累啊？ 但是设计者这样设计是有用途的，参考如下代码： 1234567891011121314var wanger = &#123; name: '王二', score: function () &#123; return [...arguments].reduce((x,y)=&gt;x+y) ; //获得传入成绩的总和 &#125;&#125;;var zhangsan = &#123; name: '张三',&#125;;wanger.score.apply(zhangsan,[100,98,95]); //293wanger.score.call(zhangsan,100,98,95); //293wanger.score.apply(zhangsan,[100,98,95,96]); //389wanger.score.call(zhangsan,100,98,95,96); //389 当传入的的参数的值不固定时，call()的灵活性就明显不如apply()了，apply()只要传一个数组就搞定了。 三、bind()是干什么用的在MDN中，是这么解释bind方法的： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 可以参考如下代码：1234567891011121314var wanger = &#123; name: '王二', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;var zhangsan = &#123; name: '张三', birth: 1992,&#125;;var getAge = wanger.age.bind(zhangsan); getAge() ; 这里bind()与call(),apply()有一个重要的区别：bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 四、总结 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 参考文献：MDN web docs廖雪峰的官方网站“chokcoco”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解原型链]]></title>
    <url>%2F2017%2F09%2F18%2F%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在JS中，原型链有时候让人觉得很胡里花哨，又是prototype、__proto__又是各种指向什么的，让人觉得很头疼。如果你也有这种感觉，或许这篇文章可以帮助到你 一、认识原型1、先来一串代码 123456789var Person = function(msg)&#123; this.msg = msg;&#125;var person1 = new Person("wanger")person1.constructor===Person; //truePerson === Person.prototype.constructor; //trueperson1.__proto__ === Person.prototype; //trueperson1.__proto__.constructor === person1.constructor //true 看晕了吧？是不是很胡里花哨？不用担心，其实一张图就能了明白这其中的关系： 蓝色的是构造函数 绿色的是构造函数实例出来的对象 橙色的是构造函数的prototype,也是构造函数实例出来的对象的原型（它其实也是一个对象） 2、这里特别要注意的是prototype与__proto__的区别，prototype是函数才有的属性，而__proto__是每个对象都有的属性。(__proto__不是一个规范属性，只是部分浏览器实现了此属性，对应的标准属性是[[Prototype]])。 二、认识原型链1、我们刚刚了解了原型，那原型链在哪儿呢？不要着急，再上一张图： 通过这张图我们可以了解到,person1的原型链是： person1 —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 2、事实上，函数也是一个对象，所以，Person的原型链是： Person —-&gt; Function.prototype —-&gt; Object.prototype —-&gt; null 由于Function.prototype定义了apply()等方法，因此，Person就可以调用apply()方法。 3、如果把原型链的关系都显示清楚，那会复杂一些，如下图： 这里需要特别注意的是：所有函数的原型都是Function.prototype,包括Function构造函数和Object构造函数（如图中的标红部分） 三、原型链的继承1、假设我们要基于Person扩展出Student，Student的构造如下：12345function Student(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Person构造函数不等于继承了Person，Student创建的对象的原型是： new Student() —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null 示意图如下所示： 必须想办法把原型链修改为： new Student() —-&gt; Student.prototype —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 示意图如下所示： 那我们应该怎么修改呢？仔细观察两张图的差异，我们会发现，如果我们将Student的prototype改成person1对象不就大功告成了？于是有了下面的代码： 1Student.prototype = person1 ; 但是这时候有个问题:1Student.prototype.constructor === Student; //false 原来Student.prototype(即person1)的constructor指向的还是Person，这时候还需要我们再改一下代码：1Student.prototype.constructor = Student; 这样就能把Student的原型链顺利的修改为： new Student() —-&gt; Student.prototype —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 了； 完整的代码显示如下：1234567891011var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;var person1 = new Person("wanger")Student.prototype = person1 ;Student.prototype.constructor = Student; 三、用以上原型链继承带来的问题1、如果在控制台执行一遍上述的代码，我们会发现一些问题，如图所示： Student.prototype上含有之前person1带有的属性，那么，这样的继承的方法就显得不那么完美了 2、这个时候，我们可以借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Person.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Person.prototype:F.prototype = Person.prototype;// 把Student的原型指向一个新的F对象，F对象的原型正好指向Person.prototype:Student.prototype = new F();// 把Student原型的构造函数修复为Student:Student.prototype.constructor = Student;// 继续在Student原型（就是new F()对象）上定义方法：Student.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建wanger:var wanger = new Student(&#123; name: '王二', grade: 9&#125;);wanger.msg; // '王二'wanger.grade; // 9// 验证原型:wanger.__proto__ === Student.prototype; // truewanger.__proto__.__proto__ === Person.prototype; // true// 验证继承关系:wanger instanceof Student; // truewanger instanceof Person; // true 这其中主要用到了一个空函数F作为过桥函数。为什么道爷会用过桥函数？用过桥函数F(){}主要是为了清空构造的属性。如果有些原Person的构造用不到，那么过桥函数将是一个好的解决方案 这样写的话，Student.prototype上就没有任何自带的私有属性，这是理想的继承的方法 3、如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 123456function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 封装后，写起来就像这样：123456789var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;inherits(Student,Person) ; 这样再一封装的话，代码就很完美了。 事实上，我们也可以在inherits中使用Object.create()来进行操作，代码如下：1234function inherits(Child, Parent) &#123; Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;&#125; 如果有兴趣了解Object.create()的其他用法，可以参考我的这篇博客JS中Object.create的使用方法; 四、ES6的新关键字class在ES6中，新的关键字class，extends被正式被引入，它采用的类似java的继承写法，写起来就像这样：123456789class Student extends Person &#123; constructor(name, grade) &#123; super(msg); // 记得用super调用父类的构造方法! this.grade = grade || 1; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 这样写的话会更通俗易懂，继承也相当方便。读者可以进入廖雪峰的官方网站详细了解class的用法 参考文献：廖雪峰的官方网站]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vue-cli 中用 proxyTable 解决开发环境的跨域问题]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%9C%A8-vue-cli-%E4%B8%AD%E7%94%A8-proxyTable-%E8%A7%A3%E5%86%B3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端开发工程中难免会遇到跨域问题，如果你用的是vue，不要担心，官方手脚架早已帮你准备好了解决方案 如果读者还不太了解 vue-cil , 或许vue-cil文档可以帮助到你 , 事实上,文档中就有用 proxyTable 进行代理请求的相关介绍 关键代码在 config/index.js 写下以下关键代码 ： 12345678910111213141516// config/index.jsmodule.exports = &#123; // ... dev: &#123; proxyTable: &#123; // proxy all requests starting with /api to jsonplaceholder '/api': &#123; target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125; 上面的示例将代理请求 /api/posts/test 到 http://jsonplaceholder.typicode.com/posts/test 实际开发中的配置王二在开发中进行的如下的配置： 123456789proxyTable: &#123; "/middleware": &#123; target: "http://192.168.2.57:80", pathRewrite: &#123; '^/middleware': '/patient/1070/middleware' &#125;, changeOrigin: true, &#125;&#125;, 这样就会将代理请求 /middleware/balabala 到 http://192.168.2.57:80/patient/1070/middleware/balabala 需要注意的是，这这种代理请求只适用于开发环境，其背后的设置来自于其使用的插件http-proxy-middleware，有兴趣可以了解了解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS验证身份证的合法性]]></title>
    <url>%2F2017%2F09%2F12%2Fjs%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%2F</url>
    <content type="text"><![CDATA[最近公司业务需求需要验证身份证的合法性，以下分享一个可以判断身份合法性的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function IdentityCodeValid(code) &#123; function cap (str)&#123; //如果身份证验证中有x,则变为X再做判断； var temp = str.split(""); temp.forEach(function(i,index)&#123;if(i==='x')&#123;temp[index]="X"&#125;&#125;);return temp.join(""); &#125; var code = cap(code); var copycode = code ; var city=&#123;11:"北京",12:"天津",13:"河北",14:"山西",15:"内蒙古",21:"辽宁",22:"吉林",23:"黑龙江 ",31:"上海",32:"江苏",33:"浙江",34:"安徽",35:"福建",36:"江西",37:"山东",41:"河南",42:"湖北 ",43:"湖南",44:"广东",45:"广西",46:"海南",50:"重庆",51:"四川",52:"贵州",53:"云南",54:"西藏 ",61:"陕西",62:"甘肃",63:"青海",64:"宁夏",65:"新疆",71:"台湾",81:"香港",82:"澳门",91:"国外 "&#125;; var tip = ""; var pass= true; if(!code || !/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/i.test(code))&#123; tip = "身份证号格式错误"; pass = false; &#125; else if(!city[code.substr(0,2)])&#123; tip = "地址编码错误"; pass = false; &#125; else&#123; //18位身份证需要验证最后一位校验位 if(code.length == 18)&#123; code = code.split(''); //∑(ai×Wi)(mod 11) //加权因子 var factor = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ]; //校验位 var parity = [ 1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2 ]; var sum = 0; var ai = 0; var wi = 0; for (var i = 0; i &lt; 17; i++) &#123; ai = code[i]; wi = factor[i]; sum += ai * wi; &#125; var last = parity[sum % 11]; if(parity[sum % 11] != code[17])&#123; tip = "校验位错误"; pass =false; &#125; &#125; &#125; //判断出生日期是否合法 function check(date)&#123; //date 传 例如：2013-01-01、2013/01/01、2013/01/32、2013/02/29 return (new Date(date).getDate()==date.substring(date.length-2)); &#125; function getDate(code)&#123; //得到类似2013-01-01、2013/01/01、2013/01/32、2013/02/29的日期格式 var date = '' ; if(code.length===18)&#123; date = code.substring(6,14) &#125;else if(code.length===15)&#123; date = '19'+code.substring(6,12) &#125;else&#123; return ''; &#125; date = date.substr(0,4)+'-'+date.substr(4,2)+'-'+date.substr(6,2); return date; &#125; if(!check(getDate(copycode)))&#123; pass = false ; tip = "日期格式不正确" &#125;// if(!pass) alert(tip); return pass;&#125; 参考文献“懒惰的肥兔”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的一般原理]]></title>
    <url>%2F2017%2F08%2F14%2Fjsonp%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器中，由于有 同源策略 的存在，ajax跨域请求数据往往失败，这时候JSONP或许会帮到我们 由于同源策略，一般来说位于server1.example.com的网页无法与不是 server1.example.com的服务器沟通,这时候Jsonp可以帮助我们进行跨域的数据交互,另一个解决这个问题的新方法是CORS，咱们今天主要聊聊Jsonp。 一、JSONP是怎么产生的1、由于同源策略的存在，Ajax直接请求数据存在跨域无权限访问的问题。2、但我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 二、JSONP的客户端具体实现不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现： 1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。远程服务器remoteserver.com根目录下有个remote.js文件代码如下：1alert('我是远程文件'); 本地服务器localserver.com下有个jsonp.html页面代码如下：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。远程服务器remoteserver.com根目录下remote.js文件代码如下：1localHandler(&#123;"result":"我是远程js带来的数据"&#125;); 本地服务器localserver.com下jsonp.html页面代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; var localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;; &lt;/script&gt; &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。看jsonp.html页面的代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：12345flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这里没有写flightHandler这个函数，但是也运行成功了，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时自动帮你生成回调函数并把数据取出来供success属性方法来调用。 三、其他注意点1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 文章转载自“随它去吧”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将特殊英文字符转为中文字符]]></title>
    <url>%2F2017%2F08%2F14%2F%E5%B0%86%E7%89%B9%E6%AE%8A%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B8%BA%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[有时候将前台的数据传到后台，再从后台读取时，由于有特殊英文字符，会出现json转为对象出错的情况，这时候，一种解决方案就是在传到后台之前，将特殊的英文字符转为中文字符 以下是一个英文字符转为中文字符的简单方法 1234function replaceSpecialJson(str)&#123; var res = str.replace(/\"/g,"“").replace(/\[/g,"【").replace(/\]/g,"】").replace(/\&#123;/g,"｛").replace(/\&#125;/g,"｝") ; return res ;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解事件冒泡]]></title>
    <url>%2F2017%2F08%2F14%2F%E4%BA%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[事件冒泡是前端er经常会遇到的问题，那在这里我们来用简短的代码来了解一下到底什么是事件冒泡 在这里我们主要讨论 event.stopPropagation() 与 event.preventDefault() 的区别，先来一段可执行的代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;div onclick="alert('我是最外层-1');"&gt; &lt;div onclick="alert('我是中间层-1');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-1');" id="test1"&gt;点击我-1&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div onclick="alert('我是最外层-2');"&gt; &lt;div onclick="alert('我是中间层-2');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-2');" id="test2"&gt;点击我-2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div onclick="alert('我是最外层-3');"&gt; &lt;div onclick="alert('我是中间层-3');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-3');" id="test3"&gt;点击我-3&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;script&gt; $("#test1").click(function(event) &#123; event.stopPropagation(); &#125;); $("#test2").click(function(event) &#123; event.preventDefault(); &#125;); $("#test3").click(function(event) &#123; return false ; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; event.stopPropagation();事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转） event.preventDefault();如果把它放在头部A标签的click事件中，点击“点击我”。会发现它依次弹出：我是最里层—-我是中间层—-我是最外层，但最后却没有跳转到百度它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） return false;事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过FileReader将图片转为Base64编码]]></title>
    <url>%2F2017%2F08%2F14%2F%E9%80%9A%E8%BF%87FileReader%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BABase64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如果我们想将图片转为base64编码，可以通过H5的FileReader接口来达成目标 封装好的方法 1234567891011121314151617/*** @param &#123;string&#125; dom input[name='file']的dom对象* @param &#123;function&#125; fn 回调函数*/function get_base64(dom,fn) &#123; var file = dom.files[0]; if(!file) return ; if(!window.FileReader)&#123; console.log("当前浏览器不支持FileReader！"); return; &#125; r = new FileReader(); r.onload = function()&#123; if(fn) fn(r) ; &#125;; r.readAsDataURL(file);&#125; 再来一段可执行的html代码，大家可以动手试试哈 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input accept="image/*" id="upload_file" type="file"&gt; &lt;textarea id="base64_output" style="min-width:800px;min-height: 500px;"&gt;&lt;/textarea&gt; &lt;script type="text/javascript"&gt; function $_(id) &#123; return document.getElementById(id); &#125; $_("upload_file").onchange = function () &#123; var dom = $_('upload_file'); get_base64(dom,function(r)&#123; $_('base64_output').value = r.result; &#125;); &#125;; function get_base64(dom,fn) &#123; var file = dom.files[0]; if(!file) return ; if(!window.FileReader)&#123; console.log("当前浏览器不支持FileReader！"); return; &#125; r = new FileReader(); r.onload = function()&#123; if(fn) fn(r) ; &#125;; r.readAsDataURL(file); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高亮文本里的关键字]]></title>
    <url>%2F2017%2F08%2F14%2F%E9%AB%98%E4%BA%AE%E6%96%87%E6%9C%AC%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[如何高亮html代码里的关键字？下面的方法或许能帮到你 封装好的方法 12345678910111213141516171819202122/*** @param &#123;string&#125; data 要搜索的文本* @param &#123;string&#125; key 要高亮的关键词* @param &#123;string&#125; bgColor 背景颜色，默认orange*/function keyLight(data, key, bgColor)&#123; var sText = data ; bgColor = bgColor || "orange", sKey = "&lt;span style='background-color: "+bgColor+";'&gt;"+key+"&lt;/span&gt;", num = -1, rStr = new RegExp(key, "g"), rHtml = new RegExp("\&lt;.*?\&gt;","ig"), //匹配html元素 aHtml = sText.match(rHtml); //存放html元素的数组 sText = sText.replace(rHtml, '&#123;~&#125;'); //替换html标签 sText = sText.replace(rStr,sKey); //替换key sText = sText.replace(/&#123;~&#125;/g,function()&#123; //恢复html标签 num++; return aHtml[num]; &#125;); return sText;&#125; 再来一段可执行的html代码，大家可以动手试试哈 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;div&gt;测试一&lt;/div&gt; &lt;div&gt;测试二&lt;/div&gt; &lt;div&gt;测试三&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function keyLight(data, key, bgColor)&#123; var sText = data ; bgColor = bgColor || "orange", sKey = "&lt;span style='background-color: "+bgColor+";'&gt;"+key+"&lt;/span&gt;", num = -1, rStr = new RegExp(key, "g"), rHtml = new RegExp("\&lt;.*?\&gt;","ig"), //匹配html元素 aHtml = sText.match(rHtml); //存放html元素的数组 sText = sText.replace(rHtml, '&#123;~&#125;'); //替换html标签 sText = sText.replace(rStr,sKey); //替换key sText = sText.replace(/&#123;~&#125;/g,function()&#123; //恢复html标签 num++; return aHtml[num]; &#125;); return sText; &#125; var html = document.getElementById("test").innerHTML ; document.getElementById("test").innerHTML = keyLight(html,'试') ; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解ES6中的Promise]]></title>
    <url>%2F2017%2F08%2F10%2F%E7%90%86%E8%A7%A3ES6%E4%B8%AD%E7%9A%84Promise%2F</url>
    <content type="text"><![CDATA[在ES6中，Promise被列为正式规范，Promise可以规范化回调，避免回调地狱 一、Promise的作用在ajax请求数据的过程中，我们可以异步拿到我们想要的数据，然后在回调中做相应的数据处理。这样做看上去并没有什么麻烦，但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就需要在回调函数中再写一个异步请求，然后在这个异步函数的回调函数里在写相应的数据处理。要是连续嵌套个三四层，往往就很恶心了。写起来就像下面这样：12345678910111213141516171819202122232425$.ajax(&#123; type:'get', url:'url_1', data: 'data' success : function(res)&#123; //相应的数据处理 var data = res.data $.ajax(&#123; type:'get', url:'url_2', data: data success : function(res)&#123; //相应的数据处理 $.ajax(&#123; type:'get', url:'url_3', data: data success : function(res)&#123; //相应的数据处理 &#125; &#125;) &#125; &#125;) &#125;&#125;) 在这种情况下Promise就能发挥它的威力了； 二、来一个实例先不谈语法，下面先来一个实例，建立感性的认识 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; function a(data)&#123; return new Promise(function(resolve,reject)&#123; console.log("我是从上一个回调函数里传过来的数据",data) ; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'http://api.money.126.net/data/feed/0000001,1399001', //jsonp跨域调用上证与深证的股票指数 data:&#123; &#125;, success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; console.log("Error:") ; console.log(res) ; reject(res) ; &#125; &#125;) &#125;); &#125; function b(data)&#123; return new Promise(function(resolve,reject)&#123; console.log("我是从上一个回调函数里传过来的数据",data) ; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'https://api.douban.com/v2/movie/top250', //跨域调用豆top250的电影 success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; console.log("Error:") ; console.log(res) ; reject(res) &#125; &#125;) &#125;); &#125; a().then(b).then(a).then(b).catch(function(a)&#123;console.log("final Error:",a)&#125;) ; &lt;/script&gt;&lt;/html&gt; 打印结果如下所示： 可以发现，Promise 通过简单的链式调用就能得到之前多层回调才能达成的效果;而且从代码的结构来看，有效地减小了各个请求之间的耦合; 三、深入Promise别的不谈，先打印一下 Promise , console.dir(Promise) , 看看它究竟是哪号人物： 原来 Promise 本身是一个构造函数，自己身上有 all、 reject、 resolve 这几个的方法，在其 prototype 上有 then 、 catch 这两个方法。那么用Promise new出来的对象也会有 then 、 catch 这两个方法。 四、注意上面实例中的resolve与reject1、我们发现，在 new Promise(function(resolve,reject){}) 里传了两个方法 resolve 、 reject 作为参数，这两个方法通常会在函数的回调里被用到。一旦执行到resolve() 或者 reject() ，那么这个函数会停止执行，然后触发后面的 then() 或者 catch() 方法。准确一点来说，执行到resolve() 会触发 then() 方法，执行到 reject() 会触发 catch() 方法。 2、resolve 和 reject 方法里可以传入参数 ，就像 resolve(data) 和 reject(data) 。 如果这样做 ，那么在后面的 then() 或者 catch() 里传入一个带参数的函数 ， 就像 then(function(data){}) 或者 catch(function(data){}) ， 就能得到 data 的数据 。 3、说的再专业一些，Promise 对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 这三种状态不受外界影响，而且状态只能从 pending 改变为 resolved 或者rejected ，并且不可逆。在 Promise 对象的构造函数中，resolve 和 reject 就是用来处理Promise的状态变化。一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 或者 catch 方法里面，而不应该直接写在 resolve() 或 reject() 的后面 (事实的情况是，resolve() 或 reject() 的后面的代码也不会执行)。 五、new Promise() 里的函数是立刻执行的需要注意的的是，new Promise() 里的函数是立刻执行的 ，也就是说 ，当你执行下面这段代码时，就已经开始执行异步请求了： 123456789101112131415161718&lt;script&gt;new Promise(function(resolve,reject)&#123; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'http://api.money.126.net/data/feed/0000001,1399001', data:&#123; &#125;, success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; reject(res) ; &#125; &#125;)&#125;);&lt;/script&gt; 这也是为什么，在上面第二段的实例中，需要用 a() 和 b() 函数把 new Promise() 给包起来 六、then() 函数的返回值一定是 Promise 对象还需要注意的的是，then() 函数的返回值一定是 Promise 对象，哪怕手动 return 一个值也无济于事，如下面的代码，照样能运行成功：1a().then(function ()&#123;console.log("hello");return 1&#125;).then(b) ; 这也解释了为什么我们可以链式调用 then() 函数。 七、Promise.all()与Promise.race()的用法想要从两个不同的 ajax 请求里分别获得信息，这两个任务是可以并行执行的，就可以用 Promise.all() 实现： 123456789101112131415161718&lt;script&gt;var p1 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;var p2 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;// 同时执行p1和p2，并在它们都完成后执行thenvar start = function()&#123; Promise.all([p1(), p2()]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2'] &#125;);&#125;&lt;/script&gt; 有些时候，多个异步任务是为了容错。比如，分别发两个不同的 ajax 请求读取用户的个人信息，只需要获得先返回的结果即可，这种情况下，就可以用Promise.race() 实现： 1234567891011121314151617&lt;script&gt;var p1 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;var p2 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;var start = function()&#123; Promise.all([p1(), p2()]).then(function (results) &#123; console.log(results); // 'P1' &#125;);&#125;&lt;/script&gt; 由于 p1 执行较快，Promise 的 then() 将获得结果 &#39;P1&#39; 。 p2 仍在继续执行，但执行结果将被丢弃。 如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。 参考文献：阮一峰ES6入门廖雪峰的官方网站sitepoint“吕大豹”的博客园]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webApp调用百度地图API获取当前位置以及其他的一些操作]]></title>
    <url>%2F2017%2F08%2F09%2FwebApp%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近公司有业务需求，需要获得当前位置与各个医院的距离，在这里我主要调用百度地图的API接口，以下做一个总结 一、先上一个简单的实例1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;HTML5调用百度地图API&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=GG3pK0aFOLuRioYyTFhG75tOD2hBZ0CG"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style="margin:50px 10px;"&gt; &lt;div style="width:600px;height:480px;border:1px solid gray;margin:30px auto" id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; /** * 写了一个map方法用以调出地图 * @param &#123;number&#125; x 经度 * @param &#123;number&#125; y 纬度，这个例子里写的是上海的经纬度 * @param &#123;String&#125; dom 要渲染的dom的id * @param &#123;Object&#125; size 地图的放大级别，范围0-19 */ function map(x,y,dom,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); &#125; map(121.48789949,31.24916171,"container"); &lt;/script&gt;&lt;/html&gt; 其中需要注意的是引用的 script 标签里的 GG3pK0aFOLuRioYyTFhG75tOD2hBZ0CG 这个秘钥是需要自己注册申请的，这里给一个注册的传送门，当然在测试中使用王二的这个秘钥也没有关系 二、并不一定需要经纬度，地名也是OK的将上面代码的第22行换成如下试试： 1map.centerAndZoom("南京",15); //中心点坐标可以是经纬度，也可以是地名 三、有时候我们需要一个标注，如下图所示 这时候可以在插入两行代码： 12var marker = new BMap.Marker(point); // 创建标注map.addOverlay(marker); // 将标注添加到地图中 写完整起来就像这样：12345678function map(x,y,dom,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); var marker = new BMap.Marker(point); map.addOverlay(marker);&#125;map(121.48789949,31.24916171,"container"); 四、有时候我们还需要一个标签，如下图所示 这时候可以插入如下的代码： 12345678910111213141516var label = new BMap.Label("上海浦西", &#123; //新建一个标签，并设置标签文本 offset: new BMap.Size(15, -25) //设置标签的偏移量&#125;);label.setStyle(&#123; //为标签设置样式 width: "80px", color: '#fff', background: '#ff8355', border: '1px solid "#ff8355"', borderRadius: "5px", textAlign: "center", height: "26px", lineHeight: "26px"&#125;);marker.setLabel(label); // 为标注添加一个标签 写成方法就像下面这样：12345678910111213141516171819202122function map(x,y,dom,text,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); var label = new BMap.Label(text, &#123; offset: new BMap.Size(15, -25) &#125;); label.setStyle(&#123; width: "80px", color: '#fff', background: '#ff8355', border: '1px solid "#ff8355"', borderRadius: "5px", textAlign: "center", height: "26px", lineHeight: "26px" &#125;); var marker = new BMap.Marker(point); marker.setLabel(label); map.addOverlay(marker);&#125;map(121.48789949,31.24916171,"container","上海浦西"); 五、获取当前的经纬度获取当前的经纬度直接调用下面这个方法就好了：123456789101112function getCurrentPosition() &#123; var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(r)&#123; //回调函数里有当前经纬度的信息 if(this.getStatus() == BMAP_STATUS_SUCCESS)&#123; console.log(r.point) ; &#125; else &#123; alert('failed:'+this.getStatus()); &#125; &#125;)&#125;getCurrentPosition() ; 不过回调的时间会长一些，2s左右 六、通过两地的经纬度获取两地的距离这里用到了一些数学和地理知识：12345678910function distance (start,end) &#123; // var x1 = (Math.PI/180)*start.y; var x2 = (Math.PI/180)*end.y; var y1 = (Math.PI/180)*start.x; var y2 = (Math.PI/180)*end.x; var R = 6371 ; //地球半径 var dis = Math.acos(Math.sin(x1)*Math.sin(x2)+Math.cos(x1)*Math.cos(x2)*Math.cos(y2-y1))*R; return dis.toFixed(2) ; //四舍五入保留两位小数，返回string类型&#125;distance(&#123;x:0,y:0&#125;,&#123;x:0,y:1&#125;) //算出经度为0，纬度为0 与 经度为0，纬度为1 两点之间的距离 七、百度地图API其他的一些功能，例如搜索、给出出行路线12345678910111213141516171819202122232425262728//创建信息窗口对象var infoWindow = new BMap.InfoWindow("I am here");map.openInfoWindow(infoWindow,point);//在地图中添加折线var polyline = new BMap.Polyline([ new BMap.Point(x,y), new BMap.Point(x+0.01,y+0.01) ],&#123;strokeColor:"blue", strokeWeight:6, strokeOpacity:0.5&#125;);map.addOverlay(polyline); //在地图中添加搜索功能var local = new BMap.LocalSearch(map, &#123; renderOptions:&#123; map: map &#125;&#125;);local.search("天安门");//给出地图的路线var driving = new BMap.DrivingRoute(map, &#123; renderOptions: &#123; map: map, autoViewport: true &#125;&#125;);driving.search("中关村", "天安门"); 感兴趣的话可以尝试一下，时间有限，回家睡觉，就不一一列举了。 2017-09-16 增 需要注意的的是，如在本地起服务器，地址是localhost的话，有时候会定位失败。这时候可以尝试把localhost换成本机的IP地址再试一下。 参考文献百度地图API文档许鸿飞的博客“莫水千留”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>百度地图API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat服务器配置虚拟目录]]></title>
    <url>%2F2017%2F08%2F09%2FTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前两天配置Tomcat服务器老是起不起来，后来在孙老板的帮助下配置成功，这里做一个备忘 1、如何配置虚拟目录？ 找到 Tomcat 所在的文件目录，在其下有一个 bin\server.xml 文件,在 &lt;Host&gt;&lt;/Host&gt; 里的最后一行，加入如下代码 1&lt;Context path="/" docBase="C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\app"/&gt; 写完整了就像这样： 1234567&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="/" docBase="C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\app"/&gt;&lt;/Host&gt; 其中的 docBase 的值就是要配的虚拟目录，注意要写成绝对路径,另外要注意的就是字符串要做转义处理 \ 转义成 \\ 2、如果起不起来怎么办？这时候 log 文件夹下的日志或许能帮助我们了解到底报了什么错。很多情况下报错的原因是端口被暂用，这时候只要在 server.xml 下改一下相应的端口号就好啦！ 需要注意的是，server.xml 下配置不止一个端口号，有时候改了只改了一个端口号，可能仍然会报错，这时候就要修改其他被占用的端口号。 想要了解tomcat各个端口的实际意义，可以参考以下链接 “风的脚步”的CSDN博客]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>后台备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JS获得浏览器的各种高度与宽度]]></title>
    <url>%2F2017%2F08%2F07%2F%E9%80%9A%E8%BF%87JS%E8%8E%B7%E5%BE%97%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E5%BA%A6%E4%B8%8E%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[浏览器的窗口的大小可以通过 document 和 window 提供的一系列属性来获得 123456789101112131415161718192021222324252627282930313233343536 /* 网页可见区域宽：document.body.clientWidth 网页可见区域高：document.body.clientHeight 网页可见区域宽：document.body.offsetWidth (包括边线的宽) 网页可见区域高：document.body.offsetHeight (包括边线的宽)(注意不是浏览器窗口的高度) dom元素相对于其父定位元素顶部的距离：dom.offsetTop (dom为dom对象的引用)(包括边线的宽) dom元素相对于其父定位元素左边的距离：dom.offsetLeft (dom为dom对象的引用)(包括边线的宽) 网页正文全文宽：document.body.scrollWidth 网页正文全文高：document.body.scrollHeight (注意不是浏览器窗口的高度) 网页被卷去的高：document.body.scrollTop (is_writeable) 网页被卷去的左：document.body.scrollLeft (is_writeable) 网页正文部分上：window.screenTop(相对于桌面的高) 网页正文部分左：window.screenLeft(相对于桌面的左) 屏幕分辨率的高：window.screen.height 屏幕分辨率的宽：window.screen.width 屏幕可用工作区高度：window.screen.availHeight (相对于 屏幕分辨率的高 会把浏览器输入栏的高度去掉) 屏幕可用工作区宽度：window.screen.availWidth (似乎和 window.screen.width 的值一样)*/function Query () &#123; console.log("网页可见区域宽：document.body.clientWidth -&gt;"+document.body.clientWidth) ; console.log("网页可见区域高：document.body.clientHeight -&gt;"+document.body.clientHeight) ; console.log("网页可见区域宽：document.body.offsetWidth (包括边线的宽) -&gt;"+document.body.offsetWidth) ; console.log("网页可见区域高：document.body.offsetHeight (包括边线的宽) -&gt;"+document.body.offsetHeight) ; console.log("网页正文全文宽：document.body.scrollWidth -&gt;"+document.body.scrollWidth) ; console.log("网页正文全文高：document.body.scrollHeight -&gt;"+document.body.scrollHeight) ; console.log("网页被卷去的高：document.body.scrollTop -&gt;"+document.body.scrollTop ) ; console.log("网页被卷去的左：document.body.scrollLeft -&gt;"+document.body.scrollLeft ) ; console.log("网页正文部分上：window.screenTop -&gt;"+window.screenTop ) ; console.log("网页正文部分左：window.screenLeft -&gt;"+window.screenLeft) ; console.log("屏幕分辨率的高：window.screen.height -&gt;"+window.screen.height ) ; console.log("屏幕分辨率的宽：window.screen.width -&gt;"+window.screen.width ) ; console.log("屏幕可用工作区高度：window.screen.availHeight -&gt;"+window.screen.availHeight ) ; console.log("屏幕可用工作区宽度：window.screen.availWidth -&gt;"+window.screen.availWidth ) ;&#125;Query() ;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过css样式禁止事件&禁止图标]]></title>
    <url>%2F2017%2F08%2F07%2F%E9%80%9A%E8%BF%87csss%E6%A0%B7%E5%BC%8F%E7%A6%81%E6%AD%A2%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候，我们只想显示页面给用户看，而不想让用户有任何操作，这时候，在css中写入样式 pointer-events:none 就能达到想要的效果 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .test1&#123; cursor: not-allowed; &#125; .test2&#123; pointer-events:none; &#125; .test3&#123; cursor: not-allowed; pointer-events:none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button class="test1" onclick="con()"&gt;按钮一&lt;/button&gt; &lt;button class="test2" onclick="con()"&gt;按钮二&lt;/button&gt; &lt;button class="test3" onclick="con()"&gt;按钮二&lt;/button&gt; &lt;br&gt; &lt;input class='test1' type='text' onclick="con()"/&gt; &lt;input class='test2' type='text' onclick="con()"/&gt; &lt;input class='test3' type='text' onclick="con()"/&gt; &lt;/body&gt; &lt;script&gt; function con()&#123; alert("show here!") ; &#125; &lt;/script&gt;&lt;/html&gt; 不过需要注意的是，由于设置了 pointer-events:none 把所有点击事件全部禁掉了，所有的 cursor 也没有了,所以原本可以通过 cursor: not-allowed 显示的禁止图标也不会再显示了]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端备忘</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用闭包或者setInterval实现一个计时器]]></title>
    <url>%2F2017%2F08%2F07%2F%E7%94%A8%E9%97%AD%E5%8C%85%E6%88%96%E8%80%85setInterval%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在开发业务中，有时候需要手机获取验证码，一般情况下，在点击 获取验证码 后，会有一个60秒倒计时的需求，这时候可以用以下两个方法来实现 通过JS中的 闭包 的来实现，代码如下： 12345678910111213function countDown(time)&#123; var time = time||60 ; //默认60s倒计时 var fn = function()&#123; if(time&gt;0)&#123; setTimeout(fn,1000) ; console.log(time--+'s') ; &#125;else&#123; console.log('end') ; &#125; &#125;; return fn ;&#125;countDown()() ; //运行方法 也可以通过JS中的 setInterval 方法来实现，代码如下： 123456789101112function countDown(time)&#123; var time = time||10 ; var fn = setInterval(function()&#123; if(time&gt;0)&#123; console.log(time--+'s') ; &#125;else&#123; console.log('end') ; clearInterval(fn); &#125; &#125;,1000)&#125;countDown() ; //运行方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中查询URL字符串中的参数]]></title>
    <url>%2F2017%2F08%2F03%2FJS%E4%B8%AD%E6%9F%A5%E8%AF%A2URL%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[原生JS中的 location.search 可以返回从问号到 URL 末尾的所有内容，但是访问其中的每个字符串参数却很麻烦。这时候，可以创建一个函数，用以解析查询字符串 1234567891011121314151617181920212223242526function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, //在 for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到 args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这样getQueryStringArgs()方法就会返回包含所有URL参数的一个对象。 参考文献JavaScript高级程序设计（第3版）P207]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo设置博文置顶]]></title>
    <url>%2F2017%2F07%2F31%2Fhexo%E8%AE%BE%E7%BD%AE%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%2F</url>
    <content type="text"><![CDATA[有时候我们需要置顶自己的某篇博文，这时候我们可以手动修改node_moudles文件夹下的相关代码 修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为如下所示： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加相应的 top 值，数值越大文章就会越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 参考文献Moorez的简书]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
