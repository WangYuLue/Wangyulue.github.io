<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[一道有趣的算法面试题]]></title>
    <url>%2F2017%2F11%2F03%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84%E7%AE%97%E6%B3%95%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天面试时遇到一道算法题，挺有趣的，在这里做一个分享 一、问题描述问题：已知一个字符串，请以字典序写出它的所有排列组合。 例如：’asd’的所有排列组就是[“ads”, “asd”, “das”, “dsa”, “sad”, “sda”]； 规定：字符串由小写字母组成，且无重复 二、解决方案这是个典型的排列组合问题，对于长度为n的字符串，排列的数组的长度为n!个。我们可以用递归来解决此类问题，参考如下代码： 123456789101112131415function test (str)&#123; var str = str.split('').sort().join(''); var arr = []; function demo (str,i='')&#123; if(str.length===1)&#123; arr.push(i+str); return; &#125; for(var x=0;x&lt;str.length;x++)&#123; demo(str.substring(0,x)+str.substring(x+1),i+str[x]); &#125; &#125; demo(str); return arr ;&#125; 三、优化事实上，以上的递归算法有大量的重复计算，例如： 对于abcdefg字符串，当字符串前两位确定时，比如，前两位字母是是a、b，那么后5个字母cdefg的排列组合只要计算一次，再加上前面的两位字母就好了。 但是，在上面的算法中，当前面的两位字母是ab或者ba时，算法都重新计算了一次cdefg的排列组合，这显然是不合理的。 这时候需要设计一个缓存，来保存已经计算过的字符串。 遗憾的是，今天王二的智商下线，想了半天没有想出如何设计这个缓存，等智商重新上线再来想吧。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道有趣的canvas题目]]></title>
    <url>%2F2017%2F11%2F01%2F%E4%B8%80%E9%81%93%E6%9C%89%E8%B6%A3%E7%9A%84canvas%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[昨天收到一份笔试邮件，关于canvas的，平时canvas接触的比较少，在这里做一个记录 一、题目描述 1.屏幕中随机产生n个蓝色大小不一的气泡，坐标随机 2.红色气泡跟随鼠标移动 3.当红色气泡会与蓝色气泡发生碰撞效果(类似桌球) 4.红色气泡会被屏幕边缘阻挡 5.蓝色气泡左右屏上下屏互通 6.蓝色气泡的运动及互动行为请自由发挥 二、解决方法代码的实现如下： 如果想看显示的运行效果，可以使劲的戳这里 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; #canvas&#123; margin: 30px; border: 1px solid #000000; padding: 0; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;canvas id="canvas"&gt;&lt;/canvas&gt; &lt;script&gt; ! function() &#123; var the_canvas = document.getElementById('canvas'), //创建画布 context = the_canvas.getContext("2d"), blueBubble = new Image(), redBubble = new Image(), n = 20 , //蓝色泡泡的数量 arr = [], //储存蓝色泡泡的array maxRadius = 80, //泡泡的最大半径 minRadius = 40, //泡泡的最小半径 redBubbleRadius = 80, //红色泡泡的半径 canvasWidth = 800, //画布的宽度 canvasHeight = 600, //画布的高度 maxSpeed = 80 , //泡泡的最大速度（x,y向量坐标速度） minSpeed = 50 , //泡泡的最小速度（x,y向量坐标速度） current_point = &#123; x: null, //当前鼠标x y: null //当前鼠标y &#125;; //定时刷新方法 var refresh = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function(func) &#123; window.setTimeout(func, 1000/60); &#125;; init(); getBubbles(); //图片加载完成后，开始绘画 blueBubble.onload = function()&#123; drawBubble(); &#125;; //生成指定个蓝圈圈，外加一个红圈圈 function getBubbles()&#123; for(var i=0;i&lt;=n;i++)&#123; var obj ; if(i===n)&#123; obj = getBubble(redBubbleRadius) ; obj.type = 'red' ; /*这段代码的本意是防止在初始化时红圈圈与蓝圈圈以外重叠在一起， * 但是有了下面 momentum下两行特殊的处理代码，这一段代码已经没有必要了。*/ /* if(!noRepeat (obj,arr))&#123; i -- ; continue ; &#125; */ &#125;else&#123; obj = getBubble() ; &#125; arr.push(obj); &#125; &#125; //定义画布大小以及加载图片资源文件 function init()&#123; //定义画布大小 the_canvas.width = canvasWidth || window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth; the_canvas.height = canvasHeight || window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight; //加载泡泡 blueBubble.src = './img/blue-bubble.png'; redBubble.src = './img/red-bubble.png'; &#125; //随机生成小圆圈的方法，传入一个半径，如果不传，则半径大小随机生成 function getBubble (radius) &#123; radius = radius || Math.round((Math.random()*(maxRadius-minRadius)+minRadius)/2); //圈圈的半径 var x = Math.round(Math.random()*(the_canvas.width-2*radius)+radius), //圈圈的x坐标 y = Math.round(Math.random()*(the_canvas.height-2*radius)+radius), //圈圈的y坐标 vx = Math.round(Math.random()*(maxSpeed-minSpeed)+minSpeed)*(Math.random()&gt;0.5?1:-1), vy = Math.round(Math.random()*(maxSpeed-minSpeed)+minSpeed)*(Math.random()&gt;0.5?1:-1); return &#123; radius : radius , x : x , y : y , vx : vx , vy : vy , type : 'blue' &#125;; &#125; //确定红圈的位置，不能与篮圈重叠 function noRepeat (a1,arr) &#123; for(var x=0;x&lt;arr.length;x++)&#123; var x_dist, y_dist, dist; x_dist = a1.x - arr[x].x; //x轴距离 l y_dist = a1.y - arr[x].y; //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist; //总距离的平方 if(dist&lt;=Math.pow(a1.radius+arr[x].radius,2)) return false ; &#125; return true ; &#125; //监听鼠标的位置 window.onmousemove = function(e) &#123; e = e || window.event; current_point.x = e.layerX; current_point.y = e.layerY; &#125;; //为了算这个动画我又拾起了高中的动量守恒定律 function momentum (a1,a2) &#123; var x_dist, y_dist, dist,m1,m2,vx1,vy1,vx2,vy2; x_dist = a1.x - a2.x; //x轴距离 l y_dist = a1.y - a2.y; //y轴距离 n dist = x_dist * x_dist + y_dist * y_dist; //总距离的平方 if(Math.pow(a1.radius+a2.radius,2)-dist&gt;0)&#123; /*下面两行的代码的作用是：防止红圈圈与蓝圈圈粘在一起； * 由于动画的刷新频率有限，当用鼠标移动红圈圈速度过快时， * 有可能红圈圈与蓝圈圈会重叠在一起，如果遇到这种情况，则把蓝圈圈移到红圈圈的外边*/ var temp = Math.sqrt(Math.pow(a1.radius+a2.radius,2)-y_dist * y_dist) ; a1.x - a2.x&gt;0?a1.x=a2.x+temp:a1.x=a2.x-temp ; /***end***/ m1 = Math.pow(a1.radius,2) ; m2 = Math.pow(a2.radius,2) ; vx1 = a1.vx ; vy1 = a1.vy ; vx2 = a2.vx ; vy2 = a2.vy ; a1.vx = ((m1-m2)*vx1+2*m2*vx2)/(m1+m2) ; a1.vy = ((m1-m2)*vy1+2*m2*vy2)/(m1+m2) ; a2.vx = (2*m1*vx1+(m2-m1)*vx2)/(m1+m2) ; a2.vy = (2*m1*vy1+(m2-m1)*vy2)/(m1+m2) ; &#125; &#125; //绘画的具体方法 function drawBubble()&#123; context.clearRect(0, 0, the_canvas.width, the_canvas.height); arr.forEach(function(item)&#123; item.x += item.vx/10 ; //移动速度太快了，这边除以个10 item.y += item.vy/10 ; if(item.type==='blue')&#123; item.x&gt;the_canvas.width &amp;&amp; (item.x-=the_canvas.width); item.x&lt;0 &amp;&amp; (item.x+=the_canvas.width); item.y&gt;the_canvas.height &amp;&amp; (item.y-=the_canvas.height); item.y&lt;0 &amp;&amp; (item.y+=the_canvas.height); context.drawImage(blueBubble, item.x-item.radius, item.y-item.radius, 2*item.radius, 2*item.radius); &#125; if(item.type==='red')&#123; arr.forEach(function(i)&#123; if(i.type==='blue')&#123; momentum(i,item); &#125; &#125;); item.vx *= item.x &gt; the_canvas.width-item.radius || item.x &lt; item.radius ? -1 : 1 ; item.vy *= item.y &gt; the_canvas.height-item.radius || item.y&lt; item.radius ? -1 : 1 ; if(current_point.x&gt;item.radius&amp;&amp;current_point.x&lt;the_canvas.width-item.radius&amp;&amp;current_point.y&gt;item.radius&amp;&amp;current_point.y&lt;the_canvas.height-item.radius)&#123; item.x = current_point.x; item.y = current_point.y; &#125; context.drawImage(redBubble, item.x-item.radius, item.y-item.radius, 2*item.radius, 2*item.radius); &#125; &#125;); refresh(drawBubble); &#125; &#125;() &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 这里需要特别特别感谢的是 canvas-nest 这个开源库,从它的源代码里王二得到了很多灵感。什么？ 你不知道这个开源库是干嘛用的，看见网站背景的炫酷小点点了吗？就是这个开源库写的。 三、遗留问题这里的小球球的碰撞后的轨迹需要二维弹性碰撞下的动量定理，而王二物理不太好，只学过一维弹性碰撞下的动量定理，所以王二在方法里用的是一维弹性碰撞下的动量定理。 所以你会发现小球之间的碰撞有那么一丝丝不符合物理常识。没办法，王二最近智商不太好，等王二智商好一点了再解决这个问题。 如果读者你是物理大神，赐教一下哈！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（六）]]></title>
    <url>%2F2017%2F11%2F01%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E5%85%AD%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python中文件的增删改读、操作目录、多进程、多线程中值得留意的地方。 一、读取文件如果想读取本地的文件，Python一行代码就能搞定： 1&gt;&gt;&gt; f = open('test.txt', 'r') 标示符&#39;r&#39;表示读，这样，我们就成功地打开了一个文件；如果文件不存在，Python会抛出一个错误； 调用read()方法可以一次读取文件的全部内容，Python把内容读到内存，用一个str对象表示： 12&gt;&gt;&gt; f.read()'Hello, world!' 最后需要用close()方法关闭文件，文件对象不关闭的话会占用操作系统的资源。 1&gt;&gt;&gt; f.close() 二、修改或新建文件写文件和读文件是一样的，唯一区别是调用open()函数时，传入标识符&#39;w&#39;表示写入文件： 123&gt;&gt;&gt; f = open('test.txt', 'w')&gt;&gt;&gt; f.write('Hello, wanger!')&gt;&gt;&gt; f.close() 如果没有test.txt文件，Python会为我们创建一个test.txt文件。 这里务必要调用f.close()来关闭文件。当我们写文件时，操作系统往往不会立刻把数据写入磁盘，而是放到内存缓存起来，空闲的时候再慢慢写入。只有调用close()方法时，操作系统才保证把没有写入的数据全部写入磁盘。 需要注意的是，当用 f = open(&#39;test.txt&#39;, &#39;w&#39;) 时， Python会把原来 &#39;test.txt&#39; 里的文件清除。 三、删除文件如果要删除文件，需要用到python的内建模块os，参考如下代码： 12&gt;&gt;&gt; import os&gt;&gt;&gt; os.remove('test.txt') 如果要删除的文件不存在，Python会抛出一个错误； 四、创建或删除目录如果要创建目录，可以使用mkdir()方法，参考如下代码： 12345&gt;&gt;&gt; import os#创建testdir目录&gt;&gt;&gt; os.mkdir('testdir')#删除testdir目录&gt;&gt;&gt; os.rmdir('testdir') 以上代码会相对于路径生成（删除）一个空的testdir文件夹，如果想相对于决绝路径创建目录，参考以下代码： 12345678910# 查看当前目录的绝对路径:&gt;&gt;&gt; os.path.abspath('.')'C:\\Users\\Administrator\\Desktop\\python'# 在某个目录下创建一个新目录，首先把新目录的完整路径表示出来:&gt;&gt;&gt; os.path.join('/Users/michael', 'testdir')'C:\\Users\\Administrator\\Desktop\\python\\testdir'# 然后创建一个目录:&gt;&gt;&gt; os.mkdir('C:\\Users\\Administrator\\Desktop\\python\\testdir')# 删掉一个目录:&gt;&gt;&gt; os.rmdir('C:\\Users\\Administrator\\Desktop\\python\\testdir') 这里需要通过os.path.join()函数来连接路径，因为不同操作系统的路径分隔符也有所不同，Linux/Unix/Mac下为/，Windows下为\。 五、多进程、多线程多进程、多线程这一块没有仔细看，等以后有实际用到在详细研究。 这里先留一个大致的印象：在CPU密集型任务下，多进程更快，或者说效果更好；而IO密集型，多线程能有效提高效率。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（五）]]></title>
    <url>%2F2017%2F10%2F30%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%BA%94%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python面向对象中类和实例、__init__方法、私有变量、继承、MixIn、判断对象类型、dir()、实例属性和类属性、__slots__方法、使用@property中值得留意的地方。 一、类和实例1、在Python中，定义类通过class关键字来实现： 12class Student(object): pass 定义好了Student类，就可以根据Student类创建出Student的实例，创建实例通过类名+()实现： 123&gt;&gt;&gt; bart = Student()&gt;&gt;&gt; bart&lt;__main__.Student object at 0x000001FECADEE128&gt; 二、__init__方法通过定义一个特殊的__init__方法，在创建实例的时候，我们可以把一些类的属性绑定上去，参考如下代码： 12345class Student(object): def __init__(self, name, score): self.name = name self.score = score 这时候我们的的学生就有了自己的名字与分数： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 59)&gt;&gt;&gt; bart.name'Bart Simpson'&gt;&gt;&gt; bart.score59 需要注意的是，__init__方法的第一个参数永远是self，表示创建的实例本身，因此，在__init__方法内部，就可以把各种属性绑定到self，因为self就指向创建的实例本身。 三、私有变量如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线__，在Python中，实例的变量名如果以__开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问，所以，我们把Student类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def print_score(self): print('%s: %s' % (self.__name, self.__score)) 改完后，对于外部代码来说，没什么变动，但是已经无法从外部访问实例变量.__name和实例变量.__score了： 12345&gt;&gt;&gt; bart = Student('Bart Simpson', 98)&gt;&gt;&gt; bart.__nameTraceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute '__name' 那就一定不能从外部访问了吗？其实也不是。不能直接访问__name是因为Python解释器对外把__name变量改成了_Student__name，所以，仍然可以通过_Student__name来访问__name变量，但是最好别这么干。 四、继承在上述的类Student中 : 12class Student(object): pass 我们注意到Stuedent中紧跟着一对括号，括号中是object，那么Student就是从object上继承下来的。 如果想定义两个或多个父类那该怎么办呢？也很简单，写上两个就好了： 123456789class Animal(object): passclass Runnable(object): def run(self): print('Running...')class Dog(Animal, Runnable): pass 五、MixIn在设计类的继承关系时，通常，主线都是单一继承下来的，例如，Ostrich继承自Bird。但是，如果需要“混入”额外的功能，通过多重继承就可以实现，比如，让Dog除了继承自Animal外，再同时继承Runnable。这种设计通常称之为MixIn。 MixIn的目的就是给一个类增加多个功能，这样，在设计类的时候，我们优先考虑通过多重继承来组合多个MixIn的功能，而不是设计多层次的复杂的继承关系。 个人认为MixIn的概念类似于Java中一个类可以添加多个接口这个概念。 六、判断对象类型我们可以使用type()、isinstance()来判断对象的类型，他们写起来就像这样： 123456789101112131415&gt;&gt;&gt; type(123)==type(456)True&gt;&gt;&gt; type(123)==intTrue&gt;&gt;&gt; type('abc')==type('123')True&gt;&gt;&gt; type('abc')==strTrue&gt;&gt;&gt; type('abc')==type(123)False&gt;&gt;&gt; isinstance('abc', str)True&gt;&gt;&gt; isinstance(123, int)True 七、使用dir()dir()这个函数算是惊艳到王二了，它返回一个包含字符串的list，获得一个传入对象的所有属性和方法： 12&gt;&gt;&gt; dir('ABC')['__add__', '__class__', '__contains__', '__delattr__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__getnewargs__', '__gt__', '__hash__', '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mod__', '__mul__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__rmod__', '__rmul__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', 'capitalize', 'casefold', 'center', 'count', 'encode', 'endswith', 'expandtabs', 'find', 'format', 'format_map', 'index', 'isalnum', 'isalpha', 'isdecimal', 'isdigit', 'isidentifier', 'islower', 'isnumeric', 'isprintable', 'isspace', 'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'maketrans', 'partition', 'replace', 'rfind', 'rindex', 'rjust', 'rpartition', 'rsplit', 'rstrip', 'split', 'splitlines', 'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper', 'zfill'] 当然，我们还可以通过getattr()、setattr()以及hasattr()来直接操作一个对象的状态。 八、实例属性和类属性在编码的时候，不要把实例属性和类属性使用相同的名字，因为相同名称的实例属性将屏蔽掉类属性，但是当你删除实例属性后，再使用相同的名称，访问到的将是类属性，参考如下代码： 12345678910111213141516&gt;&gt;&gt; class Student(object):... name = 'Student'...&gt;&gt;&gt; s = Student() # 创建实例s&gt;&gt;&gt; print(s.name) # 打印name属性，因为实例并没有name属性，所以会继续查找class的name属性Student&gt;&gt;&gt; print(Student.name) # 打印类的name属性Student&gt;&gt;&gt; s.name = 'Michael' # 给实例绑定name属性&gt;&gt;&gt; print(s.name) # 由于实例属性优先级比类属性高，因此，它会屏蔽掉类的name属性Michael&gt;&gt;&gt; print(Student.name) # 但是类属性并未消失，用Student.name仍然可以访问Student&gt;&gt;&gt; del s.name # 如果删除实例的name属性&gt;&gt;&gt; print(s.name) # 再次调用s.name，由于实例的name属性没有找到，类的name属性就显示出来了Student 九、使用__slots__如果我们想要限制实例的属性,可以使用__slots__，参考如下代码： 1234567891011class Student(object): __slots__ = ('name', 'age') # 用tuple定义允许绑定的属性名称#然后，我们试试&gt;&gt;&gt; s = Student() # 创建新的实例&gt;&gt;&gt; s.name = 'Michael' # 绑定属性'name'&gt;&gt;&gt; s.age = 25 # 绑定属性'age'&gt;&gt;&gt; s.score = 99 # 绑定属性'score'Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;AttributeError: 'Student' object has no attribute 'score' 由于&#39;score&#39;没有被放到__slots__中，所以不能绑定score属性，试图绑定score将得到AttributeError的错误。 使用__slots__要注意，__slots__定义的属性仅对当前类实例起作用，对继承的子类是不起作用的，除非在子类中也定义__slots__，这样，子类实例允许定义的属性就是自身的__slots__加上父类的__slots__。 十、使用@propertyPython内置的@property装饰器可以把一个方法变成属性调用，参考如下代码： 12345678910111213class Student(object): @property def score(self): return self._score @score.setter def score(self, value): if not isinstance(value, int): raise ValueError('score must be an integer!') if value &lt; 0 or value &gt; 100: raise ValueError('score must between 0 ~ 100!') self._score = value @property的实现比较复杂，我们先考察如何使用。把一个getter方法变成属性，只需要加上@property就可以了，此时，@property本身又创建了另一个装饰器@score.setter，负责把一个setter方法变成属性赋值，于是，我们就拥有一个可控的属性操作： 12345678&gt;&gt;&gt; s = Student()&gt;&gt;&gt; s.score = 60 # OK，实际转化为s.set_score(60)&gt;&gt;&gt; s.score # OK，实际转化为s.get_score()60&gt;&gt;&gt; s.score = 9999Traceback (most recent call last): ...ValueError: score must between 0 ~ 100! 如果只定义getter方法，不定义setter方法，那它就是一个只读属性。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sass学习小结]]></title>
    <url>%2F2017%2F10%2F30%2Fsass%E5%AD%A6%E4%B9%A0%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近有时间又看了一遍Sass的基础语法，这里主要记录了Sass基础语法中值得留意的地方，如果之前没有接触过sass，Sass 中文网的快速入门或许能帮助到你。 一、SCSS 与 Sass 异同SCSS 是 Sass3 引入新的语法，其语法完全兼容 CSS3，并且继承了 Sass 的强大功能。也就是说，任何标准的 CSS3 样式表都是具有相同语义的有效的 SCSS 文件。另外，SCSS 还能识别大部分 CSS hacks（一些 CSS 小技巧）和特定于浏览器的语法。 由于 SCSS 是 CSS 的扩展，因此，所有在 CSS 中正常工作的代码也能在 SCSS 中正常工作。也就是说，对于一个 Sass 用户，只需要理解 Sass 扩展部分如何工作的，就能完全理解 SCSS。大部分扩展，例如变量、parent references 和 指令都是一致的；唯一不同的是，SCSS 需要使用分号和花括号而不是换行和缩进。 例如，以下这段简单的 Sass 代码： 123#sidebar width: 30% background-color: #faa 只需添加花括号和分号就能转换为 SCSS 语法： 1234#sidebar &#123; width: 30%; background-color: #faa;&#125; 另外，SCSS 对空白符号不敏感。上面的代码也可以书写成下面的样子： 1#sidebar &#123;width: 30%; background-color: #faa&#125; 二、 变量名用中划线还是下划线？sass 并不想强迫任何人一定使用中划线或下划线，所以这两种用法相互兼容。用中划线声明的变量可以使用下划线的方式引用，反之亦然。这意味着即使 compass 选择用中划线的命名方式，这并不影响你在使用 compass 的样式中用下划线的命名方式进行引用： 12345678910$link-color: blue;a &#123; color: $link_color;&#125;//编译后a &#123; color: blue;&#125; 三、子组合选择器和同层组合选择器：&gt;、+和~这些组合选择器可以毫不费力地应用到sass的规则嵌套中。可以把它们放在外层选择器后边，或里层选择器前边： 123456789article &#123; ~ article &#123; border-top: 1px dashed #ccc &#125; &gt; section &#123; background: #eee &#125; dl &gt; &#123; dt &#123; color: #333 &#125; dd &#123; color: #555 &#125; &#125; nav + &amp; &#123; margin-top: 0 &#125;&#125; 四、静默注释sass另外提供了一种不同于css标准注释格式/* ... */的注释语法，即静默注释，其内容不会出现在生成的css文件中。静默注释的语法跟Java、ScriptJava等类 C 的语言中单行注释的语法相同，它们以 // 开头，注释内容直到行末: 1234body &#123; color: #333; // 这种注释内容不会出现在生成的css文件中 padding: 0; /* 这种注释内容会出现在生成的css文件中 */&#125; 五、混合器如果你的整个网站中有几处小小的样式类似（例如一致的颜色和字体），那么使用变量来统一处理这种情况是非常不错的选择。但是当你的样式变得越来越复杂，你需要大段大段的重用样式的代码，独立的变量就没办法应付这种情况了。你可以通过sass的混合器实现大段样式的重用。 混合器使用 @mixin 标识符定义,这个标识符给一大段样式赋予一个名字，这样你就可以轻易地通过引用这个名字重用这段样式。下边的这段 sass 代码，定义了一个非常简单的混合器，目的是添加跨浏览器的圆角边框。 12345@mixin rounded-corners &#123; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 然后就可以在你的样式表中通过 @include 来使用这个混合器，放在你希望的任何地方。@include 调用会把混合器中的所有样式提取出来放在 @include 被调用的地方。如果像下边这样写： 123456789101112131415notice &#123; background-color: green; border: 2px solid #00aa00; @include rounded-corners;&#125;//sass最终生成:.notice &#123; background-color: green; border: 2px solid #00aa00; -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;&#125; 当然，混合器也可以使用sass的各种规则，变量、嵌套，随便你用。 更令人兴奋地是， 我们还可以给混合器传参，来定制混合器生成的精确样式。用起来很向js的函数： 12345@mixin link-colors($normal, $hover, $visited) &#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 当混合器被 @include 时，你可以把它当作一个css函数来传参。如果你像下边这样写： 123456789a &#123; @include link-colors(blue, red, green);&#125;//Sass最终生成的是：a &#123; color: blue; &#125;a:hover &#123; color: red; &#125;a:visited &#123; color: green; &#125; 噢，对了，我们还可以为混合器设置默认参数，是不是觉得用上了JS的ES6语法。 参数默认值使用$name: default-value的声明形式，默认值可以是任何有效的css属性值，甚至是其他参数的引用，如下代码： 12345678910@mixin link-colors( $normal, $hover: $normal, $visited: $normal )&#123; color: $normal; &amp;:hover &#123; color: $hover; &#125; &amp;:visited &#123; color: $visited; &#125;&#125; 如果像下边这样调用：@include link-colors(red), $hover和$visited也会被自动赋值为red。 参考文档sass 中文网]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>sass</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp入门示例]]></title>
    <url>%2F2017%2F10%2F27%2Fgulp%E5%85%A5%E9%97%A8%E7%A4%BA%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[最近在学习Gulp,自己也整理了一些小demo,你可以访问demo-gulp来下载这些demo,整理这些demo目的是帮自己快速了解gulp的一些基本功能（检查js语法和风格、压缩js文件、合并js文件、编译sass文件，压缩css，热更新文件，浏览器实时刷新）,如果你也有这方面的需求，这篇示例教程或许能帮到你 一、安装 Gulp在全局安装gulp npm install -g gulp 二、基础介绍gulp非常简单，实际上，gulp本身只提供了4个基础的API，它的大部分功能都是通过插件来完成的，接下来简单的介绍下这四个基础的API， gulp.task(name [, deps, fn]) gulp.src(globs[, options]) gulp.dest(path[, options]) gulp.watch(glob [, opts], tasks) or gulp.watch(glob [, opts, cb]) 在这里先不解释这四个API的具体用处，因为解释也太流于表面，我们先来看一些实例，或许看完这些实例，我们就能了解这些API的具体作用了。 三、压缩js文件demo01向我们展示了如何创建一个压缩js的gulp任务。 首先，我们需要在项目的根目录下创建一个gulpfile.js文件，我们在文件中写下如下配置文件： 12345678var gulp = require('gulp'), uglify = require('gulp-uglify');gulp.task('minify', function () &#123; gulp.src('js/app.js') .pipe(uglify()) .pipe(gulp.dest('build'))&#125;); 以上代码一下子就使用到了gulp四个api中的三个，简单来说，gulp.task()会启动一个任务，gulp.src()会将你要处理的文件加载进来，gulp.dest()会将处理好的文件输出到指定位置。如果想了解这些api的具体细节，可以参考Culp 中文网。 如果你克隆下了这些demo,在命令行中桥下如下代码： cd demo01 //进入demo01子文件夹 npm install //加载依赖 gulp minify //运行minify这个任务 你就会发现在根目录下会多出一个build文件夹，里面有一个压缩好的app.js，这就是从gulp任务里生成的压缩代码。 四、检查js语法，压缩并合并js文件当然gulp能做的并不仅仅是压缩js文件，配合一些插件的使用，gulp还有更多的功能，参考demo02，在它的目录下我们发现有如下的配置文件： 12345678910111213var gulp = require('gulp'), uglify = require('gulp-uglify'); jshint = require('gulp-jshint'); concat = require('gulp-concat');gulp.task('dealJS', function () &#123; gulp.src('js/*.js') .pipe(jshint()) .pipe(jshint.reporter('default')) .pipe(uglify()) .pipe(concat('app.js')) .pipe(gulp.dest('build'));&#125;); 其中，jshint()会审查我们的代码风格，uglify()会压缩我们的文件，concat()会合并我们的文件。 需要注意的是，gulp的设计理念基于unix的pipe(流)思想，所以在编写构建任务代码更加简洁，也利于开发人员的维护和阅读。 与gulp对比的grunt,则将代码分成了grunt.initConfig（任务执行）、grunt.loadNpmTasks（引入模块）、grunt.registerTask（定义任务名称）三部分,写起来就像下面这样： 1234567891011121314151617181920212223module.exports = function(grunt) &#123; // Project configuration. grunt.initConfig(&#123; pkg: grunt.file.readJSON('package.json'), uglify: &#123; options: &#123; banner: '/*! &lt;%= pkg.name %&gt; &lt;%= grunt.template.today("yyyy-mm-dd") %&gt; */\n' &#125;, build: &#123; src: 'src/&lt;%= pkg.name %&gt;.js', dest: 'build/&lt;%= pkg.name %&gt;.min.js' &#125; &#125; &#125;); // 加载包含 "uglify" 任务的插件。 grunt.loadNpmTasks('grunt-contrib-uglify'); // 默认被执行的任务列表。 grunt.registerTask('default', ['uglify']);&#125;; 所以，单单从配置的容易程度，代码的可阅读性上来说，gulp是更加容易上手的。 五、编译sass并压缩cssgulp不仅仅能处理js，配合一些插件使用后，他还能处理css，例如demo03就可以编译sass并压缩css。 12345678910var gulp = require('gulp'), sass = require('gulp-sass'); minifyCSS = require('gulp-minify-css');gulp.task('dealCSS', function () &#123; gulp.src('scss/*.scss') .pipe(sass()) .pipe(minifyCSS()) .pipe(gulp.dest('build'))&#125;); 六、实时更新文件到现在，我们还有一个gulp的api没有用到————gulp.watch(),它可以监视文件，并且在文件发生改动时候做一些事情，参考demo04的配置文件： 12345678910111213var gulp = require('gulp'), uglify = require('gulp-uglify');gulp.task('minify', function () &#123; console.log("js文件夹里的文件正在重新编译...") gulp.src('js/*.js') .pipe(uglify()) .pipe(gulp.dest('build'))&#125;);gulp.task('watch', function () &#123; gulp.watch('js/*.js', ['minify']);&#125;); 启动watch任务后，每当js文件夹下的.js文件有变动时（变动代码未保存不算），就会触发minify文件，然后minify任务就会重新编译压缩js文件夹下的所有.js文件。 七、浏览器实时刷新虽然现在文件可以实时监听更新了，可是浏览器不会因为文件的变动而实时刷新，这时候我们可以借助gulp插件启动一个本地服务器来调试代码，参考demo05的配置文件： 12345678910111213141516171819202122232425var gulp = require('gulp'), sass = require('gulp-sass'); minifyCSS = require('gulp-minify-css'); connect = require('gulp-connect');gulp.task('dealCSS', function () &#123; gulp.src('scss/*.scss') .pipe(sass()) .pipe(minifyCSS()) .pipe(gulp.dest('build')) .pipe(connect.reload());&#125;);gulp.task('watch', function () &#123; gulp.watch('scss/*.scss', ['dealCSS']);&#125;);gulp.task('connect', function () &#123; connect.server(&#123; livereload: true &#125;);&#125;);gulp.task('livereload', [ 'connect', 'watch']); 启动livereload任务后，会触发另外两个任务connect与watch,其中connect会启动一个本地服务器，watch会监听scss文件夹下的.scss文件。在.scss文件发生变动后，watch任务会重新编译.scss文件，并触发connect.reload()方法，这个方法会让浏览器重新刷新，然后我们就可以自动刷新了。 八、默认任务每次gulp命令后面加一个任务名称会不会觉得超级烦？这时候只要以default为任务名称， 123gulp.task('default', function () &#123; // Your default task&#125;); 然后在命令行单单敲下gulp就能启动default任务了。 九、gulp-load-plugins每次gulpfile.js里需要require()那么多的依赖是不是也觉得超级烦？这个时候gulp-load-plugins可以解救我们，只要我们的package.json里有相关的依赖配置并且下载好了这些配置，那么我们就再也不需要require()那么多的依赖了，它写起来就像这样： 123456789101112var gulp = require('gulp'), gulpLoadPlugins = require('gulp-load-plugins'), plugins = gulpLoadPlugins();gulp.task('js', function () &#123; return gulp.src('js/*.js') .pipe(plugins.jshint()) .pipe(plugins.jshint.reporter('default')) .pipe(plugins.uglify()) .pipe(plugins.concat('app.js')) .pipe(gulp.dest('build'));&#125;); 生活就是这么美好，哈哈！ 参考文章Gulp – How To Build And Develop Websites By Callum Macrae]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[转载]Gulp资料大全 入门、插件、脚手架、包清单]]></title>
    <url>%2F2017%2F10%2F25%2F%E8%BD%AC%E8%BD%BD-Gulp%E8%B5%84%E6%96%99%E5%A4%A7%E5%85%A8-%E5%85%A5%E9%97%A8%E3%80%81%E6%8F%92%E4%BB%B6%E3%80%81%E8%84%9A%E6%89%8B%E6%9E%B6%E3%80%81%E5%8C%85%E6%B8%85%E5%8D%95%2F</url>
    <content type="text"><![CDATA[最近在学习Gulp,发现一个超级全的Gulp资料清单，在这里做一个分享。同时也要感谢原作者Pines-Cheng在github上的分享 awesome-gulp中文版 一份gulp的资源，插件和使用实例清单， 致力于打造更好的前端工程构建流程。 被老外的awesome 清单刺激到，觉得有必要翻译一份，为国产的程序员们做点事情，本清单将保持实时更新同步。PS:进都进来了，就顺便看看其他的吧: awesome-nodejs-cn awesome-react-cn awesome-npm-cn awesome-react-native-cn 项目的Github地址：awesome-react-cn,欢迎start。 翻译得仓促，如有问题，请提issues。 如果想贡献，请Pull Requests。 目录 资源 通用资源 官方文档 组织 入门教程 Gulp 入门 Gulp 4 入门 Gulp with Browserify Gulp with Angular Gulp with Angular and Browserify Gulp with Angular and Webpack Gulp with React and Browserify Gulp with Ember 其他资源 插件 编辑 编译 合并 压缩 优化 资源注入 模板 代码校验 实时加载 缓存 流控制 日志 测试 其他插件 脚手架 参考工程 Yeoman生成器 其他 资源通用资源 官网 Github库 插件注册 NPM模块 插件黑名单 官方文档 快速开始 API文档 CLI 文档 开始写一个插件 使用诀窍 组织 StackOverflow Twitter 入门教程Gulp入门 使用Gulp构建前端工程 通过Gulp.js轻松自动化构建你的前端工程 Gulp，让前端工程可视化 Gulp.js是什么？ 使用Gulp在你的HTML中直接插入Scripts和Styles标签 5节课学会使用Gulp.js 我是怎样摆脱前端工程的困扰的？ 第一次开始Gulp Task 为什么你不自己写一个Gulp插件？ 6个最好的从根本改善你的开发经验的Gulp实战练习 Gulp初学者教程 Gulp 4 入门 迁移到Gulp 4的例子 Gulp 4: 新的task执行系统 - gulp.parallel 和 gulp.series Gulp with Browserify Gulp + Browserify, the Gulp-y Way Gulp + Browserify 快速构建Browserify和Watchify Gulp with Angular Angular工程需要什么 - Gulp能提供什么 Gulp with Angular and Browserify 使用 Gulp, Node and Browserify构建先进的 AngularJS工程结构 Gulp with React and Browserify Browserify、Gulp 和 React Taking React to the Next Level: Mixins, Gulp, and Browserify Gulp with Ember 使用Gulp.js改进你的Ember.js工作流 其他资源 Gulp 备忘录 Gulp清单 插件编译 gulp-sass - 通过 libsass将Sass编译成 CSS gulp-ruby-sass - 通过 Ruby Sass将Sass编译成CSS gulp-compass - 通过 Ruby Sass和CompassSass编译成CSS gulp-less - Less编译成 CSS. gulp-stylus - Stylus 编译成 CSS. gulp-postcss - Pipe CSS 通过 PostCSS processors with a single parse. gulp-coffee - Coffeescript 编译成 JavaScript. gulp-typescript - TypeScript编译成JavaScript. gulp-react - Facebook React JSX 模板编译成JavaScript. webpack-stream - 将webpack集成在Gulp中使用。 gulp-babel - ES6编译成ES5 通过 babel. gulp-traceur - ES6编译成ES5 通过 Traceur. gulp-regenerator - ES6编译成ES5 通过 Regenerator. gulp-es6-transpiler - [过时的] ES6编译成ES5 通过 es6-transpiler. gulp-myth - Myth - a polyfill for future versions of the CSS spec. gulp-cssnext - [过时的] 使用下一代的 CSS 规范通过 cssnext. 合并 gulp-concat - 合并文件. 压缩 gulp-clean-css - 压缩 CSS 通过 clean-css. gulp-csso - 压缩 CSS 通过 CSSO. gulp-uglify - 压缩 JavaScript 通过 UglifyJS2. gulp-htmlmin - 压缩 HTML 通过 html-minifier. gulp-minify-html - 压缩 HTML 通过Minimize. gulp-imagemin - 压缩 PNG, JPEG, GIF and SVG 图片 通过 imagemin. gulp-svgmin - 通过Gulp压缩 SVG 文件 优化 gulp-uncss - 移除未使用的CSS选择器通过 UnCSS. gulp-css-base64 - 将CSS文件中所有的资源(有url()声明的)变成base64-encoded 数据的URI字符串 gulp-svg2png - 将SVGs转换成PNGs gulp-responsive - 生成不同尺寸的图片 gulp-svgstore -将svg files 合并成一个通过 元素 gulp-iconfont - 通过SVG icons创建 icon fonts 资源注入 gulp-useref - 解析HTML文件中特殊标签里面的script或style标签，合并成一个script或css文件，并替换。 gulp-inject - 将指定的css或js文件以标签的形式插入到HTML中的指定标志内。 wiredep - 将Bower依赖自动注入HTML文件中。 模板 gulp-angular-templatecache - 在$templateCache中联系并注册AngularJS模板 gulp-jade - Jade 转换成 HTML. gulp-handlebars - Handlebars模板转换成 JavaScript. gulp-hb - Handlebars 模板转换成 HTML. gulp-nunjucks - Nunjucks模板转换成JavaScript. gulp-dustjs - Dust模板转换成JavaScript. gulp-riot - Riot模板转换成JavaScript. gulp-markdown - Markdown → HTML. gulp-template - Lodash 模板转换成JavaScript. gulp-swig - Swig模板转换成HTML. gulp-remark - Gulp plugin for [remark]的Gulp插件(https://github.com/wooorm/remark) 通过插件处理markdown 代码校验 gulp-csslint - 通过CSSLint自动校验CSS. gulp-htmlhint - 通过HTMLHint校验HTML. gulp-jshint - 通过JSHint发现错误和潜在的问题. gulp-jscs - 通过jscs检查JavaScript代码风格. gulp-coffeelint - 一种用来保证CoffeeScript代码风格统一的检查。 gulp-tslint - gulp的TypeScript代码校验插件. gulp-eslint - ECMAScript/JavaScript代码校验. gulp-w3cjs - 通过w3cjs检验HTML. gulp-lesshint - 通过lesshint校验LESS. 实时加载 browser-sync - 保证多个浏览器或设备网页同步显示 (recipes). gulp-livereload - Gulp的实时加载插件. 缓存 gulp-changed - 仅让发生改变的文件通过. gulp-cached - 一个简单的文件内存缓存. gulp-remember - 记忆并回收通过了的文件. gulp-newer - 只让新的源码通过. 流控制 merge-stream - 合并多个流到一个插入的流. streamqueue - 逐渐输入队列的流. run-sequence - 按要求运行一些依赖的Gulptask. gulp-if - 按照条件运行task. 日志 gulp-notify - Gulp的通知插件. gulp-size - 显示你的项目的大小. gulp-debug - 通过调试文件流来观察那些文件通过了你的Gulp管道. 测试 gulp-mocha - 运行Mocha测试用例. gulp-jasmine - 在Node.js中运行Jasmine 2 测试用例. gulp-protractor - 为Protractor测试用例包裹Gulp. gulp-coverage - 为Node.js覆盖相对于运行的测试运行独立的报告. gulp-karma - 通过Gulp运行Karma测试用例. gulp-ava- 通过Gulp运行AVA 测试用例. 其他插件 gulp-util - 包含一系列有用插件. gulp-plumber - 防止错误引起管道中断Prevent pipe breaking caused by errors. gulp-load-plugins - 自动加载Gulp插件. main-bower-files - 构建时自动获取bower库的文件. autoprefixer - 解析CSS且根据规则添加浏览器兼容性前缀. gulp-sourcemaps - 提供source map支持. gulp-replace - Gulp的一个字符串替换插件. gulp-rename - 轻松重命名文件. gulp-rev - 在静态文件名的后面添加hash值，如: unicorn.css → unicorn-d41d8cd98f.css. del - 使用globs删除文件/文件夹. gulp-exec - 运行一个shell命令. gulp-strip-debug - 除去javascript代码中的console,alert,debugger声明. gulp-cssimport - 解析CSS文件，找到imports,将连接文件替换成imort声明. gulp-inline-css - 将HTML中的css属性放到style标签中. gulp-gh-pages - 将内容发布到GiHub有页面. gulp-ng-annotate - 通过ng-annotate添加Angular依赖注入. gulp-bump - 通过Gulp Bump任何semvar JSON版本. gulp-file-include - 通过Gulp Include文件. gulp-zip - 以ZIP格式压缩文件. gulp-git - 通过Gulp运行git命令. gulp-filter - 使用globbing过滤文件. gulp-preprocess - 基于自定义内容或环境配置预处理文件. 脚手架模板 web-starter-kit - Google的Web Starter Kit. gulp-plugin-boilerplate - 创建Gulp插件的开始模板. polymer-starter-kit -Polymer 1.0 应用的起点. este - 同构的web应用最全面的React/Flux开发栈和开始模板. mnml - 开发响应式HTML5/Sass项目的最小开始模板. kraken 一个轻量级的、移动端优先的前端开发开始模板. angularjs-gulp-browserify-boilerplate - 一个使用AngularJS, Sass, gulp, 和 Browserify技术的开始模板. hapi-ninja - 一个使用Node.js, Hapi, and Swig技术的开始模板. laravel-5-boilerplate - 一个Laravel 5 开始模板. react-starterkit - 包含react-router, Reflux, jest, webpack, gulp and Stylus的React开始模板. Yeoman生成器 generator-gulp-webapp - A 一个流行的web应用的gulp生成器. generator-gulp-angular - 使用Gulp的AngularJS 的Yeoman生成器. generator-react-gulp-browserify - 一个React库的Yeoman生成器，包含gulp, Browserify, Browsersync and Bootstrap. generator-node-gulp - 一个Node.js模块生成器，包含gulp和 Mocha. generator-gulp-bootstrap - 一个包含Bootstrap, gulp 和libsass的Yeoman生成器·. generator-angulpify - 一个包含AngularJS, gulp和Browserify的Yeoman生成器. generator-ionic-gulp - 一个Ionic工厂的Yeoman生成器. generator-gulp-plugin-boilerplate -一个输出 gulp plugin boilerplate的脚手架. generator-jekyllized - 一个包含gulp, Sass, AutoPrefixer,资源优化，缓存等的Jekyll工作流. 其他 elixir - 一个为你的应用定义基本的gulp任务的干净、灵活的API. gulp-app - 将Gulp作为一个应用(OS X). lmn-gulp-tasks - gulp任务的单元测试示例. gulp-chef - 一个优雅的、简单的重复使用gulp task的方法. 证书]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>Gulp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode上的一些算法题（二）]]></title>
    <url>%2F2017%2F10%2F24%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些关于股票的算法题，很有趣，在这里做一个分享 一、123456789101112131415161718192021222324252627282930313233343536var maxProfit = function(prices, fee) &#123; total = 0 ; myIndex = 0 ; for(var i=myIndex;i&lt;prices.length-1;)&#123; if(myIndex===prices.length-1) break; tempIndex = myIndex; myPrice = undefined; sellPrice = 0; maxPrice = undefined; for(var x=myIndex;x&lt;prices.length;x++)&#123; tempIndex = x ; if(!myPrice || myPrice&gt;prices[x])&#123; myPrice = prices[x]; continue ; &#125; if(myPrice&lt;prices[x]-fee)&#123; break ; &#125; &#125; myIndex = tempIndex; maxPrice = Math.max(...prices.slice(myIndex)); for(var y=myIndex;y&lt;prices.length;y++)&#123; tempIndex = y ; if(sellPrice===maxPrice || sellPrice&gt;prices[y]+fee)&#123; break ; &#125; if(sellPrice&lt;prices[y])&#123; sellPrice = prices[y]; continue ; &#125; &#125; total += Math.max(sellPrice-myPrice-fee,0); myIndex = tempIndex; &#125; return total ;&#125; 123456789101112131415var maxProfit = function(prices, fee) &#123; var curMin = 10000000, curMax = 0, res = 0; for (var i = 0; i &lt; prices.length; ++i) &#123; if (prices[i] &lt; curMax - fee) &#123; if (curMax - curMin &gt; fee) res += curMax - curMin - fee; curMin = prices[i]; curMax = prices[i]; &#125; else &#123; curMin = Math.min(curMin, prices[i]); curMax = Math.max(curMax, prices[i]); &#125; &#125; if (curMax - curMin &gt; fee) res += curMax - curMin - fee; return res;&#125; 二、12345678var maxProfit = function(prices) &#123; var min = 1000000 , out = 0; for(var x=0;x&lt;prices.length;x++)&#123; min = Math.min(min,prices[x]) out = Math.max(out,prices[x]-min) &#125; return out&#125;; 三、123456789101112131415161718192021222324var maxProfit = function(prices) &#123; var minIndex = 0,maxIndex=0; function temp(prices)&#123; var min = 1000000 , out = 0 ,tempMinIndex = 0; for(var x=0;x&lt;prices.length;x++)&#123; if(prices[x]&lt;min)&#123; min = prices[x] ; tempMinIndex = x ; &#125; if(prices[x]-min&gt;out)&#123; out = prices[x]-min ; maxIndex = x ; minIndex = tempMinIndex ; &#125; &#125; return out ; &#125; var a1 = temp(prices); var left = prices.slice(0,minIndex); var self = prices.slice(minIndex,maxIndex+1); var right = prices.slice(maxIndex+1); var a2 = Math.max(temp(left),temp(right),temp(self.reverse())) ; return a1+a2&#125;; 四、12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var maxProfit = function(k, prices) &#123; console.time() ; var keyIndex = [0,prices.length-1] ; var whole = 0 ; function temp(prices,start,end,isReverse)&#123; var minIndex = 0,maxIndex=0; var min = 1000000 , out = 0 ,tempMinIndex = 0; if(!isReverse)&#123; for(var x=start;x&lt;=end;x++)&#123; if(prices[x]&lt;min)&#123; min = prices[x] ; tempMinIndex = x ; &#125; if(prices[x]-min&gt;out)&#123; out = prices[x]-min ; maxIndex = x ; minIndex = tempMinIndex ; &#125; &#125; &#125;else&#123; for(var x=end;x&gt;=start;x--)&#123; if(prices[x]&lt;min)&#123; min = prices[x] ; tempMinIndex = x ; &#125; if(prices[x]-min&gt;out)&#123; out = prices[x]-min ; maxIndex = x ; minIndex = tempMinIndex ; &#125; &#125; &#125; return [out,[maxIndex,minIndex]] ; &#125; for(var x=1;x&lt;=k;x++)&#123; var sell = 0 ; var currentIndex = [] ; var isReverse = true ; for(var y=0;y&lt;keyIndex.length;y++)&#123; if(y===0) continue ; isReverse = !isReverse ; var getVal = temp(prices,keyIndex[y-1],keyIndex[y],isReverse) ; if(sell&lt;getVal[0])&#123; sell = getVal[0] ; currentIndex = getVal[1] ; &#125; &#125; if(sell===0)&#123; //当遍历所有后,sell还是0的话，说明已经没有合适的对象了，于是退出循环 console.timeEnd() ; return whole ; &#125; keyIndex = keyIndex.concat(currentIndex) ; keyIndex.sort((x,y)=&gt;x&gt;y?1:-1) ; //这边的排序方法要特别注意 whole += sell ; &#125; console.timeEnd() ; return whole ;&#125;; 123456789101112131415161718192021222324252627282930var maxProfit = function(k, prices) &#123; console.time(); function quickSolve(prices) &#123; var len = prices.length, profit = 0; for (var i = 1; i &lt; len; i++) // as long as there is a price gap, we gain a profit. if (prices[i] &gt; prices[i - 1]) profit += prices[i] - prices[i - 1]; return profit; &#125; var len = prices.length; if (k &gt;= len / 2) return quickSolve(prices); var t = new Array(k+1); for(var x=0;x&lt;t.length;x++)&#123; t[x] = new Array(len); for(var y=0;y&lt;t[x].length;y++)&#123; t[x][y] = 0 &#125; &#125; for (var i = 1; i &lt;= k; i++) &#123; var tmpMax = -prices[0]; for (var j = 1; j &lt; len; j++) &#123; t[i][j] = Math.max(t[i][j - 1], prices[j] + tmpMax); tmpMax = Math.max(tmpMax, t[i - 1][j - 1] - prices[j]); &#125; &#125; console.timeEnd(); return t[k][len - 1];&#125;; 五、1234567891011121314151617181920212223242526272829303132//未完成var maxProfit = function(prices) &#123; var min = 10000000 ,max = 0,out=0 ; for(var x = 0 ; x&lt;prices.length ; x++)&#123; min = Math.min(min,prices[x]) ; max = Math.max(max,prices[x]) ; if(x===prices.length-1)&#123; console.log("-------") console.log(prices[x]) console.log(out) console.log(min,max) console.log("-------") out += max-min ; continue ; &#125; if(prices[x+1]&lt;prices[x])&#123; console.log("+++++++++") console.log(x) console.log("+++++++++") if(prices[x+2]-prices[x+1]&gt;(price[x-1]?prices[x]-prices[x-1]:0))&#123; out += (price[x-1]?prices[x-1]-min:0) ; console.log("######1:"+out) &#125;else&#123; out += prices[x]-min ; console.log("######2:"+out) x++ ; &#125; min = 10000000 ,max = 0 ; &#125; &#125; return out ;&#125; 参考文献：leetcode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（四）]]></title>
    <url>%2F2017%2F10%2F24%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E5%9B%9B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python函数式编程中一些高阶函数、返回函数、匿名函数、装饰器、偏函数中值得留意的地方。 一、高阶函数1、mapmap()函数接收两个参数，一个是函数，一个是Iterable，map将传入的函数依次作用到序列的每个元素，并把结果作为新的Iterator返回。 2、reducereduce把一个函数作用在一个序列[x1, x2, x3, ...]上，这个函数必须接收两个参数，reduce把结果继续和序列的下一个元素做累积计算，其效果就是： reduce(f, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) 3、filterfilter()也接收一个函数和一个序列。和map()不同的是，filter()把传入的函数依次作用于每个元素，然后根据返回值是True还是False决定保留还是丢弃该元素。 例如，在一个list中，删掉偶数，只保留奇数，可以这么写：12345data = [1, 2, 4, 5, 6, 9, 10, 15]def is_odd(n): return n % 2 == 1list(filter(is_odd, data))# 结果: [1, 5, 9, 15] 需要注意的是，以上返回的序列是一个新的序列，原来的data序列不变。 4、用filter求素数 计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单： 首先，列出从2开始的所有自然数，构造一个序列： 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取序列的第一个数2，它一定是素数，然后用2把序列的2的倍数筛掉： 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数3，它一定是素数，然后用3把序列的3的倍数筛掉： 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数5，然后用5把序列的5的倍数筛掉： 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 不断筛下去，就可以得到所有的素数。 用Python来实现这个算法，可以先构造一个从3开始的奇数序列： 12345def _odd_iter(): n = 1 while True: n = n + 2 yield n 注意这是一个生成器，并且是一个无限序列。 然后定义一个筛选函数： 12def _not_divisible(n): return lambda x: x % n &gt; 0 最后，定义一个生成器，不断返回下一个素数： 1234567def primes(): yield 2 it = _odd_iter() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(_not_divisible(n), it) # 构造新序列 这个生成器先返回第一个素数2，然后，利用filter()不断产生筛选后的新的序列。 由于primes()也是一个无限序列，所以调用时需要设置一个退出循环的条件： 123456# 打印1000以内的素数:for n in primes(): if n &lt; 1000: print(n) else: break 注意到Iterator是惰性计算的序列，所以我们可以用Python表示“全体自然数”，“全体素数”这样的序列，而代码非常简洁。 5、 sortedsorted()函数也是一个高阶函数，它还可以接收一个key函数来实现自定义的排序，接收一个reverse函数来实现反向排序，参考如下代码： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 二、返回函数1、高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。 2、闭包如果返回的函数依赖其父作用域，那么就形成了闭包。 3、另外需要注意的是，返回的函数并不会立刻执行，而是直到调用了f()才执行。参考如下代码：12345678910111213141516def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) return fsf1, f2, f3 = count()&gt;&gt;&gt; f1()9&gt;&gt;&gt; f2()9&gt;&gt;&gt; f3()9 我们发现，返回的结果都为9，原因就在于返回的函数引用了其父作用域的变量i，但它并非立刻执行。当for循环完成时，变量i已经变成了3，因此最终结果为9。 如果要解决此问题，再创建一个函数，用该函数的参数绑定循环变量当前的值，脱离对父作用域的依赖，参考如下代码： 1234567891011121314151617def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i)立刻被执行，因此i的当前值被传入f() return fs&gt;&gt;&gt; f1, f2, f3 = count()&gt;&gt;&gt; f1()1&gt;&gt;&gt; f2()4&gt;&gt;&gt; f3()9 三、匿名函数在Python中，对匿名函数提供了一些支持,下面的f(x)可以写成匿名函数lambda x: x * x 12def f(x): return x * x 四、装饰器1、在java中有个设计模式叫装饰者模式，可以扩充类的功能。在python中，要想实现类似的功能，可以使用“装饰器”（Decorator）。 2、参考如下简单的代码： 1234567891011121314def log(func): def hala(): print('在这里打印日志') return func() return hala@logdef now(): print('2015-3-25')now()#在这里打印日志#2015-3-25 简单来说。把@log放到now()函数的定义处，相当于执行了语句： now = log(now) 3、如果decorator本身需要传入参数，那就需要编写一个返回decorator的高阶函数，写出来会更复杂。比如，要自定义log的文本： 12345678910111213141516def log(text): def decorator(func): def hala(): print('在这里打印日志'+text) return func() return hala return decorator@log('execute')def now(): print('2015-3-25')now()#在这里打印日志execute#2015-3-25 4、以上两种decorator的定义都没有问题，但还差最后一步。因为我们讲了函数也是对象，它有__name__等属性，但你去看经过decorator装饰之后的函数，它们的__name__已经从原来的&#39;now&#39;变成了&#39;hala&#39;： 12&gt;&gt;&gt; now.__name__'wrapper' 因为返回的那个hala()函数名字就是&#39;hala&#39;，所以，需要把原始函数的__name__等属性复制到hala()函数中，否则，有些依赖函数签名的代码执行就会出错。 不需要编写hala.__name__ = func.__name__这样的代码，Python内置的functools.wraps就是干这个事的，所以，一个完整的decorator的写法如下： 123456789101112import functoolsdef log(func): @functools.wraps(func) def hala(): print('在这里打印日志') return func() return hala@logdef now(): print('2015-3-25') 或者针对带参数的decorator： 1234567891011121314import functoolsdef log(text): def decorator(func): @functools.wraps(func) def hala(): print('在这里打印日志'+text) return func() return hala return decorator@log('execute')def now(): print('2015-3-25') 五、偏函数1、Python的functools模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。 2、使用场景int()函数可以把字符串转换为整数，当仅传入字符串时，int()函数默认按十进制转换： 12&gt;&gt;&gt; int('12345')12345 int()函数还提供额外的base参数，默认值为10。如果传入base参数，就可以做N进制的转换： 1234&gt;&gt;&gt; int('12345', base=8)5349&gt;&gt;&gt; int('12345', 16)74565 假设要转换大量的二进制字符串，每次都传入int(x, base=2)非常麻烦，于是，我们想到，可以定义一个int2()的函数，默认把base=2传进去： 12def int2(x, base=2): return int(x, base) 这样，我们转换二进制就非常方便了： 1234&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 我们使用偏函数也能解决上述问题，参考如下代码： 123456&gt;&gt;&gt; import functools&gt;&gt;&gt; int2 = functools.partial(int, base=2)&gt;&gt;&gt; int2('1000000')64&gt;&gt;&gt; int2('1010101')85 所以，简单总结functools.partial的作用就是，把一个函数的某些参数给固定住（也就是设置默认值），返回一个新的函数，调用这个新函数会更简单。 注意到上面的新的int2函数，仅仅是把base参数重新设定默认值为2，但也可以在函数调用时传入其他值： 12&gt;&gt;&gt; int2('1000000', base=10)1000000 实际上，在创建偏函数时，可以接收函数对象、args和*kw这3个参数，当传入： 1int2 = functools.partial(int, base=2) 实际上固定了int()函数的关键字参数base，也就是： 1int2('10010') 相当于： 12kw = &#123; 'base': 2 &#125;int('10010', **kw) 当传入： 1max2 = functools.partial(max, 10) 实际上会把10作为*args的一部分自动加到左边，也就是： 1max2(5, 6, 7) 相当于： 12args = (10, 5, 6, 7)max(*args) 结果为10。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（三）]]></title>
    <url>%2F2017%2F10%2F24%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%89%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了Python中切片、迭代、列表生成式、生成器、迭代器中值得留意的地方。 一、切片Python提供了切片（Slice）操作符，帮我们完成取一个list或tuple的部分元素的操作。Slice的常见用法参考如下代码： 1234567891011121314151617181920212223242526272829303132333435363738#先创建一个0-99的数列&gt;&gt;&gt; L = list(range(100))&gt;&gt;&gt; L[0, 1, 2, 3, ..., 99]#可以通过切片轻松取出某一段数列。比如前10个数&gt;&gt;&gt; L[:10][0, 1, 2, 3, 4, 5, 6, 7, 8, 9]#后10个数&gt;&gt;&gt; L[-10:][90, 91, 92, 93, 94, 95, 96, 97, 98, 99]#前11-20个数&gt;&gt;&gt; L[10:20][10, 11, 12, 13, 14, 15, 16, 17, 18, 19]#前10个数，每两个取一个&gt;&gt;&gt; L[:10:2][0, 2, 4, 6, 8]#所有数，每5个取一个&gt;&gt;&gt; L[::5][0, 5, 10, 15, 20, 25, 30, 35, 40, 45, 50, 55, 60, 65, 70, 75, 80, 85, 90, 95]#甚至什么都不写，只写[:]就可以原样复制一个list&gt;&gt;&gt; L[:][0, 1, 2, 3, ..., 99]#tuple也是一种list，唯一区别是tuple不可变。因此，tuple也可以用切片操作，只是操作的结果仍是tuple&gt;&gt;&gt; (0, 1, 2, 3, 4, 5)[:3](0, 1, 2)#字符串'xxx'也可以看成是一种list，每个元素就是一个字符。因此，字符串也可以用切片操作，只是操作结果仍是字符串&gt;&gt;&gt; 'ABCDEFG'[:3]'ABC'&gt;&gt;&gt; 'ABCDEFG'[::2]'ACEG' 二、迭代1、默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.values()，如果要同时迭代key和value，可以用for k, v in d.items()。 2、可以通过collections模块的Iterable类型再通过isinstance方法判断一个对象是否是可迭代对象,参考如下代码：1234567&gt;&gt;&gt; from collections import Iterable&gt;&gt;&gt; isinstance('abc', Iterable) # str是否可迭代True&gt;&gt;&gt; isinstance([1,2,3], Iterable) # list是否可迭代True&gt;&gt;&gt; isinstance(123, Iterable) # 整数是否可迭代False 3、如果要对list实现下标循环，可以用Python内置的enumerate函数可以把一个list变成索引-元素对，参考如下代码：123456&gt;&gt;&gt; for i, value in enumerate(['A', 'B', 'C']):... print(i, value)...0 A1 B2 C 4、上面的for循环里，同时引用了两个变量，在Python里是很常见的，参考如下代码：123456&gt;&gt;&gt; for x, y in [(1, 1), (2, 4), (3, 9)]:... print(x, y)...1 12 43 9 三、列表生成式1、在python基础语法小结（一）里，我们了解到用list(range(5))可以生成的序列从0开始小于5的整数: 12&gt;&gt;&gt;list(range(5))[ 0,1, 2, 3, 4] 但如果要生成[0x0, 1x1, 2x2, 3x3, 4x4]就会有些麻烦，需要用for循环：123456&gt;&gt;&gt; L = []&gt;&gt;&gt; for x in range(5):... L.append(x * x)...&gt;&gt;&gt; L[0, 1, 4, 9, 16] 但是循环太繁琐，而列表生成式则可以用一行语句代替循环生成上面的list： 12&gt;&gt;&gt; [x * x for x in range(5)][0, 1, 4, 9, 16] 2、for循环后面还可以加上if判断，这样我们就可以筛选出仅偶数的平方：12&gt;&gt;&gt; [x * x for x in range(1, 11) if x % 2 == 0][4, 16, 36, 64, 100] 3、还可以使用两层循环，可以生成全排列：12&gt;&gt;&gt; [m + n for m in 'ABC' for n in 'XYZ']['AX', 'AY', 'AZ', 'BX', 'BY', 'BZ', 'CX', 'CY', 'CZ'] 4、列表生成式还可以使用两个变量来生成list：123&gt;&gt;&gt; d = &#123;'x': 'A', 'y': 'B', 'z': 'C' &#125;&gt;&gt;&gt; [k + '=' + v for k, v in d.items()]['y=B', 'x=A', 'z=C'] 四、生成器1、通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。 2、要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： 12345678910111213141516171819202122232425262728293031323334&gt;&gt;&gt; L = [x * x for x in range(10)]&gt;&gt;&gt; L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]&gt;&gt;&gt; G = (x * x for x in range(10))&gt;&gt;&gt; G&lt;generator object &lt;genexpr&gt; at 0x000001D760F85BF8&gt;#而且用for迭代时，使用上去也没有差异&gt;&gt;&gt; for i in L:... print(i)0149162536496481&gt;&gt;&gt; for i in G:... print(i)0149162536496481 3、另外一个创建generator的方法是在一个函数定义中包含yield关键字,例如下面一个计算斐波拉契数列（Fibonacci）的函数： 12345678910111213141516def fib(max): n, a, b = 0, 0, 1 while n &lt; max: print(b) a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; fib(6)112358'done' 只需要将其中的print(b)改为yield b,那么fib函数就变成generator： 1234567891011121314151617181920def fib(max): n, a, b = 0, 0, 1 while n &lt; max: yield b a, b = b, a + b n = n + 1 return 'done'&gt;&gt;&gt; f = fib(6)&gt;&gt;&gt; f&lt;generator object fib at 0x000001D760F85CA8&gt;&gt;&gt;&gt; for i in f:... print(i)112358 五、迭代器1、凡是可作用于for循环的对象都是Iterable类型；例如集合数据类型，list、tuple、dict、set、str等；还有generator，包括生成器和带yield的generator function。 2、凡是可作用于next()函数的对象都是Iterator类型，它们表示一个惰性计算的序列； 3、集合数据类型如list、dict、str等是Iterable但不是Iterator，不过可以通过iter()函数获得一个Iterator对象。而generator既是Iterable类型也是Iterator类型。 3、王二认为，可以将Iterable类型比喻为本科生，Iterator类型比喻为硕士生，硕士生一定是本科生，但本科生不一定是研究生，本科生（Iterable）可以通过考研（iter()）变为研究生（Iterator）。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetcode上的一些算法题（一）]]></title>
    <url>%2F2017%2F10%2F23%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些关于字符串的有趣的算法题，在这里做一个分享 一、Longest Substring Without Repeating Characters1、问题描述如下 ： Given a string, find the length of the longest substring without repeating characters. Examples: Given &quot;abcabcbb&quot;, the answer is &quot;abc&quot;, which the length is 3. Given &quot;bbbbb&quot;, the answer is &quot;b&quot;, with the length of 1. Given &quot;pwwkew&quot;, the answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring. 原问题地址点这里 2、王二一开始的算法如下： 12345678910111213141516171819202122232425262728293031var lengthOfLongestSubstring = function(s) &#123; if (s.length===0) return; var element = &#123;&#125; ; var maxLength = 0 ; var currentLength = 0 ; var currentIndex = 0 ; for(var x=0;x&lt;s.length;x++)&#123; var i = s[x]; if(element.hasOwnProperty(i))&#123; var index = element[i] ; currentLength = 0 ; for(var temp of Object.entries(element))&#123; if(temp[1]&lt;=index)&#123; delete element[temp[0]] ; &#125;else&#123; currentLength++ ; &#125; &#125; element[i] = x ; currentLength++ ; &#125;else&#123; element[i] = x ; currentLength++ ; if(currentLength&gt;maxLength)&#123; maxLength = currentLength ; currentIndex = x ; &#125; &#125; &#125; return [maxLength,s.substr(currentIndex-maxLength+1,maxLength)] ;&#125; 算法的时间复杂度为O(n)，参考如下验证时间为O(n)的代码： 123456789101112131415161718192021222324function getRandomStr(len) &#123; //随机获取字符串，len为随机字符串的长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;var validate = function()&#123; var str = getRandomStr(100000) ; console.time('str100000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str100000') ; var str = getRandomStr(1000000) ; console.time('str1000000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str1000000') ;&#125;validate() ; 执行时间如下图所示： 3、王二的解决思路如下：把字符串看成一个游标，每for循环一次就相当于在游标上走一格，算法会设置一个element对象，每走一格，算法会判断element对象中有没有这一格的值。 如果没有，就会将这一格的值加入到element对象中，加完后再将element的长度与maxLength作比较，将较大值重新赋值给maxLength。 如果有，会将element对象中这一格之前的值都给清除掉。 4、不过leetcode上大神们有更巧妙的解决思路，参考如下（原文点击这里）： 12345678910111213public int lengthOfLongestSubstring(String s) &#123; if (s.length()==0) return 0; HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;(); int max=0; for (int i=0, j=0; i&lt;s.length(); ++i)&#123; if (map.containsKey(s.charAt(i)))&#123; j = Math.max(j,map.get(s.charAt(i))+1); &#125; map.put(s.charAt(i),i); max = Math.max(max,i-j+1); &#125; return max;&#125; 大神的思路是这样的 ： the basic idea is, keep a hashmap which stores the characters in string as keys and their positions as values, and keep two pointers which define the max substring. move the right pointer to scan through the string , and meanwhile update the hashmap. If the character is already in the hashmap, then move the left pointer to the right of the same character last found. Note that the two pointers can only move forward. 5、于是王二参考大神的思路写下了如下的算法： 123456789101112131415161718var lengthOfLongestSubstring = function(s) &#123; if (s.length==0) return 0; var map = &#123;&#125;; var maxLength=0; var currentIndex = 0; for (var i=0, j=0; i&lt;s.length; ++i)&#123; if (map.hasOwnProperty(s[i]))&#123; j = Math.max(j,map[s[i]]+1); &#125; map[s[i]] = i; temp = Math.max(maxLength,i-j+1); if(temp&gt;maxLength)&#123; maxLength = temp ; currentIndex = i ; &#125; &#125; return [maxLength,s.substr(currentIndex-maxLength+1,maxLength)];&#125; 它的算法的时间复杂度为O(n)，而且执行效率更高，参考如下验证代码： 123456789101112131415161718192021222324function getRandomStr(len) &#123; //随机获取字符串，len为随机字符串的长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;var validate = function()&#123; var str = getRandomStr(100000) ; console.time('str100000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str100000') ; var str = getRandomStr(1000000) ; console.time('str1000000') ; console.log(lengthOfLongestSubstring(str)) ; console.timeEnd('str1000000') ;&#125;validate() ; 执行时间如下图所示： 二、Longest Palindromic Substring1、问题描述如下： Given a string s, find the longest palindromic substring in s. Example: Input: “babad”Output: “bab”Note: “aba” is also a valid answer. Example: Input: “cbbd”Output: “bb” 原问题地址点这里 2、王二的算法如下： 123456789101112131415161718var longestPalindrome = function(s) &#123; s = ' '+s.split('').join(' ')+' '; var out = '' ; for(var x=0 ; x&lt;s.length ; x++)&#123; var temp = s[x] ; for(var y=1 ; y&lt;=x ; y++)&#123; if(s[x-y]===s[x+y])&#123; temp = s[x-y] + temp + s[x+y] ; &#125;else&#123; break ; &#125; &#125; if(out.length&lt;temp.length)&#123; out = temp ; &#125; &#125; return out.split(/\s+/).join('') ;&#125;; 该算法也是O(n)的时间复杂度。 在解决这个问题的时候，王二遇到了一个问题：上述代码如果直接for循环，那么遇到偶数个回文时就不会正确处理，那该怎么办呢？王二的解决方法是在单个字符之间插入空格，那么将空格算进去后，返回的回文数一定是奇数个，最后返回的时候再将空格都去除掉，问题就解决了。 最后推荐一个很好的刷题的网站leetcode]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（二）]]></title>
    <url>%2F2017%2F10%2F21%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%BA%8C%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了函数中内置函数、参数返回值、默认函数、可变参数、关键字参数、递归函数中值得留意的地方。 一、函数1、python内置了很多有用的函数，我们可以直接从pyhton的官方网站中查看到。 2、如果想定义一个什么事也不做的空函数，可以用pass语句： 12def nop(): pass 3、python 的函数可以返回多个值，但其实就是一个tuple。 4、默认参数 python 的函数传的参数数量需要与函数定义参数的数量一致，如果不一致，就会报错，参考如下代码： 1234567891011121314def power(x, n): s = 1 while n &gt; 0: n = n - 1 s = s * x return s&gt;&gt;&gt; power(5, 3)125&gt;&gt;&gt; power(5)Traceback (most recent call last): File "&lt;stdin&gt;", line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: 'n' 为了避免这种情况，可以使用默认参数，参考如下代码： 123456def power(x, n=2): s = 1 while n &gt; 0: n = n - 1 s = s * x return s 需要注意的是，设置默认参数时，必选参数在前，默认参数在后，否则Python的解释器会报错。另外，当默认参数的默认值是一个引用变量时，我们会很有可能掉进坑里，参考如下代码： 123def add_end(L=[]): L.append('END') return L 当正常调用时，结果似乎不错： 1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 当使用默认参数调用时，一开始结果也是对的： 12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了’END’后的list。 原因解释如下：Python函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。 所以，定义默认参数要牢记一点：默认参数必须指向不变对象！ 在JS的ES6语法中，为函数设置默认参数时，不会出现以上Python中遇到的问题，在这一点上，JS和Python有差异 要修改上面的例子，我们可以用None这个不变对象来实现： 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 现在，无论调用多少次，都不会有问题： 1234&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END'] 5、可变参数定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。Python还允许我们在list或tuple前面加一个号，把list或tuple的元素变成可变参数传进去。 6、关键字参数可变参数允许我们传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许我们可以传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。参考如下代码： 12def person(name, age, **kw): print('name:', name, 'age:', age, 'other:', kw) 函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数： 12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125; 也可以传入任意个数的关键字参数： 1234&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;&gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125; 和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去： 123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125; 7、尾递归在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。 这个时候可以使用尾递归来优化算法，王二认为，尾递归的核心要素在于函数return出来的东西不能对其父作用域有依赖关系 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python基础语法小结（一）]]></title>
    <url>%2F2017%2F10%2F19%2Fpython%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E5%B0%8F%E7%BB%93%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[打算最近有时间看一看Python的基础语法,这一节里主要记录了数据类型和变量、list 、tuple、循环、dict、set中值得留意的地方。 一、数据类型和变量1、在需要在字符中使用特殊字符时，python用反斜杠(\)转义字符。下表是开发中一些常用的转义字符： 转义字符 描述 \(在行尾时) 续行符 \\ 反斜杠符号 \&#39; 单引号 \&quot; 双引号 \n 换行 \t 横向制表符 2、如果字符串里面有很多字符都需要转义，就需要加很多\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，参考如下代码： 1234&gt;&gt;&gt; print('\\\t\\')\ \&gt;&gt;&gt; print(r'\\\t\\')\\\t\\ 3、如果字符串内部有很多换行，用\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容。 4、在python中，在Python中，布尔值的首字母是大写的（True，False） 5、在python3中，有两种除法： 一种除法是/,其计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数： 12345&gt;&gt;&gt; 10 / 33.3333333333333335&gt;&gt;&gt; 9 / 33.0 还有一种除法是//，称为地板除，两个整数的除法仍然是整数： 12&gt;&gt;&gt; 10 // 33 这一点和python2的语法有差异。 二、使用list1、list是一种有序的集合，可以随时添加和删除其中的元素。 2、用len()函数可以获得list元素的个数： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3 3、list可以用负数做索引，例如-1做索引，可以直接获取最后一个元素： 12&gt;&gt;&gt; classmates[-1]'Tracy' 4、append可以往list中追加元素到末尾。 5、也可以把元素插入到指定的位置，比如索引号为1的位置： 1234&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy'] 6、pop 会删除list末尾的元素，如果要删除指定位置的元素，可以用pop(i)方法，其中i是索引位置。 7、如果要把某个元素替换成别的元素，可以直接赋值给对应的索引位置： 123&gt;&gt;&gt; classmates[1] = &apos;Sarah&apos;&gt;&gt;&gt; classmates[&apos;Michael&apos;, &apos;Sarah&apos;, &apos;Tracy&apos;] 三、使用tuple1、tuple和list非常类似，但是tuple一旦初始化就不能修改。 2、如果要定义一个空的tuple，可以写成()；但是，要定义一个只有1个元素的tuple，如果你这么定义： 123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1 定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义： 123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,) 四、循环1、如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数: 12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4] 如果要计算0～100的和，可以参考如下代码： 1234sum = 0for x in range(101): sum = sum + xprint(sum) 五、使用dict1、Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。 2、如果要删除dict中的一个key，可以用pop(key)方法，对应的value也会从dict中删除。 3、和list比较，dict有以下几个特点： 查找和插入的速度极快，不会随着key的增加而变慢； 需要占用大量的内存，内存浪费多。 而list相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict是用空间来换取时间的一种方法。 六、使用set1、set中不可以放入可变对象，例如，下面代码会出错： 1234&gt;&gt;&gt; set([1, 1, 2, 2, [3], 3])Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: &apos;list&apos; 这一点和JS里的Set有出入，在JS中，引用类型对象也可以放入Set对象中。 参考文章廖雪峰的官方网站]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一道算法题以及关于其时间复杂度的一些讨论]]></title>
    <url>%2F2017%2F10%2F19%2Fleetcode%E4%B8%8A%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AE%97%E6%B3%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近在leetcode上看了一些算法题，其中有一个Two Sum的算法，其中涉及一些关于时间复杂度的问题，在这里做一个讨论 一、算法描述如下：Given an array of integers, return indices of the two numbers such that they add up to a specific target. You may assume that each input would have exactly one solution, and you may not use the same element twice. Example:Given nums = [2, 7, 11, 15], target = 9,Because nums[0] + nums[1] = 2 + 7 = 9,return [0, 1]. 如果想看leetcode上关于two sum的描述可以点这里 二、解决思路1、王二最开始写下了如下算法： 123456789101112function twoSum (nums,target) &#123; var out ; nums.forEach(function(element1,index1) &#123; nums.forEach(function(element2,index2)&#123; if(index2&lt;=index1) return ; if(element1+element2===target &amp;&amp; !out)&#123; out = [index1,index2] &#125; &#125;) &#125;); return out ;&#125; 但是以上算法有一个缺陷，Array.prototype.forEach在遍历数组时中途不能跳出循环，除非我手动抛出一个错误，但是这样就显得非常不优雅了。 2、于是王二想到了可以用for循环，代码如下： 123456789function twoSum (nums,target) &#123; for (var x=0; x&lt;nums.length;x++)&#123; for (var y=x+1; y&lt;nums.length;y++)&#123; if(nums[x]+nums[y]===target)&#123; return [x,y] ; &#125; &#125; &#125;&#125; 这样写的话，只要一找到符合条件的数组，就能跳出循环，相比第一种方法效率提高了不少。 3、不过王二觉得两层for循环是在是不太好看，甚至觉得有点low，一定有其他的解决方案，于是又细细思索了一下，改进了代码如下： 123456function twoSum (nums,target) &#123; for (var x=0; x&lt;nums.length;x++)&#123; var y = nums.lastIndexOf(target-nums[x]) if(y&gt;0) return x===y?undefined:[x,y] ; &#125;&#125; 这样写的话代码就显得优雅精悍的多了，但它本质上还是两层循环，时间复杂度仍然为O(n^2)，因为indexOf是数组的元素存在性检查方法。需要遍历所有元素来检查，此方法的时间复杂度是O(n) 参考如下验证时间为O(n^2)的代码：12345678910111213141516171819202122232425function largeArray(index) &#123; var arr = [] ; var count = 1 ; for(var x = 0;x&lt;index;x++)&#123; arr.push(count++); &#125; return arr ;&#125;function twoSum (nums,target) &#123; console.time() ; for (var x=0; x&lt;nums.length;x++)&#123; var y = nums.lastIndexOf(target-nums[x]) if(y&gt;0) &#123; return x===y?undefined:[x,y] ; &#125; &#125; console.timeEnd() ;&#125;//注意arr1与arr2分开执行var arr1 = largeArray(10000);//var arr2 = largeArray(100000);twoSum(arr1,10000000) //为10000000时，方法由于找不到适配的结果，所以会遍历所有情况//twoSum(arr2,10000000) 执行时间如下图所示： 可以发现在数组长度多了10倍的情况下，执行时间多了近100倍。 4、leetcode上有大神用java写下了如下代码(链接在这里)：12345678910111213public int[] twoSum(int[] numbers, int target) &#123; int[] result = new int[2]; Map&lt;Integer, Integer&gt; map = new HashMap&lt;Integer, Integer&gt;(); for (int i = 0; i &lt; numbers.length; i++) &#123; if (map.containsKey(target - numbers[i])) &#123; result[1] = i + 1; result[0] = map.get(target - numbers[i]); return result; &#125; map.put(numbers[i], i + 1); &#125; return result;&#125; 它的时间复杂度为O(n)，原因是作者巧妙地运用了HashMap的containsKey()方法，由于HashMap使用哈希表来存储元素，所以在查询key时，其时间复杂度为O(1)。 5、于是我也用js复原了一下上面的java算法，参考如下：123456789function twoSum (nums,target) &#123; var obj = &#123;&#125;; for (var x=0; x&lt;nums.length;x++)&#123; if(obj.hasOwnProperty(target-nums[x])) &#123; return [obj[target-nums[x]],x] ; &#125; obj[nums[x]]=x; &#125;&#125; 这里的Object.prototype.hasOwnProperty类似java中HashMap的containsKey()方法，时间复杂度为O(1)；所以以上代码的时间复杂度也变成了O(n) 参考如下验证时间为O(n)的代码：1234567891011121314151617181920212223242526function largeArray(index) &#123; var arr = [] ; var count = 1 ; for(var x = 0;x&lt;index;x++)&#123; arr.push(count++); &#125; return arr ;&#125;function twoSum (nums,target) &#123; console.time() ; var obj = &#123;&#125;; for (var x=0; x&lt;nums.length;x++)&#123; if(obj.hasOwnProperty(target-nums[x])) &#123; return [obj[target-nums[x]],x] ; &#125; obj[nums[x]]=x; &#125; console.timeEnd() ;&#125;//注意arr1与arr2分开执行var arr1 = largeArray(10000);//var arr2 = largeArray(100000);twoSum(arr1,10000000) //为10000000时，方法由于找不到适配的结果，所以会遍历所有情况//twoSum(arr2,10000000) 执行时间如下图所示： 可以发现在数组长度多了10倍的情况下，执行时间也只多了不到10倍。 二、小结上述代码中，在数组长度很大的情况下，时间复杂度为O(n^2)与时间复杂度为O(n)的执行效率相差了近万倍，有时候会严重地影响性能，从这一点来看，以后写算法的时候要特别注意算法的时间复杂度； 参考文章：leetcodesegmentfaultCSDN”旧时光“的博客]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>leetcode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS样式踩坑小结]]></title>
    <url>%2F2017%2F10%2F12%2FCSS%E6%A0%B7%E5%BC%8F%E8%B8%A9%E5%9D%91%E5%B0%8F%E7%BB%93%2F</url>
    <content type="text"><![CDATA[最近做了一些项目，在CSS方面遇到了不少坑，在这里做一个小结 一、iOS上的Safari没有滑动惯性在开发iphone微信端的时候，如果给一个div设置样式为滑动,样式如下：123div&#123; overflow-y:scroll ;&#125; 会发现Safari的滑动很僵硬，这时候可以用以下样式来解决：123div&#123; -webkit-overflow-scrolling: touch;&#125; 二、去除iphone中点击按钮会出现一个半透明的灰色背景的问题在开发iphone微信端的时候，同样发现，如果点击一个按钮，按钮会出现一个半透明的灰色背景，这时候可以用以下样式来解决： 123a,img,button,input,textarea,div&#123; -webkit-tap-highlight-color:rgba(255,255,255,0); &#125; 三、div中保留保留文本的空格、换行以及tab字符的处理在后台用textarea标签写入文本放入前端显示的时候，发现之前在textarea中的文本都被格式化了（浏览器默认把文本中的空格、换行以及tab字符都处理掉了），如果想保留文本的格式，可以用以下样式来解决： 123div&#123; white-space: pre-wrap;&#125; 需要特别注意的是，white-space有五种值可以选择，normal、pre 、nowrap 、pre-wrap、pre-wrap,每一种值都有不同的表现形式，其中： normal 是 white-space 的默认值； pre 会保留文本中额外的空格, 而且会保留文本中的换行； nowrap 不会保留文本中额外的空格，而且会禁止文本中的换行； pre-wrap 会保留文本中额外的空格, 而且会让文本正常的换行； pre-line 不会保留文本中额外的空格，但是会让文本正常的换行； 这样解释读者会有一些迷惑，接下来用代码进一步说明，参考如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;style&gt; .a&#123; white-space: pre &#125; .b&#123; white-space: nowrap &#125; .c&#123; white-space: pre-wrap &#125; .d&#123; white-space: pre-line &#125; .e&#123; white-space: normal &#125;&lt;/style&gt;&lt;div class="a"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="b"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="c"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="d"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div class="e"&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt;&lt;hr&gt;&lt;div&gt; hdfkf sjnfjsdkfn sdjf d d dfklsf sdfhjs sdfbsjdh df djfsf dsfsdf sdfbsjdh hfh hfjsgjf&lt;/div&gt; 这里我们要特地留意一下 pre 与 pre-wrap 的区别，正常情况下，两者的现实没有差异，如下图： 但是如果将窗口拉窄,我们会发现，pre-wrap会让文本根据窗口宽窄自动换行，而pre的换行不会受窗口宽窄影响： 四、让盒子里的字超出长度后，可以缩略显示变成点点点1、在 div 框里的内容超出长度后，我们可以让超出部分的内容变成点点点，样式如下： 12345div&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis;&#125; 然后我们就能获得我们想要的样式： 1234567891011121314151617&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .ellipsis&#123; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; &#125;&lt;/style&gt;&lt;div class="a"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt; 效果图如下： 2、但是如果我们想让div里的内容两行或者三行之后再显示点点点，我们应该怎么办呢？如果你也有疑惑，可以参考如下代码： 123456789101112131415161718&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="a"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;Wow,CSS is very very very very very cool !&lt;/div&gt; 效果图如下： 这时候变成三行后再省略也相当简单，直接将 -webkit-line-clamp 变成 3 就行了。 3、特别特别需要注意的是，如果遇到丧心病狂的测试，他会给出一长串连续的英文字符，那么以上代码有可能会失效，这时候就需要word-break: break-all; 来帮助我们，参考如下代码： 1234567891011121314151617181920212223242526272829&lt;style&gt; .a&#123; width:100px; border: 1px solid gray; &#125; .break&#123; word-break: break-all ; &#125; .ellipsis&#123; display: -webkit-box; -webkit-box-orient: vertical; -webkit-line-clamp: 2; overflow: hidden; &#125;&lt;/style&gt;&lt;div class="a"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a ellipsis"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a break ellipsis"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt;&lt;hr&gt;&lt;div class="a break"&gt;ssssssasjdjdfjsdfksdfgksdfgskdfgskjdfksdf&lt;/div&gt; 效果图如下： 五、word-wrap和word-break的区别1、word-wrap和word-break都能使过长的字符串断开，防止其溢出，那他们两的区别又是什么呢？ 2、我们先从MDN文档里了解它们的概要： CSS 属性 word-break 指定了怎样在单词内断行。他的属性有： normal 使用默认的断行规则。 break-all 对于non-CJK (CJK 指中文/日文/韩文) 文本，可在任意字符间断行。 keep-all CJK 文本不断行。 Non-CJK 文本表现同 normal。 CSS 属性 word-wrap 是用来说明当一个不能被分开的字符串太长而不能填充其包裹盒时，为防止其溢出，浏览器是否允许这样的单词中断换行。他的属性有： normal 表示在正常的单词结束处换行。 break-word 表示如果行内没有多余的地方容纳该单词到结尾，则那些正常的不能被被分割的单词会被强制分割换行。 3、仅仅看解释并不能看出什么头绪，接下来用代码来演示他们的差异，代码如下： 12345678910111213141516171819202122&lt;style&gt;.a&#123; width:100px; border: 1px solid gray;&#125;.break&#123; word-break: break-all ;&#125;.wrap&#123; word-wrap: break-word ;&#125;&lt;/style&gt;&lt;div class="a"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt;&lt;hr&gt;&lt;div class="a break"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt;&lt;hr&gt;&lt;div class="a wrap"&gt;you are vvvvvvvvvvvvvvvvvvvvvvvery beautiful!&lt;/div&gt; 效果图如下： 我们发现，当使用word-wrap: break-word;时，如果这个时候文本溢出，它会首先尝试挪到下一行，看看下一行的宽度够不够，不够的话才会进行单词内的断句。而使用word-break:break-all时，他会直接进行单词内的断句。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.keys、Object.values、Object.entries的使用方法]]></title>
    <url>%2F2017%2F10%2F11%2FJS%E4%B8%ADObject-keys%E3%80%81Object-values%E3%80%81Object-entries%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.keys、Object.values、Object.entries的使用方法 一、大致了解首先我们需要了解的是Object.keys是ES5中引入的的方法，在ES2017中，引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段。 需要注意的是，Object.keys(),Object.values(),Object.entries()都会返回一个由一个给定对象的自身可枚举属性组成的数组，数组中属性名的排列顺序和使用 for...in 循环遍历该对象时返回的顺序一致( 区别在于 for...in 还会循环枚举原型链中的属性 )。 参考一些代码：1234567let obj = &#123; a: 1, b: 2, c: 3 &#125;;Object.keys(obj); // ['a','b','c']Object.values(obj); // [1,2,3]Object.entries(obj); // [['a',1],['b',2],['c',3]] 我们会发现，Object.keys会返回参数对象自身的所有可遍历属性的键名形成的数组，Object.values会返回参数对象自身的所有可遍历属性的键值形成的数组，Object.entries会返回参数对象自身的所有可遍历属性的键值对数组形成的数组 二、其他一些例子再来看一些Object.keys、Object.values、Object.entries的其他使用方法：123456789101112131415161718192021222324252627/* Array 对象 */ var arr = ["a", "b", "c"];console.log(Object.keys(arr)); // ["0", "1", "2"]console.log(Object.values(arr)); // ["a", "b", "c"]console.log(Object.entries(arr)); // [["0", "a"], ["1", "b"], ["2", "c"]]/* 类数组 对象 */ var obj = &#123; 0 : "a", 1 : "b", 2 : "c"&#125;;console.log(Object.keys(obj)); // ["0", "1", "2"]console.log(Object.values(obj)); // ["a", "b", "c"]console.log(Object.entries(obj)); // [["0", "a"], ["1", "b"], ["2", "c"]]/* 类数组 对象, 随机排序 */var obj1 = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;; console.log(Object.keys(obj1)); // ["2", "7", "100"]console.log(Object.values(obj1)); // ["b", "c", "a"]console.log(Object.entries(obj1)); // [["2", "b"],["7", "c"],["100", "a"]]/* a 是个不可枚举的属性 */ var obj2 = &#123;&#125;Object.defineProperty(obj2,'a', &#123; value : "hala"&#125;);obj2.b = "heihei";console.log(Object.keys(obj2)); // ['b']console.log(Object.values(obj2)); // ['heihei']console.log(Object.entries(obj2)); // [["b", "heihei"]] 三、注意点在ES5里，如果传入的参数不是对象（而是一个原始值），那么它会抛出 TypeError。但是在ES2015中，非对象的参数将被强制转换为一个对象，参考如下代码：12345678Object.keys("foo"); // TypeError: "foo" is not an object (ES5 code)Object.keys("foo");// ["0", "1", "2"] (ES2015 code)Object.values("foo"); // TypeError: "foo" is not an object (ES5 code)Object.values("foo");// ["f", "o", "0"] (ES2015 code)Object.entries("foo"); // TypeError: "foo" is not an object (ES5 code)Object.entries("foo");// [["0", "f"],["1", "o"],["2", "o"]] (ES2015 code) 四、Object.entries的另外用法new Map() 构造函数接受一个可迭代的entries。借助Object.entries方法你可以很容易的将Object转换为Map,参考如下代码： 123var obj = &#123; foo: "bar", baz: 42 &#125;; var map = new Map(Object.entries(obj));console.log(map); // Map &#123; foo: "bar", baz: 42 &#125; 参考文档MDN web docs阮一峰ES6语法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.create的使用方法]]></title>
    <url>%2F2017%2F10%2F10%2FJS%E4%B8%ADObject-defineProperty%E4%B8%8EObject-create%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%952%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.create的使用方法 一、Object.create1、Object.create() 方法会使用指定的原型对象及其属性去创建一个新的对象，语法如下： Object.create(proto, [ propertiesObject ]) 其中： proto一个对象，新创建对象的原型 propertiesObject可选。该参数对象是一组属性与值，该对象的属性名称将是新创建的对象的属性名称，值是属性描述符（这些属性描述符的结构与Object.defineProperties()的第二个参数一样）。 函数将返回一个定原型对象上添加新属性后的新对象 如果 propertiesObject 参数不是 null 也不是对象，则抛出一个 TypeError 异常。 2、一些例子： 1234var a = &#123;v:41&#125;var b = Object.create(a)b.__proto__ === a //true //Object.create返回的对象的原型是其第一个参数。 123o = &#123;&#125;;// 以字面量方式创建的空对象就相当于:o = Object.create(Object.prototype); 12345678910111213141516o = Object.create(Object.prototype, &#123; // foo会成为所创建对象的数据属性 foo: &#123; writable:true, configurable:true, value: "hello" &#125;, // bar会成为所创建对象的访问器属性 bar: &#123; configurable: false, get: function() &#123; return 10 &#125;, set: function(value) &#123; console.log("Setting `o.bar` to", value); &#125; &#125;&#125;); 1234567891011121314// 创建一个以另一个空对象为原型,且拥有一个属性p的对象o = Object.create(&#123;&#125;, &#123; p: &#123; value: 42 &#125; &#125;)// 省略了的属性特性默认为false,所以属性p是不可写,不可枚举,不可配置的:o.p = 24o.p //42o.q = 12for (var prop in o) &#123; //for..in..不可枚举 console.log(prop)&#125;//"q"delete o.p // Nothing happens 123456789//创建一个可写的,可枚举的,可配置的属性po2 = Object.create(&#123;&#125;, &#123; p: &#123; value: 42, writable: true, enumerable: true, configurable: true &#125; &#125;); 3、使用 Object.create 实现类式继承,参考如下代码： 1234567891011121314151617181920212223242526272829//Shape - superclassfunction Shape() &#123; this.x = 0; this.y = 0;&#125;Shape.prototype.move = function(x, y) &#123; this.x += x; this.y += y; console.info("Shape moved.");&#125;;// Rectangle - subclassfunction Rectangle() &#123; Shape.call(this); //call super constructor.&#125;// subclass extends superclassRectangle.prototype = Object.create(Shape.prototype);Rectangle.prototype.constructor = Rectangle;var rect = new Rectangle();console.log('Is rect an instance of Rectangle?', rect instanceof Rectangle); // trueconsole.log('Is rect an instance of Shape?', rect instanceof Shape); // truerect.move(1, 1); //Outputs, "Shape moved." 如果有兴趣了解用其他方式实现类继承，可以参考我的这篇博客理解原型链; 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中Object.defineProperty的使用方法]]></title>
    <url>%2F2017%2F10%2F10%2FJS%E4%B8%ADObject-defineProperty%E4%B8%8EObject-create%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[一直好奇JS中Object上静态方法的使用方式，上网找了不少教程，今天在这里和大家分享一下 Object.defineProperty的使用方法 一、Object.defineProperty1、Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象，语法如下： Object.defineProperty(obj, prop, descriptor) 其中： obj是需要被操作的目标对象 prop是目标对象需要定义或修改的属性的名称 descriptor是将被定义或修改的属性的描述符 函数将返回被传递给函数的对象 2、一个简单的实例： 12var o = &#123;&#125;;Object.defineProperty(o, "a", &#123;value : 37&#125;); //&#123;a: 37&#125; 上述代码中，我们用Object.defineProperty为对象o创建的了一个新属性a,它的值为37，但是我们也发现了一些问题，参考如下代码： 12345var o = &#123;&#125;;Object.defineProperty(o, "a", &#123;value : 37&#125;); //&#123;a: 37&#125;console.log(o.a); // 打印 37o.a = 25; // 没有错误抛出（在严格模式下会抛出，即使之前已经有相同的值）console.log(o.a); // 打印 37， 赋值不起作用。 我们发现，对o.a赋值似乎不起作用，原来Object.defineProperty的第三个参数descriptor有很多属性描述符，其中就有是否能被赋值运算符改变value的属性描述符。 3、具体的属性描述符如下： configurable 当且仅当该属性的 configurable 为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。 enumerable 当且仅当该属性的 enumerable 为 true 时，该属性才能够出现在对象的枚举属性中(可以被for..in..遍历)。默认为 false。 value 该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。默认为 undefined。 writable 当且仅当该属性的 writable 为 true 时，该属性才能被赋值运算符改变。默认为 false。 get 一个给属性提供 getter 的方法，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined。 set 一个给属性提供 setter 的方法，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined。 4、这时候我们改造一下代码，如下： 12345678910var o = &#123;&#125;;Object.defineProperty(o, "a", &#123; value : 37, writable : true, enumerable : true, configurable : true&#125;); //&#123;a: 37&#125;console.log(o.a); // 打印 37o.a = 25;console.log(o.a); // 打印 25 这样的话我们就可以正确地为属性赋值了。 5、需要注意的是，对象里目前存在的属性描述符有两种主要形式：数据描述符和存取描述符。数据描述符是一个拥有可写或不可写值的属性。存取描述符是由一对 getter-setter 函数功能来描述的属性。描述符必须是两种形式之一；不能同时是两者。其中，数据描述符和存取描述符均具有以下可选键值：configurable，enumerable，value，writable存取描述符同时具有以下可选键值：get，set。 如果两者同时使用，会报如下错误： 12345678var o = &#123;&#125;;Object.defineProperty(o, "conflict", &#123; value: 0x9f91102, get: function() &#123; return 0xdeadbeef; &#125; &#125;);//Uncaught TypeError: Invalid property descriptor. Cannot both specify accessors and a value or writable attribute 6、在这里，我们需要特别注意 configurable 这个属性描述符，如果它的值为false，那么除了 writable 外，其他特性都不能被修改(包括其自身)，并且 writable 只能从 true 修改为 false，而且数据和存取描述符也不能相互切换。 如果尝试修改，会报如下错误： 12345678910111213141516171819var o = &#123;&#125;;Object.defineProperty(o, "a", &#123; get : function()&#123;return 1;&#125;, configurable : false &#125;);// throws a TypeErrorObject.defineProperty(o, "a", &#123;configurable : true&#125;); // throws a TypeErrorObject.defineProperty(o, "a", &#123;enumerable : true&#125;); // throws a TypeError (set was undefined previously) Object.defineProperty(o, "a", &#123;set : function()&#123;&#125;&#125;); // throws a TypeError (even though the new get does exactly the same thing) Object.defineProperty(o, "a", &#123;get : function()&#123;return 1;&#125;&#125;);// throws a TypeErrorObject.defineProperty(o, "a", &#123;value : 12&#125;);console.log(o.a); // logs 1delete o.a; // Nothing happensconsole.log(o.a); // logs 1 7、最后，我们又要留意一下存取描述符set与get，vuejs的底层就是通过set与get监听数据变动来实现mvvm的双向绑定的，参考如下代码： 12345678910111213141516171819202122232425262728293031function observe(data) &#123; if (!data || typeof data !== 'object') &#123; return; &#125; // 取出所有属性遍历 Object.keys(data).forEach(function(key) &#123; defineReactive(data, key, data[key]); &#125;);&#125;;function defineReactive(data, key, val) &#123; observe(val); // 监听子属性 Object.defineProperty(data, key, &#123; enumerable: true, // 可枚举 configurable: false, // 不能再define get: function() &#123; return val; &#125;, set: function(newVal) &#123; console.log('哈哈哈，监听到值变化了 ', val, ' --&gt; ', newVal); val = newVal; &#125; &#125;);&#125;var obj = &#123;a:'10',b:'20'&#125;observe(obj)obj.a // '10'obj.a = '100' // 哈哈哈，监听到值变化了 10 --&gt; 100// '100' 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[让input里面placeholder水平居中]]></title>
    <url>%2F2017%2F10%2F10%2F%E8%AE%A9input%E9%87%8C%E9%9D%A2placeholder%E6%B0%B4%E5%B9%B3%E5%B1%85%E4%B8%AD%2F</url>
    <content type="text"><![CDATA[有时候我们想让input里面placeholder水平居中，这个时候我们可以这样做 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; input&#123; width: 200px; height: 30px; color:#333; &#125; input::-ms-input-placeholder&#123;text-align: center;&#125; input::-webkit-input-placeholder&#123;text-align: center;&#125; &lt;/style&gt; &lt;body&gt; &lt;input placeholder="用户名" /&gt; &lt;/body&gt;&lt;/html&gt; 参考文章：知乎问题“如何让input里面placeholder水平居中？”]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器原生API实现Base64编码转换]]></title>
    <url>%2F2017%2F10%2F03%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8E%9F%E7%94%9FAPI%E5%AE%9E%E7%8E%B0Base64%E7%BC%96%E7%A0%81%E8%BD%AC%E6%8D%A2%2F</url>
    <content type="text"><![CDATA[最近发现浏览器的两个原生API atob()、btoa() 可以实现编码转换 1、代码如下：12btoa("hello world"); // "aGVsbG8gd29ybGQ="atob("aGVsbG8gd29ybGQ="); // "hello world" 2017-11-01添加 如果转换的字符串中有中文的话，编码转换会失败，这时候就需要window.encodeURIComponent和window.decodeURIComponent的帮助了： 1234567var str = "China，中国";window.btoa(window.encodeURIComponent(str))//"Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ="window.decodeURIComponent(window.atob('Q2hpbmElRUYlQkMlOEMlRTQlQjglQUQlRTUlOUIlQkQ='))//"China，中国" 2、再科（bai）普(du) 一下base64的编码原理： 转码过程例子：38=46内存1个字节占8位转前： s 1 3先转成ascii：对应 115 49 512进制： 01110011 00110001 001100116个一组（4组） 011100110011000100110011然后才有后面的 011100 110011 000100 110011然后计算机是8位8位的存数 6不够，自动就补两个高位0了所有有了 高位补0科学计算器输入 00011100 00110011 00000100 00110011得到 28 51 4 51查对下照表 c z E z 3、如果好奇atob()与btoa()的具体实现，可参考如下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220/* * $Id: base64.js,v 2.15 2014/04/05 12:58:57 dankogai Exp dankogai $ * * Licensed under the BSD 3-Clause License. * http://opensource.org/licenses/BSD-3-Clause * * References: * http://en.wikipedia.org/wiki/Base64 */(function(global) &#123; 'use strict'; // existing version for noConflict() var _Base64 = global.Base64; var version = "2.3.2"; // if node.js, we use Buffer var buffer; if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; try &#123; buffer = require('buffer').Buffer; &#125; catch (err) &#123;&#125; &#125; // constants var b64chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'; var b64tab = function(bin) &#123; var t = &#123;&#125;; for (var i = 0, l = bin.length; i &lt; l; i++) t[bin.charAt(i)] = i; return t; &#125;(b64chars); var fromCharCode = String.fromCharCode; // encoder stuff var cb_utob = function(c) &#123; if (c.length &lt; 2) &#123; var cc = c.charCodeAt(0); return cc &lt; 0x80 ? c : cc &lt; 0x800 ? (fromCharCode(0xc0 | (cc &gt;&gt;&gt; 6)) + fromCharCode(0x80 | (cc &amp; 0x3f))) : (fromCharCode(0xe0 | ((cc &gt;&gt;&gt; 12) &amp; 0x0f)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 6) &amp; 0x3f)) + fromCharCode(0x80 | ( cc &amp; 0x3f))); &#125; else &#123; var cc = 0x10000 + (c.charCodeAt(0) - 0xD800) * 0x400 + (c.charCodeAt(1) - 0xDC00); return (fromCharCode(0xf0 | ((cc &gt;&gt;&gt; 18) &amp; 0x07)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 12) &amp; 0x3f)) + fromCharCode(0x80 | ((cc &gt;&gt;&gt; 6) &amp; 0x3f)) + fromCharCode(0x80 | ( cc &amp; 0x3f))); &#125; &#125;; var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g; var utob = function(u) &#123; return u.replace(re_utob, cb_utob); &#125;; var cb_encode = function(ccc) &#123; var padlen = [0, 2, 1][ccc.length % 3], ord = ccc.charCodeAt(0) &lt;&lt; 16 | ((ccc.length &gt; 1 ? ccc.charCodeAt(1) : 0) &lt;&lt; 8) | ((ccc.length &gt; 2 ? ccc.charCodeAt(2) : 0)), chars = [ b64chars.charAt( ord &gt;&gt;&gt; 18), b64chars.charAt((ord &gt;&gt;&gt; 12) &amp; 63), padlen &gt;= 2 ? '=' : b64chars.charAt((ord &gt;&gt;&gt; 6) &amp; 63), padlen &gt;= 1 ? '=' : b64chars.charAt(ord &amp; 63) ]; return chars.join(''); &#125;; var btoa = global.btoa ? function(b) &#123; return global.btoa(b); &#125; : function(b) &#123; return b.replace(/[\s\S]&#123;1,3&#125;/g, cb_encode); &#125;; var _encode = buffer ? buffer.from &amp;&amp; buffer.from !== Uint8Array.from ? function (u) &#123; return (u.constructor === buffer.constructor ? u : buffer.from(u)) .toString('base64') &#125; : function (u) &#123; return (u.constructor === buffer.constructor ? u : new buffer(u)) .toString('base64') &#125; : function (u) &#123; return btoa(utob(u)) &#125; ; var encode = function(u, urisafe) &#123; return !urisafe ? _encode(String(u)) : _encode(String(u)).replace(/[+\/]/g, function(m0) &#123; return m0 == '+' ? '-' : '_'; &#125;).replace(/=/g, ''); &#125;; var encodeURI = function(u) &#123; return encode(u, true) &#125;; // decoder stuff var re_btou = new RegExp([ '[\xC0-\xDF][\x80-\xBF]', '[\xE0-\xEF][\x80-\xBF]&#123;2&#125;', '[\xF0-\xF7][\x80-\xBF]&#123;3&#125;' ].join('|'), 'g'); var cb_btou = function(cccc) &#123; switch(cccc.length) &#123; case 4: var cp = ((0x07 &amp; cccc.charCodeAt(0)) &lt;&lt; 18) | ((0x3f &amp; cccc.charCodeAt(1)) &lt;&lt; 12) | ((0x3f &amp; cccc.charCodeAt(2)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(3)), offset = cp - 0x10000; return (fromCharCode((offset &gt;&gt;&gt; 10) + 0xD800) + fromCharCode((offset &amp; 0x3FF) + 0xDC00)); case 3: return fromCharCode( ((0x0f &amp; cccc.charCodeAt(0)) &lt;&lt; 12) | ((0x3f &amp; cccc.charCodeAt(1)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(2)) ); default: return fromCharCode( ((0x1f &amp; cccc.charCodeAt(0)) &lt;&lt; 6) | (0x3f &amp; cccc.charCodeAt(1)) ); &#125; &#125;; var btou = function(b) &#123; return b.replace(re_btou, cb_btou); &#125;; var cb_decode = function(cccc) &#123; var len = cccc.length, padlen = len % 4, n = (len &gt; 0 ? b64tab[cccc.charAt(0)] &lt;&lt; 18 : 0) | (len &gt; 1 ? b64tab[cccc.charAt(1)] &lt;&lt; 12 : 0) | (len &gt; 2 ? b64tab[cccc.charAt(2)] &lt;&lt; 6 : 0) | (len &gt; 3 ? b64tab[cccc.charAt(3)] : 0), chars = [ fromCharCode( n &gt;&gt;&gt; 16), fromCharCode((n &gt;&gt;&gt; 8) &amp; 0xff), fromCharCode( n &amp; 0xff) ]; chars.length -= [0, 0, 2, 1][padlen]; return chars.join(''); &#125;; var atob = global.atob ? function(a) &#123; return global.atob(a); &#125; : function(a)&#123; return a.replace(/[\s\S]&#123;1,4&#125;/g, cb_decode); &#125;; var _decode = buffer ? buffer.from &amp;&amp; buffer.from !== Uint8Array.from ? function(a) &#123; return (a.constructor === buffer.constructor ? a : buffer.from(a, 'base64')).toString(); &#125; : function(a) &#123; return (a.constructor === buffer.constructor ? a : new buffer(a, 'base64')).toString(); &#125; : function(a) &#123; return btou(atob(a)) &#125;; var decode = function(a)&#123; return _decode( String(a).replace(/[-_]/g, function(m0) &#123; return m0 == '-' ? '+' : '/' &#125;) .replace(/[^A-Za-z0-9\+\/]/g, '') ); &#125;; var noConflict = function() &#123; var Base64 = global.Base64; global.Base64 = _Base64; return Base64; &#125;; // export Base64 global.Base64 = &#123; VERSION: version, atob: atob, btoa: btoa, fromBase64: decode, toBase64: encode, utob: utob, encode: encode, encodeURI: encodeURI, btou: btou, decode: decode, noConflict: noConflict &#125;; // if ES5 is available, make Base64.extendString() available if (typeof Object.defineProperty === 'function') &#123; var noEnum = function(v)&#123; return &#123;value:v,enumerable:false,writable:true,configurable:true&#125;; &#125;; global.Base64.extendString = function () &#123; Object.defineProperty( String.prototype, 'fromBase64', noEnum(function () &#123; return decode(this) &#125;)); Object.defineProperty( String.prototype, 'toBase64', noEnum(function (urisafe) &#123; return encode(this, urisafe) &#125;)); Object.defineProperty( String.prototype, 'toBase64URI', noEnum(function () &#123; return encode(this, true) &#125;)); &#125;; &#125; // // export Base64 to the namespace // if (global['Meteor']) &#123; // Meteor.js Base64 = global.Base64; &#125; // module.exports and AMD are mutually exclusive. // module.exports has precedence. if (typeof module !== 'undefined' &amp;&amp; module.exports) &#123; module.exports.Base64 = global.Base64; &#125; else if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD. Register as an anonymous module. define([], function()&#123; return global.Base64 &#125;); &#125; // that's it!&#125;)( typeof self !== 'undefined' ? self : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : this); 以上代码是GitHub上js-base64的开源代码，感兴趣的同学可以戳这里]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS格式化日期函数]]></title>
    <url>%2F2017%2F10%2F01%2FJS%E6%A0%BC%E5%BC%8F%E5%8C%96%E6%97%A5%E6%9C%9F%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[在JAVA中用SimpleDateFormat对象可以格式化日期，JS中没有原生方法，这个时候可以考虑自己写一个 代码如下： 1234567891011121314151617181920212223/** 对Date的扩展，将 Date 转化为指定格式的String 月(M)、日(d)、小时(h)、分(m)、秒(s)、季度(q) 可以用 1-2 个占位符， 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 例子： * (new Date()).Format("yyyy-MM-dd hh:mm:ss.S") ==&gt; 2006-07-02 08:09:04.423 * (new Date()).Format("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 * Date.prototype.Format = function (fmt) &#123; //author: meizz */Date.prototype.parse=function(fmt) &#123; var o = &#123; "M+": this.getMonth() + 1, //月份 "d+": this.getDate(), //日 "h+": this.getHours(), //小时 "m+": this.getMinutes(), //分 "s+": this.getSeconds(), //秒 "q+": Math.floor((this.getMonth() + 3) / 3), //季度 "S": this.getMilliseconds() //毫秒 &#125;; if (/(y+)/.test(fmt)) fmt = fmt.replace(RegExp.$1, (this.getFullYear() + "").substr(4 - RegExp.$1.length)); for (var k in o) if (new RegExp("(" + k + ")").test(fmt)) fmt = fmt.replace(RegExp.$1, (RegExp.$1.length == 1) ? (o[k]) : (("00" + o[k]).substr(("" + o[k]).length))); return fmt;&#125; 另一种写法如下： 123456789101112131415161718192021222324252627282930313233343536373839404142/** 对Date的扩展，将 Date 转化为指定格式的String * 月(M)、日(d)、12小时(h)、24小时(H)、分(m)、秒(s)、周(E)、季度(q) 可以用 1-2 个占位符 * 年(y)可以用 1-4 个占位符，毫秒(S)只能用 1 个占位符(是 1-3 位的数字) 例子： * (new Date()).pattern("yyyy-MM-dd hh:mm:ss.S")==&gt; 2006-07-02 08:09:04.423 * (new Date()).pattern("yyyy-MM-dd E HH:mm:ss") ==&gt; 2009-03-10 二 20:09:04 * (new Date()).pattern("yyyy-MM-dd EE hh:mm:ss") ==&gt; 2009-03-10 周二 08:09:04 * (new Date()).pattern("yyyy-MM-dd EEE hh:mm:ss") ==&gt; 2009-03-10 星期二 08:09:04 * (new Date()).pattern("yyyy-M-d h:m:s.S") ==&gt; 2006-7-2 8:9:4.18 */ Date.prototype.pattern=function(fmt) &#123; var o = &#123; "M+" : this.getMonth()+1, //月份 "d+" : this.getDate(), //日 "h+" : this.getHours()%12 == 0 ? 12 : this.getHours()%12, //小时 "H+" : this.getHours(), //小时 "m+" : this.getMinutes(), //分 "s+" : this.getSeconds(), //秒 "q+" : Math.floor((this.getMonth()+3)/3), //季度 "S" : this.getMilliseconds() //毫秒 &#125;; var week = &#123; "0" : "/u65e5", "1" : "/u4e00", "2" : "/u4e8c", "3" : "/u4e09", "4" : "/u56db", "5" : "/u4e94", "6" : "/u516d" &#125;; if(/(y+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, (this.getFullYear()+"").substr(4 - RegExp.$1.length)); &#125; if(/(E+)/.test(fmt))&#123; fmt=fmt.replace(RegExp.$1, ((RegExp.$1.length&gt;1) ? (RegExp.$1.length&gt;2 ? "/u661f/u671f" : "/u5468") : "")+week[this.getDay()+""]); &#125; for(var k in o)&#123; if(new RegExp("("+ k +")").test(fmt))&#123; fmt = fmt.replace(RegExp.$1, (RegExp.$1.length==1) ? (o[k]) : (("00"+ o[k]).substr((""+ o[k]).length))); &#125; &#125; return fmt; &#125; 参考博客‘一路前行’的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MAC上如何自由切换python2和python3并正确使用pip]]></title>
    <url>%2F2017%2F10%2F01%2FMAC%E4%B8%8A%E5%A6%82%E4%BD%95%E8%87%AA%E7%94%B1%E5%88%87%E6%8D%A2python2%E5%92%8Cpython3%E5%B9%B6%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8pip%2F</url>
    <content type="text"><![CDATA[MAC上默认的Python版本是2的版本，这时候怎么才能用上3的语法呢？用pip安装依赖的时候怎么才能根据不同的版本安装不同的依赖库呢？如果你对此也有疑问，或许这篇文章能帮助你 一、下载Python3最新版本如果还没有下载python3最新的版本，可以进入python的官网进行下载。 二、正确的使用Python3进行编译一开始以为用上Python3需要一些特殊的操作，后来发现自己还是 too young too simple sometimes native，事实上，不需要什么特殊的操作，要用Python2就用Python命令编译，就像下面这样： python ./demo.py 要用Python3就用Python3命令编译，就像下面这样： python3 ./demo.py 就这么简单。 三、安装pippip是python的包管理工具，类似node.js中的npm,在MAC中，安装pip很简单，输入如下命令即可安装： sudo easy_install pip 四、在python2和python3上正确的使用pip对于 Linux ## sudo pip install sth 或者明确版本 sudo pip2 install sthsudo pip3 install sthsudo python2 -m pip install sthsudo /path/to/python -m pip install sth 对于 Windows NT ##如果仅安装 python2 pip install sth 如果安装有 python3, 则需要明确 pip 版本 py -2 -m pip install sthpy -3 -m pip install sth 这一条参考的是知乎上同时装了Python3和Python2，怎么用pip？下Johnny Wong的回答,如果还有疑问，可以点进去了解详情。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>Python备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IE浏览器跳转报400错误的问题]]></title>
    <url>%2F2017%2F09%2F30%2FIE%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%B3%E8%BD%AC%E6%8A%A5400%E9%94%99%E8%AF%AF%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[最近开发中，遇到一个问题，在Chrome中可以正常跳转的链接在IE中跳转就会报400错误 如果URL的参数中带有中文，那么在IE中，则很有可能会报400错误，这个时候正确的做法是用js自带的encodeURL对URL进行编码，后传到另个一面后再用decodeURL进行解码。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS转换HTML转义符]]></title>
    <url>%2F2017%2F09%2F30%2FJS%E8%BD%AC%E6%8D%A2HTML%E8%BD%AC%E4%B9%89%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[前两天在公司写代码，在后台请求的数据放到前台时显示错乱，检查后发现如果文本里有&lt;,后面再紧跟字母的话，html就会显示错误，要解决这个问题，可以对文本里的特殊字符进行转义 一、去掉html标签123function removeHtmlTab(tab) &#123; return tab.replace(/&lt;[^&lt;&gt;]+?&gt;/g,'');//删除所有HTML标签&#125; 二、普通字符转换成转意符123function html2Escape(sHtml) &#123; return sHtml.replace(/[&lt;&gt;&amp;"]/g,function(c)&#123;return &#123;'&lt;':'&amp;lt;','&gt;':'&amp;gt;','&amp;':'&amp;amp;','"':'&amp;quot;'&#125;[c];&#125;);&#125; 三、转意符换成普通字符1234function escape2Html(str) &#123; var arrEntities=&#123;'lt':'&lt;','gt':'&gt;','nbsp':' ','amp':'&amp;','quot':'"'&#125;; return str.replace(/&amp;(lt|gt|nbsp|amp|quot);/ig,function(all,t)&#123;return arrEntities[t];&#125;);&#125; 三、&nbsp;转成空格1234function nbsp2Space(str) &#123; var arrEntities = &#123;'nbsp' : ' '&#125;; return str.replace(/&amp;(nbsp);/ig, function(all, t)&#123;return arrEntities[t]&#125;)&#125; 四、回车转为br标签123function return2Br(str) &#123; eturn str.replace(/\r?\n/g,"&lt;br /&gt;");&#125; 五、去除开头结尾换行,并将连续3次以上换行转换成2次换行123456function trimBr(str) &#123; str=str.replace(/((\s|&amp;nbsp;)*\r?\n)&#123;3,&#125;/g,"\r\n\r\n");//限制最多2次换行 str=str.replace(/^((\s|&amp;nbsp;)*\r?\n)+/g,'');//清除开头换行 str=str.replace(/((\s|&amp;nbsp;)*\r?\n)+$/g,'');//清除结尾换行 return str;&#125; 六、将多个连续空格合并成一个空格1234function mergeSpace(str) &#123; str=str.replace(/(\s|&amp;nbsp;)+/g,' '); return str;&#125; 参考博客：SJY之家]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js过滤emoji表情符号]]></title>
    <url>%2F2017%2F09%2F30%2Fjs%E8%BF%87%E6%BB%A4emoji%E8%A1%A8%E6%83%85%E7%AC%A6%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[有时候，在手机的输入框输入emoji，插入数据库时会报错，这时候有一个解决方案是用js正则把emoji表情给过滤掉 unicode定义的emoji是四个字符，而Mysql的utf8编码最多3个字节，所以数据插不进去。所以数据库会报错： SQLException: Incorrect string value 这时候有三种解决方案： 把emoji直接过滤掉； 将Mysql的编码从utf8转换成utf8mb4; unicode emoji转义为softbank的emoji; 这次只讨论第一种方案, 以下是正则代码,很简短，只有一行：1name = name.replace(/\ud83c[\udf00-\udfff]|\ud83d[\udc00-\ude4f]|\ud83d[\ude80-\udeff]/g, ""); 参考博客：“逸学堂”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取随机字符串]]></title>
    <url>%2F2017%2F09%2F29%2F%E8%8E%B7%E5%8F%96%E9%9A%8F%E6%9C%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%2F</url>
    <content type="text"><![CDATA[如何获取一段随机字符串？下面的方法或许能帮到你 123456789101112131415 /** * Get the a random string * @param &#123;integer&#125; len length of the random string * @return &#123;string&#125; */function getStrRandom(len) &#123; //len为字符串长度 var len = len || 32; var $chars = 'ABCDEFGHJKMNPQRSTWXYZabcdefhijkmnprstwxyz2345678'; /****默认去掉了容易混淆的字符oOLl,9gq,Vv,Uu,I1****/ var maxPos = $chars.length; var pwd = ''; for (var i = 0; i &lt; len; i++) &#123; pwd += $chars.charAt(Math.floor(Math.random() * maxPos)); &#125; return pwd;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS字符串截取函数slice(),substring(),substr()的区别]]></title>
    <url>%2F2017%2F09%2F28%2FJS%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%88%AA%E5%8F%96%E5%87%BD%E6%95%B0slice-substring-substr%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[在JS中,slice()、substring()、substr()都有截取字符串的作用，那他们有哪些用法上的区别呢？如果你也有疑惑，这篇文章或许能够帮助到你。 一、substring()substring()方法返回一个索引和另一个索引之间的字符串，语法如下： str.substring(indexStart, [indexEnd]) 下面有六点需要注意： substring()从提取的字符indexStart可达但不包括 indexEnd 如果indexStart 等于indexEnd，substring()返回一个空字符串。 如果indexEnd省略，则将substring()字符提取到字符串的末尾。 如果任一参数小于0或是NaN，它被视为为0。 如果任何一个参数都大于stringName.length，则被视为是stringName.length。 如果indexStart大于indexEnd，那么效果substring()就好像这两个论点被交换了一样； 例如，str.substring(1, 0) == str.substring(0, 1) 以下是一些示例代码：123456789var str = 'abcdefghij';console.log('(1, 2): ' + str.substring(1, 2)); // '(1, 2): b'console.log('(1, 1): ' + str.substring(1, 1)); // '(1, 1): 'console.log('(-3, 2): ' + str.substring(-3, 2)); // '(-3, 2): ab'console.log('(-3): ' + str.substring(-3)); // '(-3): abcdefghij'console.log('(1): ' + str.substring(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.substring(-20, 2)); // '(-20, 2): ab'console.log('(2, 20): ' + str.substring(2, 20)); // '(2, 20): cdefghij'console.log('(20, 2): ' + str.substring(20, 2)); // '(20, 2): cdefghij' 二、substr()substr()方法返回从指定位置开始的字符串中指定字符数的字符，语法如下： str.substr(start, [length]) 下面有四点需要注意： substr()会从start获取长度为length字符（如果截取到字符串的末尾，则会停止截取）。 如果start是正的并且大于或等于字符串的长度，则substr()返回一个空字符串。 若start为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。 如果length为0或为负数，substr()返回一个空字符串。如果length省略，则将substr()字符提取到字符串的末尾。 以下是一些示例代码：1234567var str = 'abcdefghij';console.log('(1, 2): ' + str.substr(1, 2)); // '(1, 2): bc'console.log('(-3, 2): ' + str.substr(-3, 2)); // '(-3, 2): hi'console.log('(-3): ' + str.substr(-3)); // '(-3): hij'console.log('(1): ' + str.substr(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.substr(-20, 2)); // '(-20, 2): ab'console.log('(20, 2): ' + str.substr(20, 2)); // '(20, 2): ' 需要注意的是，Microsoft的JScript不支持起始索引的负值。如果要使用此功能，可以使用以下兼容性代码来解决此错误： 12345678910111213141516171819// only run when the substr() function is brokenif ('ab'.substr(-1) != 'b') &#123; /** * Get the substring of a string * @param &#123;integer&#125; start where to start the substring * @param &#123;integer&#125; length how many characters to return * @return &#123;string&#125; */ String.prototype.substr = function(substr) &#123; return function(start, length) &#123; // call the original method return substr.call(this, // did we get a negative start, calculate how much it is from the beginning of the string // adjust the start parameter for negative value start &lt; 0 ? this.length + start : start, length) &#125; &#125;(String.prototype.substr);&#125; 三、substring()与substr()的主要区别substring()方法的参数表示起始和结束索引，substr()方法的参数表示起始索引和要包含在生成的字符串中的字符的长度,示例如下： 123var text = 'Mozilla';console.log(text.substring(2,5)); // =&gt; "zil"console.log(text.substr(2,3)); // =&gt; "zil" 四、slice()slice()方法返回一个索引和另一个索引之间的字符串，语法如下： str.slice(beginIndex[, endIndex]) 下面有三点需要注意： 若beginIndex为负数,则将该值加上字符串长度后再进行计算（如果加上字符串的长度后还是负数，则从0开始截取）。 如果beginIndex大于或等于字符串的长度，则slice()返回一个空字符串。 如果endIndex省略，则将slice()字符提取到字符串的末尾。如果为负，它被视为strLength + endIndex其中strLength是字符串的长度。 以下是一些示例代码：1234567891011var str = 'abcdefghij';console.log('(1, 2): ' + str.slice(1, 2)); // '(1, 2): b'console.log('(-3, 2): ' + str.slice(-3, 2)); // '(-3, 2): 'console.log('(-3, 9): ' + str.slice(-3, 9)); // '(-3, 9): hi'console.log('(-3): ' + str.slice(-3)); // '(-3): hij'console.log('(-3，-1): ' + str.slice(-3，-1)); // '(-3，-1): hi'console.log('(0，-1): ' + str.slice(0，-1)); // '(0，-1): abcdefghi'console.log('(1): ' + str.slice(1)); // '(1): bcdefghij'console.log('(-20, 2): ' + str.slice(-20, 2)); // '(-20, 2): ab'console.log('(20): ' + str.slice(20)); // '(20): 'console.log('(20, 2): ' + str.slice(20, 2)); // '(20, 2): ' 参考文档MDN web docs]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中如何进行对象的深拷贝]]></title>
    <url>%2F2017%2F09%2F21%2FJS%E4%B8%AD%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%B7%B1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[在JS中，一般的=号传递的都是对象/数组的引用，并没有真正地拷贝一个对象，那如何进行对象的深度拷贝呢？如果你对此也有疑问，这篇文章或许能够帮助到你。 一、对象引用、浅层拷贝与深层拷贝的区别js的对象引用传递理解起来很简单，参考如下代码：12345var a = &#123;name:'wanger'&#125;var b = a ;a===b // trueb.name = 'zhangsan'a.name //'zhangan' 上述代码中，使用了=进行赋值，于是b指向了a所指向的栈的对象，也就是a与b指向了同一个栈对象，所以在对b.name赋值时，a.name也发生了变化。为了避免上面的情况，可以对对象进行拷贝，代码如下： 12345var a = &#123;name:'wanger'&#125;var b = Object.assign(&#123;&#125;, a)a===b // falseb.name = 'zhangsan'a.name //'wanger' 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆，这时候a与b指向的是不同的栈对象，所以对b.name重新复制也不会影响到a.name。但是如果a.name是一个对象的引用，而不是一个字符串，那么上面的代码也会遇到一些问题，参考如下代码： 12345var a = &#123;name:&#123;firstName:'wang',lastName:'er'&#125;&#125;var b = Object.assign(&#123;&#125;, a)a===b // falseb.name.firstName = 'zhang'a.name.firstName //'zhang' b.name.firstName又影响到了a.name.firstName，这是因为Object.assign()方法只是浅层拷贝，a.name是一个栈对象的引用，赋值给b时，b.name也同样是这个栈对象的引用，很多时候，我们不想让这种事情发生，所以我们就需要用到对象的深拷贝。 二、使用JSON.parse（）与JSON.stringify（）对对象进行拷贝通常情况下，我们可以使用JSON.parse（）与 JSON.stringify（）实现对象的深克隆，如下： 123var clone = function (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125; 这种方法只适用于纯数据json对象的深度克隆，因为有些时候，这种方法也有缺陷，参考如下代码： 12345var clone = function (obj) &#123; return JSON.parse(JSON.stringify(obj));&#125;var a = &#123;a:function()&#123;console.log('hello world')&#125;,b:&#123;c:1&#125;,c:[1,2,3],d:"wanger",e:new Date(),f:null,g:undefined&#125;var b = clone(a) 打印如下：我们发现，上述的方法会忽略值为function以及undefied的字段，而且对date类型的支持也不太友好。 更要紧的是，上述方法只能克隆原始对象自身的值，不能克隆它继承的值，参考如下代码： 1234567function Person (name) &#123; this.name = name&#125;var wanger = new Person('王二')var newwanger = clone(wanger)wanger.constructor === Person // truenewwanger.constructor === Object // true 打印如下： 我们发现，克隆的对象的构造函数已经变成了Object,而原来的对象的构造是Person。 三、目前没有发现bug的对象深拷贝方法王二在网上参考了不少文章，方法都不尽完美，于是在前人基础上改造了一下，方法如下，目前没有发现有什么bug： 12345678910111213var clone = function (obj) &#123; if(obj === null) return null if(typeof obj !== 'object') return obj; if(obj.constructor===Date) return new Date(obj); var newObj = new obj.constructor (); //保持继承链 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //不遍历其原型链上的属性 var val = obj[key]; newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合 &#125; &#125; return newObj; &#125;; 这里有三点需要注意：1、用new obj.constructor ()构造函数新建一个空的对象，而不是使用{}或者[],这样可以保持原形链的继承；2、用obj.hasOwnProperty(key)来判断属性是否来自原型链上，因为for..in..也会遍历其原型链上的可枚举属性。3、上面的函数用到递归算法，在函数有名字，而且名字以后也不会变的情况下，这样定义没有问题。但问题是这个函数的执行与函数名 factorial 紧紧耦合在了一起。为了消除这种紧密耦合的现象，需要使用 arguments.callee。 2017-10-03添加，之前没有考虑正则对象的问题，这里做一下修改： 1234567891011121314var clone = function (obj) &#123; if(obj === null) return null if(typeof obj !== 'object') return obj; if(obj.constructor===Date) return new Date(obj); if(obj.constructor === RegExp) return new RegExp(obj); var newObj = new obj.constructor (); //保持继承链 for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; //不遍历其原型链上的属性 var val = obj[key]; newObj[key] = typeof val === 'object' ? arguments.callee(val) : val; // 使用arguments.callee解除与函数名的耦合 &#125; &#125; return newObj; &#125;;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中apply、call、bind的用法]]></title>
    <url>%2F2017%2F09%2F20%2FJS%E4%B8%ADapply%E3%80%81call%E3%80%81bind%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[apply()和call()都是为了改变某个函数运行时的上下文而存在的（就是为了改变函数内部this的指向）,bind()会创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 一、了解apply()的作用1、先来一个实例123456789var wanger = &#123; name: '王二', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;wanger.age(); // 17年调用是22,18年调用就变成23了 上面的对象定义了一个wanger对象，里面有个age方法，当调用age方法时，就可以得到王二的年龄；这时候，下面又来了一个张三:1234var zhangsan = &#123; name: '张三', birth: 1992,&#125;; 他没有age方法，但他也想知道自己的年龄，那该怎么办呢？或许我们可以借用王二的age方法来帮助张三知道自己的年龄，这时候，apply()就能帮到我们：1wanger.age.apply(zhangsan); //17年调用是25,18年调用就变成26了 上面apply()中的zhangsan成功地调用到了wanger的age方法。 在MDN中，是这么解释apply方法的： 在调用一个存在的函数时，你可以为其指定一个 this 对象。 this 指当前对象，也就是正在调用这个函数的对象。 使用 apply， 你可以只写一次这个方法然后在另一个对象中继承它，而不用在新对象中重复写该方法。 二、apply()与call()的区别 call()方法的作用和apply()方法类似，只有一个区别，就是call()方法接受的是若干个参数的列表，而apply()方法接受的是一个包含多个参数的数组 王二和张三要获得期末考试语文和数学加起来的成绩，如下代码所示：1234567891011var wanger = &#123; name: '王二', score: function (x,y) &#123; return x+y ; &#125;&#125;;var zhangsan = &#123; name: '张三',&#125;;wanger.score.apply(zhangsan,[100,98]); //198wanger.score.call(zhangsan,100,98); //198 以上两种方法都能获得张三的成绩； 两个方法用途差不多，为什么还要分成两个方法呢？还有那个谁，对，apply,还要放个数组进去，累不累啊？ 但是设计者这样设计是有用途的，参考如下代码： 1234567891011121314var wanger = &#123; name: '王二', score: function () &#123; return [...arguments].reduce((x,y)=&gt;x+y) ; //获得传入成绩的总和 &#125;&#125;;var zhangsan = &#123; name: '张三',&#125;;wanger.score.apply(zhangsan,[100,98,95]); //293wanger.score.call(zhangsan,100,98,95); //293wanger.score.apply(zhangsan,[100,98,95,96]); //389wanger.score.call(zhangsan,100,98,95,96); //389 当传入的的参数的值不固定时，call()的灵活性就明显不如apply()了，apply()只要传一个数组就搞定了。 三、bind()是干什么用的在MDN中，是这么解释bind方法的： bind()方法创建一个新的函数, 当被调用时，将其this关键字设置为提供的值 可以参考如下代码：1234567891011121314var wanger = &#123; name: '王二', birth: 1995, age: function () &#123; var y = new Date().getFullYear(); return y - this.birth; &#125;&#125;;var zhangsan = &#123; name: '张三', birth: 1992,&#125;;var getAge = wanger.age.bind(zhangsan); getAge() ; 这里bind()与call(),apply()有一个重要的区别：bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 四、总结 apply 、 call 、bind 三者都是用来改变函数的this对象的指向的； apply 、 call 、bind 三者第一个参数都是this要指向的对象，也就是想指定的上下文； apply 、 call 、bind 三者都可以利用后续参数传参； bind 是返回对应函数，便于稍后调用；apply 、call 则是立即调用 。 参考文献：MDN web docs廖雪峰的官方网站“chokcoco”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解原型链]]></title>
    <url>%2F2017%2F09%2F18%2F%E7%90%86%E8%A7%A3%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[在JS中，原型链有时候让人觉得很胡里花哨，又是prototype、__proto__又是各种指向什么的，让人觉得很头疼。如果你也有这种感觉，或许这篇文章可以帮助到你 一、认识原型1、先来一串代码 123456789var Person = function(msg)&#123; this.msg = msg;&#125;var person1 = new Person("wanger")person1.constructor===Person; //truePerson === Person.prototype.constructor; //trueperson1.__proto__ === Person.prototype; //trueperson1.__proto__.constructor === person1.constructor //true 看晕了吧？是不是很胡里花哨？不用担心，其实一张图就能了明白这其中的关系： 蓝色的是构造函数 绿色的是构造函数实例出来的对象 橙色的是构造函数的prototype,也是构造函数实例出来的对象的原型（它其实也是一个对象） 2、这里特别要注意的是prototype与__proto__的区别，prototype是函数才有的属性，而__proto__是每个对象都有的属性。(__proto__不是一个规范属性，只是部分浏览器实现了此属性，对应的标准属性是[[Prototype]])。 二、认识原型链1、我们刚刚了解了原型，那原型链在哪儿呢？不要着急，再上一张图： 通过这张图我们可以了解到,person1的原型链是： person1 —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 2、事实上，函数也是一个对象，所以，Person的原型链是： Person —-&gt; Function.prototype —-&gt; Object.prototype —-&gt; null 由于Function.prototype定义了apply()等方法，因此，Person就可以调用apply()方法。 3、如果把原型链的关系都显示清楚，那会复杂一些，如下图： 这里需要特别注意的是：所有函数的原型都是Function.prototype,包括Function构造函数和Object构造函数（如图中的标红部分） 三、原型链的继承1、假设我们要基于Person扩展出Student，Student的构造如下：12345function Student(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125; 但是，调用了Person构造函数不等于继承了Person，Student创建的对象的原型是： new Student() —-&gt; Student.prototype —-&gt; Object.prototype —-&gt; null 示意图如下所示： 必须想办法把原型链修改为： new Student() —-&gt; Student.prototype —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 示意图如下所示： 那我们应该怎么修改呢？仔细观察两张图的差异，我们会发现，如果我们将Student的prototype改成person1对象不就大功告成了？于是有了下面的代码： 1Student.prototype = person1 ; 但是这时候有个问题:1Student.prototype.constructor === Student; //false 原来Student.prototype(即person1)的constructor指向的还是Person，这时候还需要我们再改一下代码：1Student.prototype.constructor = Student; 这样就能把Student的原型链顺利的修改为： new Student() —-&gt; Student.prototype —-&gt; Person.prototype —-&gt; Object.prototype —-&gt; null 了； 完整的代码显示如下：1234567891011var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;var person1 = new Person("wanger")Student.prototype = person1 ;Student.prototype.constructor = Student; 三、用以上原型链继承带来的问题1、如果在控制台执行一遍上述的代码，我们会发现一些问题，如图所示： Student.prototype上含有之前person1带有的属性，那么，这样的继承的方法就显得不那么完美了 2、这个时候，我们可以借助一个中间对象来实现正确的原型链，这个中间对象的原型要指向Person.prototype。为了实现这一点，参考道爷（就是发明JSON的那个道格拉斯）的代码，中间对象可以用一个空函数F来实现： 123456789101112131415161718192021222324252627282930313233343536373839404142var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;// 空函数F:function F() &#123;&#125;// 把F的原型指向Person.prototype:F.prototype = Person.prototype;// 把Student的原型指向一个新的F对象，F对象的原型正好指向Person.prototype:Student.prototype = new F();// 把Student原型的构造函数修复为Student:Student.prototype.constructor = Student;// 继续在Student原型（就是new F()对象）上定义方法：Student.prototype.getGrade = function () &#123; return this.grade;&#125;;// 创建wanger:var wanger = new Student(&#123; name: '王二', grade: 9&#125;);wanger.msg; // '王二'wanger.grade; // 9// 验证原型:wanger.__proto__ === Student.prototype; // truewanger.__proto__.__proto__ === Person.prototype; // true// 验证继承关系:wanger instanceof Student; // truewanger instanceof Person; // true 这其中主要用到了一个空函数F作为过桥函数。为什么道爷会用过桥函数？用过桥函数F(){}主要是为了清空构造的属性。如果有些原Person的构造用不到，那么过桥函数将是一个好的解决方案 这样写的话，Student.prototype上就没有任何自带的私有属性，这是理想的继承的方法 3、如果把继承这个动作用一个inherits()函数封装起来，还可以隐藏F的定义，并简化代码： 123456function inherits(Child, Parent) &#123; var F = function () &#123;&#125;; F.prototype = Parent.prototype; Child.prototype = new F(); Child.prototype.constructor = Child;&#125; 封装后，写起来就像这样：123456789var Person = function(msg)&#123; this.msg = msg;&#125;var Student = function(props) &#123; // 调用Person构造函数，绑定this变量: Person.call(this, props); this.grade = props.grade || 1;&#125;inherits(Student,Person) ; 这样再一封装的话，代码就很完美了。 事实上，我们也可以在inherits中使用Object.create()来进行操作，代码如下：1234function inherits(Child, Parent) &#123; Child.prototype = Object.create(Parent.prototype); Child.prototype.constructor = Child;&#125; 如果有兴趣了解Object.create()的其他用法，可以参考我的这篇博客JS中Object.create的使用方法; 四、ES6的新关键字class在ES6中，新的关键字class，extends被正式被引入，它采用的类似java的继承写法，写起来就像这样：123456789class Student extends Person &#123; constructor(name, grade) &#123; super(msg); // 记得用super调用父类的构造方法! this.grade = grade || 1; &#125; myGrade() &#123; alert('I am at grade ' + this.grade); &#125;&#125; 这样写的话会更通俗易懂，继承也相当方便。读者可以进入廖雪峰的官方网站详细了解class的用法 参考文献：廖雪峰的官方网站]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在 vue-cli 中用 proxyTable 解决开发环境的跨域问题]]></title>
    <url>%2F2017%2F09%2F12%2F%E5%9C%A8-vue-cli-%E4%B8%AD%E7%94%A8-proxyTable-%E8%A7%A3%E5%86%B3%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E7%9A%84%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端开发工程中难免会遇到跨域问题，如果你用的是vue，不要担心，官方手脚架早已帮你准备好了解决方案 如果读者还不太了解 vue-cil , 或许vue-cil文档可以帮助到你 , 事实上,文档中就有用 proxyTable 进行代理请求的相关介绍 关键代码在 config/index.js 写下以下关键代码 ： 12345678910111213141516// config/index.jsmodule.exports = &#123; // ... dev: &#123; proxyTable: &#123; // proxy all requests starting with /api to jsonplaceholder '/api': &#123; target: 'http://jsonplaceholder.typicode.com', changeOrigin: true, pathRewrite: &#123; '^/api': '' &#125; &#125; &#125; &#125;&#125; 上面的示例将代理请求 /api/posts/test 到 http://jsonplaceholder.typicode.com/posts/test 实际开发中的配置王二在开发中进行的如下的配置： 123456789proxyTable: &#123; "/middleware": &#123; target: "http://192.168.2.57:80", pathRewrite: &#123; '^/middleware': '/patient/1070/middleware' &#125;, changeOrigin: true, &#125;&#125;, 这样就会将代理请求 /middleware/balabala 到 http://192.168.2.57:80/patient/1070/middleware/balabala 需要注意的是，这这种代理请求只适用于开发环境，其背后的设置来自于其使用的插件http-proxy-middleware，有兴趣可以了解了解]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS验证身份证的合法性]]></title>
    <url>%2F2017%2F09%2F12%2Fjs%E9%AA%8C%E8%AF%81%E8%BA%AB%E4%BB%BD%E8%AF%81%E7%9A%84%E5%90%88%E6%B3%95%E6%80%A7%2F</url>
    <content type="text"><![CDATA[最近公司业务需求需要验证身份证的合法性，以下分享一个可以判断身份合法性的方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869function IdentityCodeValid(code) &#123; function cap (str)&#123; //如果身份证验证中有x,则变为X再做判断； var temp = str.split(""); temp.forEach(function(i,index)&#123;if(i==='x')&#123;temp[index]="X"&#125;&#125;);return temp.join(""); &#125; var code = cap(code); var copycode = code ; var city=&#123;11:"北京",12:"天津",13:"河北",14:"山西",15:"内蒙古",21:"辽宁",22:"吉林",23:"黑龙江 ",31:"上海",32:"江苏",33:"浙江",34:"安徽",35:"福建",36:"江西",37:"山东",41:"河南",42:"湖北 ",43:"湖南",44:"广东",45:"广西",46:"海南",50:"重庆",51:"四川",52:"贵州",53:"云南",54:"西藏 ",61:"陕西",62:"甘肃",63:"青海",64:"宁夏",65:"新疆",71:"台湾",81:"香港",82:"澳门",91:"国外 "&#125;; var tip = ""; var pass= true; if(!code || !/^\d&#123;6&#125;(18|19|20)?\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\d|3[01])\d&#123;3&#125;(\d|X)$/i.test(code))&#123; tip = "身份证号格式错误"; pass = false; &#125; else if(!city[code.substr(0,2)])&#123; tip = "地址编码错误"; pass = false; &#125; else&#123; //18位身份证需要验证最后一位校验位 if(code.length == 18)&#123; code = code.split(''); //∑(ai×Wi)(mod 11) //加权因子 var factor = [ 7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2 ]; //校验位 var parity = [ 1, 0, 'X', 9, 8, 7, 6, 5, 4, 3, 2 ]; var sum = 0; var ai = 0; var wi = 0; for (var i = 0; i &lt; 17; i++) &#123; ai = code[i]; wi = factor[i]; sum += ai * wi; &#125; var last = parity[sum % 11]; if(parity[sum % 11] != code[17])&#123; tip = "校验位错误"; pass =false; &#125; &#125; &#125; //判断出生日期是否合法 function check(date)&#123; //date 传 例如：2013-01-01、2013/01/01、2013/01/32、2013/02/29 return (new Date(date).getDate()==date.substring(date.length-2)); &#125; function getDate(code)&#123; //得到类似2013-01-01、2013/01/01、2013/01/32、2013/02/29的日期格式 var date = '' ; if(code.length===18)&#123; date = code.substring(6,14) &#125;else if(code.length===15)&#123; date = '19'+code.substring(6,12) &#125;else&#123; return ''; &#125; date = date.substr(0,4)+'-'+date.substr(4,2)+'-'+date.substr(6,2); return date; &#125; if(!check(getDate(copycode)))&#123; pass = false ; tip = "日期格式不正确" &#125;// if(!pass) alert(tip); return pass;&#125; 参考文献“懒惰的肥兔”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jsonp的一般原理]]></title>
    <url>%2F2017%2F08%2F14%2Fjsonp%E7%9A%84%E4%B8%80%E8%88%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[浏览器中，由于有 同源策略 的存在，ajax跨域请求数据往往失败，这时候JSONP或许会帮到我们 由于同源策略，一般来说位于server1.example.com的网页无法与不是 server1.example.com的服务器沟通,这时候Jsonp可以帮助我们进行跨域的数据交互,另一个解决这个问题的新方法是CORS，咱们今天主要聊聊Jsonp。 一、JSONP是怎么产生的1、由于同源策略的存在，Ajax直接请求数据存在跨域无权限访问的问题。2、但我们又发现，Web页面上调用js文件时则不受是否跨域的影响（不仅如此，我们还发现凡是拥有”src”这个属性的标签都拥有跨域的能力，比如&lt;script&gt;、&lt;img&gt;、&lt;iframe&gt;）；3、于是可以判断，当前阶段如果想通过纯web端（ActiveX控件、服务端代理、属于未来的HTML5之Websocket等方式不算）跨域访问数据就只有一种可能，那就是在远程服务器上设法把数据装进js格式的文件里，供客户端调用和进一步处理；4、恰巧我们已经知道有一种叫做JSON的纯字符数据格式可以简洁的描述复杂数据，更妙的是JSON还被js原生支持，所以在客户端几乎可以随心所欲的处理这种格式的数据；5、这样子解决方案就呼之欲出了，web客户端通过与调用脚本一模一样的方式，来调用跨域服务器上动态生成的js格式文件（一般以JSON为后缀），显而易见，服务器之所以要动态生成JSON文件，目的就在于把客户端需要的数据装入进去。6、客户端在对JSON文件调用成功之后，也就获得了自己所需的数据，剩下的就是按照自己需求进行处理和展现了，这种获取远程数据的方式看起来非常像AJAX，但其实并不一样。7、为了便于客户端使用数据，逐渐形成了一种非正式传输协议，人们把它称作JSONP，该协议的一个要点就是允许用户传递一个callback参数给服务端，然后服务端返回数据时会将这个callback参数作为函数名来包裹住JSON数据，这样客户端就可以随意定制自己的函数来自动处理返回数据了。 二、JSONP的客户端具体实现不管jQuery也好，extjs也罢，又或者是其他支持jsonp的框架，他们幕后所做的工作都是一样的，下面我来循序渐进的说明一下jsonp在客户端的实现： 1、我们知道，哪怕跨域js文件中的代码（当然指符合web脚本安全策略的），web页面也是可以无条件执行的。远程服务器remoteserver.com根目录下有个remote.js文件代码如下：1alert('我是远程文件'); 本地服务器localserver.com下有个jsonp.html页面代码如下：123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 毫无疑问，页面将会弹出一个提示窗体，显示跨域调用成功。 2、现在我们在jsonp.html页面定义一个函数，然后在远程remote.js中传入数据进行调用。远程服务器remoteserver.com根目录下remote.js文件代码如下：1localHandler(&#123;"result":"我是远程js带来的数据"&#125;); 本地服务器localserver.com下jsonp.html页面代码如下：1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; var localHandler = function(data)&#123; alert('我是本地函数，可以被跨域的remote.js文件调用，远程js带来的数据是：' + data.result); &#125;; &lt;/script&gt; &lt;script type="text/javascript" src="http://remoteserver.com/remote.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 运行之后查看结果，页面成功弹出提示窗口，显示本地函数被跨域的远程js调用成功，并且还接收到了远程js带来的数据。很欣喜，跨域远程获取数据的目的基本实现了，但是又一个问题出现了，我怎么让远程js知道它应该调用的本地函数叫什么名字呢？毕竟是jsonp的服务者都要面对很多服务对象，而这些服务对象各自的本地函数都不相同啊？我们接着往下看。 3、聪明的开发者很容易想到，只要服务端提供的js脚本是动态生成的就行了呗，这样调用者可以传一个参数过去告诉服务端“我想要一段调用XXX函数的js代码，请你返回给我”，于是服务器就可以按照客户端的需求来生成js脚本并响应了。看jsonp.html页面的代码：123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script type="text/javascript"&gt; // 得到航班信息查询结果后的回调函数 var flightHandler = function(data)&#123; alert('你查询的航班结果是：票价 ' + data.price + ' 元，' + '余票 ' + data.tickets + ' 张。'); &#125;; // 提供jsonp服务的url地址（不管是什么类型的地址，最终生成的返回值都是一段javascript代码） var url = "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998&amp;callback=flightHandler"; // 创建script标签，设置其属性 var script = document.createElement('script'); script.setAttribute('src', url); // 把script标签加入head，此时调用开始 document.getElementsByTagName('head')[0].appendChild(script); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 这次的代码变化比较大，不再直接把远程js文件写死，而是编码实现动态查询，而这也正是jsonp客户端实现的核心部分，本例中的重点也就在于如何完成jsonp调用的全过程。我们看到调用的url中传递了一个code参数，告诉服务器我要查的是CA1998次航班的信息，而callback参数则告诉服务器，我的本地回调函数叫做flightHandler，所以请把查询结果传入这个函数中进行调用。OK，服务器很聪明，这个叫做flightResult.aspx的页面生成了一段这样的代码提供给jsonp.html（服务端的实现这里就不演示了，与你选用的语言无关，说到底就是拼接字符串）：12345flightHandler(&#123; "code": "CA1998", "price": 1780, "tickets": 5&#125;); 我们看到，传递给flightHandler函数的是一个json，它描述了航班的基本信息。运行一下页面，成功弹出提示窗口，jsonp的执行全过程顺利完成！ 4、到这里为止的话，相信你已经能够理解jsonp的客户端实现原理了吧？剩下的就是如何把代码封装一下，以便于与用户界面交互，从而实现多次和重复调用。 什么？你用的是jQuery，想知道jQuery如何实现jsonp调用？好吧，那我就好人做到底，再给你一段jQuery使用jsonp的代码（我们依然沿用上面那个航班信息查询的例子，假定返回jsonp结果不变）： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;script&gt; jQuery(document).ready(function()&#123; $.ajax(&#123; type: "get", async: false, url: "http://flightQuery.com/jsonp/flightResult.aspx?code=CA1998", dataType: "jsonp", jsonp: "callback",//传递给请求处理程序或页面的，用以获得jsonp回调函数名的参数名(一般默认为:callback) jsonpCallback:"flightHandler",//自定义的jsonp回调函数名称，默认为jQuery自动生成的随机函数名，也可以写"?"，jQuery会自动为你处理数据 success: function(json)&#123; alert('您查询到航班信息：票价： ' + json.price + ' 元，余票： ' + json.tickets + ' 张。'); &#125;, error: function()&#123; alert('fail'); &#125; &#125;); &#125;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这里没有写flightHandler这个函数，但是也运行成功了，这就是jQuery的功劳了，jquery在处理jsonp类型的ajax时自动帮你生成回调函数并把数据取出来供success属性方法来调用。 三、其他注意点1、ajax和jsonp这两种技术在调用方式上“看起来”很像，目的也一样，都是请求一个url，然后把服务器返回的数据进行处理，因此jquery和ext等框架都把jsonp作为ajax的一种形式进行了封装； 2、但ajax和jsonp其实本质上是不同的东西。ajax的核心是通过XmlHttpRequest获取非本页内容，而jsonp的核心则是动态添加&lt;script&gt;标签来调用服务器提供的js脚本。 3、所以说，其实ajax与jsonp的区别不在于是否跨域，ajax通过服务端代理一样可以实现跨域，jsonp本身也不排斥同域的数据的获取。 4、还有就是，jsonp是一种方式或者说非强制性协议，如同ajax一样，它也不一定非要用json格式来传递数据，如果你愿意，字符串都行，只不过这样不利于用jsonp提供公开服务。 文章转载自“随它去吧”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[将特殊英文字符转为中文字符]]></title>
    <url>%2F2017%2F08%2F14%2F%E5%B0%86%E7%89%B9%E6%AE%8A%E8%8B%B1%E6%96%87%E5%AD%97%E7%AC%A6%E8%BD%AC%E4%B8%BA%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[有时候将前台的数据传到后台，再从后台读取时，由于有特殊英文字符，会出现json转为对象出错的情况，这时候，一种解决方案就是在传到后台之前，将特殊的英文字符转为中文字符 以下是一个英文字符转为中文字符的简单方法 1234function replaceSpecialJson(str)&#123; var res = str.replace(/\"/g,"“").replace(/\[/g,"【").replace(/\]/g,"】").replace(/\&#123;/g,"｛").replace(/\&#125;/g,"｝") ; return res ;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解事件冒泡]]></title>
    <url>%2F2017%2F08%2F14%2F%E4%BA%86%E8%A7%A3%E4%BA%8B%E4%BB%B6%E5%86%92%E6%B3%A1%2F</url>
    <content type="text"><![CDATA[事件冒泡是前端er经常会遇到的问题，那在这里我们来用简短的代码来了解一下到底什么是事件冒泡 在这里我们主要讨论 event.stopPropagation() 与 event.preventDefault() 的区别，先来一段可执行的代码： 1234567891011121314151617181920212223242526272829303132333435363738&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;form&gt; &lt;div onclick="alert('我是最外层-1');"&gt; &lt;div onclick="alert('我是中间层-1');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-1');" id="test1"&gt;点击我-1&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div onclick="alert('我是最外层-2');"&gt; &lt;div onclick="alert('我是中间层-2');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-2');" id="test2"&gt;点击我-2&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;div onclick="alert('我是最外层-3');"&gt; &lt;div onclick="alert('我是中间层-3');"&gt; &lt;a href="https://www.baidu.com/" onclick="alert('我是最里层-3');" id="test3"&gt;点击我-3&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; &lt;/form&gt; &lt;script&gt; $("#test1").click(function(event) &#123; event.stopPropagation(); &#125;); $("#test2").click(function(event) &#123; event.preventDefault(); &#125;); $("#test3").click(function(event) &#123; return false ; &#125;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; event.stopPropagation();事件处理过程中，阻止了事件冒泡，但不会阻击默认行为（它就执行了超链接的跳转） event.preventDefault();如果把它放在头部A标签的click事件中，点击“点击我”。会发现它依次弹出：我是最里层—-我是中间层—-我是最外层，但最后却没有跳转到百度它的作用是：事件处理过程中，不阻击事件冒泡，但阻击默认行为（它只执行所有弹框，却没有执行超链接跳转） return false;事件处理过程中，阻止了事件冒泡，也阻止了默认行为（比如刚才它就没有执行超链接的跳转）]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过FileReader将图片转为Base64编码]]></title>
    <url>%2F2017%2F08%2F14%2F%E9%80%9A%E8%BF%87FileReader%E5%B0%86%E5%9B%BE%E7%89%87%E8%BD%AC%E4%B8%BABase64%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[如果我们想将图片转为base64编码，可以通过H5的FileReader接口来达成目标 封装好的方法 1234567891011121314151617/*** @param &#123;string&#125; dom input[name='file']的dom对象* @param &#123;function&#125; fn 回调函数*/function get_base64(dom,fn) &#123; var file = dom.files[0]; if(!file) return ; if(!window.FileReader)&#123; console.log("当前浏览器不支持FileReader！"); return; &#125; r = new FileReader(); r.onload = function()&#123; if(fn) fn(r) ; &#125;; r.readAsDataURL(file);&#125; 再来一段可执行的html代码，大家可以动手试试哈 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input accept="image/*" id="upload_file" type="file"&gt; &lt;textarea id="base64_output" style="min-width:800px;min-height: 500px;"&gt;&lt;/textarea&gt; &lt;script type="text/javascript"&gt; function $_(id) &#123; return document.getElementById(id); &#125; $_("upload_file").onchange = function () &#123; var dom = $_('upload_file'); get_base64(dom,function(r)&#123; $_('base64_output').value = r.result; &#125;); &#125;; function get_base64(dom,fn) &#123; var file = dom.files[0]; if(!file) return ; if(!window.FileReader)&#123; console.log("当前浏览器不支持FileReader！"); return; &#125; r = new FileReader(); r.onload = function()&#123; if(fn) fn(r) ; &#125;; r.readAsDataURL(file); &#125; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高亮文本里的关键字]]></title>
    <url>%2F2017%2F08%2F14%2F%E9%AB%98%E4%BA%AE%E6%96%87%E6%9C%AC%E9%87%8C%E7%9A%84%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[如何高亮html代码里的关键字？下面的方法或许能帮到你 封装好的方法 12345678910111213141516171819202122/*** @param &#123;string&#125; data 要搜索的文本* @param &#123;string&#125; key 要高亮的关键词* @param &#123;string&#125; bgColor 背景颜色，默认orange*/function keyLight(data, key, bgColor)&#123; var sText = data ; bgColor = bgColor || "orange", sKey = "&lt;span style='background-color: "+bgColor+";'&gt;"+key+"&lt;/span&gt;", num = -1, rStr = new RegExp(key, "g"), rHtml = new RegExp("\&lt;.*?\&gt;","ig"), //匹配html元素 aHtml = sText.match(rHtml); //存放html元素的数组 sText = sText.replace(rHtml, '&#123;~&#125;'); //替换html标签 sText = sText.replace(rStr,sKey); //替换key sText = sText.replace(/&#123;~&#125;/g,function()&#123; //恢复html标签 num++; return aHtml[num]; &#125;); return sText;&#125; 再来一段可执行的html代码，大家可以动手试试哈 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div id="test"&gt; &lt;div&gt;测试一&lt;/div&gt; &lt;div&gt;测试二&lt;/div&gt; &lt;div&gt;测试三&lt;/div&gt; &lt;/div&gt; &lt;/body&gt; &lt;script&gt; function keyLight(data, key, bgColor)&#123; var sText = data ; bgColor = bgColor || "orange", sKey = "&lt;span style='background-color: "+bgColor+";'&gt;"+key+"&lt;/span&gt;", num = -1, rStr = new RegExp(key, "g"), rHtml = new RegExp("\&lt;.*?\&gt;","ig"), //匹配html元素 aHtml = sText.match(rHtml); //存放html元素的数组 sText = sText.replace(rHtml, '&#123;~&#125;'); //替换html标签 sText = sText.replace(rStr,sKey); //替换key sText = sText.replace(/&#123;~&#125;/g,function()&#123; //恢复html标签 num++; return aHtml[num]; &#125;); return sText; &#125; var html = document.getElementById("test").innerHTML ; document.getElementById("test").innerHTML = keyLight(html,'试') ; &lt;/script&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解ES6中的Promise]]></title>
    <url>%2F2017%2F08%2F10%2F%E7%90%86%E8%A7%A3ES6%E4%B8%AD%E7%9A%84Promise%2F</url>
    <content type="text"><![CDATA[在ES6中，Promise被列为正式规范，Promise可以规范化回调，避免回调地狱 一、Promise的作用在ajax请求数据的过程中，我们可以异步拿到我们想要的数据，然后在回调中做相应的数据处理。这样做看上去并没有什么麻烦，但是如果这个时候，我们还需要做另外一个ajax请求，这个新的ajax请求的其中一个参数，得从上一个ajax请求中获取，这个时候我们就需要在回调函数中再写一个异步请求，然后在这个异步函数的回调函数里在写相应的数据处理。要是连续嵌套个三四层，往往就很恶心了。写起来就像下面这样：12345678910111213141516171819202122232425$.ajax(&#123; type:'get', url:'url_1', data: 'data' success : function(res)&#123; //相应的数据处理 var data = res.data $.ajax(&#123; type:'get', url:'url_2', data: data success : function(res)&#123; //相应的数据处理 $.ajax(&#123; type:'get', url:'url_3', data: data success : function(res)&#123; //相应的数据处理 &#125; &#125;) &#125; &#125;) &#125;&#125;) 在这种情况下Promise就能发挥它的威力了； 二、来一个实例先不谈语法，下面先来一个实例，建立感性的认识 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;script src="http://libs.baidu.com/jquery/2.0.0/jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt; &lt;script&gt; function a(data)&#123; return new Promise(function(resolve,reject)&#123; console.log("我是从上一个回调函数里传过来的数据",data) ; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'http://api.money.126.net/data/feed/0000001,1399001', //jsonp跨域调用上证与深证的股票指数 data:&#123; &#125;, success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; console.log("Error:") ; console.log(res) ; reject(res) ; &#125; &#125;) &#125;); &#125; function b(data)&#123; return new Promise(function(resolve,reject)&#123; console.log("我是从上一个回调函数里传过来的数据",data) ; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'https://api.douban.com/v2/movie/top250', //跨域调用豆top250的电影 success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; console.log("Error:") ; console.log(res) ; reject(res) &#125; &#125;) &#125;); &#125; a().then(b).then(a).then(b).catch(function(a)&#123;console.log("final Error:",a)&#125;) ; &lt;/script&gt;&lt;/html&gt; 打印结果如下所示： 可以发现，Promise 通过简单的链式调用就能得到之前多层回调才能达成的效果;而且从代码的结构来看，有效地减小了各个请求之间的耦合; 三、深入Promise别的不谈，先打印一下 Promise , console.dir(Promise) , 看看它究竟是哪号人物： 原来 Promise 本身是一个构造函数，自己身上有 all、 reject、 resolve 这几个的方法，在其 prototype 上有 then 、 catch 这两个方法。那么用Promise new出来的对象也会有 then 、 catch 这两个方法。 四、注意上面实例中的resolve与reject1、我们发现，在 new Promise(function(resolve,reject){}) 里传了两个方法 resolve 、 reject 作为参数，这两个方法通常会在函数的回调里被用到。一旦执行到resolve() 或者 reject() ，那么这个函数会停止执行，然后触发后面的 then() 或者 catch() 方法。准确一点来说，执行到resolve() 会触发 then() 方法，执行到 reject() 会触发 catch() 方法。 2、resolve 和 reject 方法里可以传入参数 ，就像 resolve(data) 和 reject(data) 。 如果这样做 ，那么在后面的 then() 或者 catch() 里传入一个带参数的函数 ， 就像 then(function(data){}) 或者 catch(function(data){}) ， 就能得到 data 的数据 。 3、说的再专业一些，Promise 对象有三种状态，他们分别是： pending: 等待中，或者进行中，表示还没有得到结果 resolved(Fulfilled): 已经完成，表示得到了我们想要的结果，可以继续往下执行 rejected: 也表示得到结果，但是由于结果并非我们所愿，因此拒绝执行 这三种状态不受外界影响，而且状态只能从 pending 改变为 resolved 或者rejected ，并且不可逆。在 Promise 对象的构造函数中，resolve 和 reject 就是用来处理Promise的状态变化。一般来说，调用 resolve 或 reject 以后，Promise 的使命就完成了，后继操作应该放到 then 或者 catch 方法里面，而不应该直接写在 resolve() 或 reject() 的后面 (事实的情况是，resolve() 或 reject() 的后面的代码也不会执行)。 五、new Promise() 里的函数是立刻执行的需要注意的的是，new Promise() 里的函数是立刻执行的 ，也就是说 ，当你执行下面这段代码时，就已经开始执行异步请求了： 123456789101112131415161718&lt;script&gt;new Promise(function(resolve,reject)&#123; $.ajax(&#123; type:'post', dataType: 'jsonp', url:'http://api.money.126.net/data/feed/0000001,1399001', data:&#123; &#125;, success : function(res)&#123; console.log(res) ; resolve(res) ; &#125;, error:function(res)&#123; reject(res) ; &#125; &#125;)&#125;);&lt;/script&gt; 这也是为什么，在上面第二段的实例中，需要用 a() 和 b() 函数把 new Promise() 给包起来 六、then() 函数的返回值一定是 Promise 对象还需要注意的的是，then() 函数的返回值一定是 Promise 对象，哪怕手动 return 一个值也无济于事，如下面的代码，照样能运行成功：1a().then(function ()&#123;console.log("hello");return 1&#125;).then(b) ; 这也解释了为什么我们可以链式调用 then() 函数。 七、Promise.all()与Promise.race()的用法想要从两个不同的 ajax 请求里分别获得信息，这两个任务是可以并行执行的，就可以用 Promise.all() 实现： 123456789101112131415161718&lt;script&gt;var p1 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;var p2 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;// 同时执行p1和p2，并在它们都完成后执行thenvar start = function()&#123; Promise.all([p1(), p2()]).then(function (results) &#123; console.log(results); // 获得一个Array: ['P1', 'P2'] &#125;);&#125;&lt;/script&gt; 有些时候，多个异步任务是为了容错。比如，分别发两个不同的 ajax 请求读取用户的个人信息，只需要获得先返回的结果即可，这种情况下，就可以用Promise.race() 实现： 1234567891011121314151617&lt;script&gt;var p1 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 500, 'P1'); &#125;);&#125; ;var p2 = function()&#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, 1000, 'P2'); &#125;);&#125; ;var start = function()&#123; Promise.all([p1(), p2()]).then(function (results) &#123; console.log(results); // 'P1' &#125;);&#125;&lt;/script&gt; 由于 p1 执行较快，Promise 的 then() 将获得结果 &#39;P1&#39; 。 p2 仍在继续执行，但执行结果将被丢弃。 如果我们组合使用Promise，就可以把很多异步任务以并行和串行的方式组合起来执行。 参考文献：阮一峰ES6入门廖雪峰的官方网站sitepoint“吕大豹”的博客园]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webApp调用百度地图API获取当前位置以及其他的一些操作]]></title>
    <url>%2F2017%2F08%2F09%2FwebApp%E8%B0%83%E7%94%A8%E7%99%BE%E5%BA%A6%E5%9C%B0%E5%9B%BEAPI%E8%8E%B7%E5%8F%96%E5%BD%93%E5%89%8D%E4%BD%8D%E7%BD%AE%E4%BB%A5%E5%8F%8A%E5%85%B6%E4%BB%96%E7%9A%84%E4%B8%80%E4%BA%9B%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[最近公司有业务需求，需要获得当前位置与各个医院的距离，在这里我主要调用百度地图的API接口，以下做一个总结 一、先上一个简单的实例1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;HTML5调用百度地图API&lt;/title&gt; &lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /&gt; &lt;script type="text/javascript" src="http://api.map.baidu.com/api?v=2.0&amp;ak=GG3pK0aFOLuRioYyTFhG75tOD2hBZ0CG"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body style="margin:50px 10px;"&gt; &lt;div style="width:600px;height:480px;border:1px solid gray;margin:30px auto" id="container"&gt;&lt;/div&gt; &lt;/body&gt; &lt;script type="text/javascript"&gt; /** * 写了一个map方法用以调出地图 * @param &#123;number&#125; x 经度 * @param &#123;number&#125; y 纬度，这个例子里写的是上海的经纬度 * @param &#123;String&#125; dom 要渲染的dom的id * @param &#123;Object&#125; size 地图的放大级别，范围0-19 */ function map(x,y,dom,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); &#125; map(121.48789949,31.24916171,"container"); &lt;/script&gt;&lt;/html&gt; 其中需要注意的是引用的 script 标签里的 GG3pK0aFOLuRioYyTFhG75tOD2hBZ0CG 这个秘钥是需要自己注册申请的，这里给一个注册的传送门，当然在测试中使用王二的这个秘钥也没有关系 二、并不一定需要经纬度，地名也是OK的将上面代码的第22行换成如下试试： 1map.centerAndZoom("南京",15); //中心点坐标可以是经纬度，也可以是地名 三、有时候我们需要一个标注，如下图所示 这时候可以在插入两行代码： 12var marker = new BMap.Marker(point); // 创建标注map.addOverlay(marker); // 将标注添加到地图中 写完整起来就像这样：12345678function map(x,y,dom,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); var marker = new BMap.Marker(point); map.addOverlay(marker);&#125;map(121.48789949,31.24916171,"container"); 四、有时候我们还需要一个标签，如下图所示 这时候可以插入如下的代码： 12345678910111213141516var label = new BMap.Label("上海浦西", &#123; //新建一个标签，并设置标签文本 offset: new BMap.Size(15, -25) //设置标签的偏移量&#125;);label.setStyle(&#123; //为标签设置样式 width: "80px", color: '#fff', background: '#ff8355', border: '1px solid "#ff8355"', borderRadius: "5px", textAlign: "center", height: "26px", lineHeight: "26px"&#125;);marker.setLabel(label); // 为标注添加一个标签 写成方法就像下面这样：12345678910111213141516171819202122function map(x,y,dom,text,size) &#123; var map = new BMap.Map(dom); var point = new BMap.Point(x,y); map.centerAndZoom(point,size||15); var label = new BMap.Label(text, &#123; offset: new BMap.Size(15, -25) &#125;); label.setStyle(&#123; width: "80px", color: '#fff', background: '#ff8355', border: '1px solid "#ff8355"', borderRadius: "5px", textAlign: "center", height: "26px", lineHeight: "26px" &#125;); var marker = new BMap.Marker(point); marker.setLabel(label); map.addOverlay(marker);&#125;map(121.48789949,31.24916171,"container","上海浦西"); 五、获取当前的经纬度获取当前的经纬度直接调用下面这个方法就好了：123456789101112function getCurrentPosition() &#123; var geolocation = new BMap.Geolocation(); geolocation.getCurrentPosition(function(r)&#123; //回调函数里有当前经纬度的信息 if(this.getStatus() == BMAP_STATUS_SUCCESS)&#123; console.log(r.point) ; &#125; else &#123; alert('failed:'+this.getStatus()); &#125; &#125;)&#125;getCurrentPosition() ; 不过回调的时间会长一些，2s左右 六、通过两地的经纬度获取两地的距离这里用到了一些数学和地理知识：12345678910function distance (start,end) &#123; // var x1 = (Math.PI/180)*start.y; var x2 = (Math.PI/180)*end.y; var y1 = (Math.PI/180)*start.x; var y2 = (Math.PI/180)*end.x; var R = 6371 ; //地球半径 var dis = Math.acos(Math.sin(x1)*Math.sin(x2)+Math.cos(x1)*Math.cos(x2)*Math.cos(y2-y1))*R; return dis.toFixed(2) ; //四舍五入保留两位小数，返回string类型&#125;distance(&#123;x:0,y:0&#125;,&#123;x:0,y:1&#125;) //算出经度为0，纬度为0 与 经度为0，纬度为1 两点之间的距离 七、百度地图API其他的一些功能，例如搜索、给出出行路线12345678910111213141516171819202122232425262728//创建信息窗口对象var infoWindow = new BMap.InfoWindow("I am here");map.openInfoWindow(infoWindow,point);//在地图中添加折线var polyline = new BMap.Polyline([ new BMap.Point(x,y), new BMap.Point(x+0.01,y+0.01) ],&#123;strokeColor:"blue", strokeWeight:6, strokeOpacity:0.5&#125;);map.addOverlay(polyline); //在地图中添加搜索功能var local = new BMap.LocalSearch(map, &#123; renderOptions:&#123; map: map &#125;&#125;);local.search("天安门");//给出地图的路线var driving = new BMap.DrivingRoute(map, &#123; renderOptions: &#123; map: map, autoViewport: true &#125;&#125;);driving.search("中关村", "天安门"); 感兴趣的话可以尝试一下，时间有限，回家睡觉，就不一一列举了。 2017-09-16 增 需要注意的的是，如在本地起服务器，地址是localhost的话，有时候会定位失败。这时候可以尝试把localhost换成本机的IP地址再试一下。 参考文献百度地图API文档许鸿飞的博客“莫水千留”的博客]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>百度地图API</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Tomcat服务器配置虚拟目录]]></title>
    <url>%2F2017%2F08%2F09%2FTomcat%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE%E8%99%9A%E6%8B%9F%E7%9B%AE%E5%BD%95%2F</url>
    <content type="text"><![CDATA[前两天配置Tomcat服务器老是起不起来，后来在孙老板的帮助下配置成功，这里做一个备忘 1、如何配置虚拟目录？ 找到 Tomcat 所在的文件目录，在其下有一个 bin\server.xml 文件,在 &lt;Host&gt;&lt;/Host&gt; 里的最后一行，加入如下代码 1&lt;Context path="/" docBase="C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\app"/&gt; 写完整了就像这样： 1234567&lt;Host name="localhost" appBase="webapps" unpackWARs="true" autoDeploy="true"&gt; &lt;Valve className="org.apache.catalina.valves.AccessLogValve" directory="logs" prefix="localhost_access_log" suffix=".txt" pattern="%h %l %u %t &amp;quot;%r&amp;quot; %s %b" /&gt; &lt;Context path="/" docBase="C:\\Program Files\\Apache Software Foundation\\Tomcat 9.0\\webapps\\app"/&gt;&lt;/Host&gt; 其中的 docBase 的值就是要配的虚拟目录，注意要写成绝对路径,另外要注意的就是字符串要做转义处理 \ 转义成 \\ 2、如果起不起来怎么办？这时候 log 文件夹下的日志或许能帮助我们了解到底报了什么错。很多情况下报错的原因是端口被暂用，这时候只要在 server.xml 下改一下相应的端口号就好啦！ 需要注意的是，server.xml 下配置不止一个端口号，有时候改了只改了一个端口号，可能仍然会报错，这时候就要修改其他被占用的端口号。 想要了解tomcat各个端口的实际意义，可以参考以下链接 “风的脚步”的CSDN博客]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>后台备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过JS获得浏览器的各种高度与宽度]]></title>
    <url>%2F2017%2F08%2F07%2F%E9%80%9A%E8%BF%87JS%E8%8E%B7%E5%BE%97%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E5%90%84%E7%A7%8D%E9%AB%98%E5%BA%A6%E4%B8%8E%E5%AE%BD%E5%BA%A6%2F</url>
    <content type="text"><![CDATA[浏览器的窗口的大小可以通过 document 和 window 提供的一系列属性来获得 123456789101112131415161718192021222324252627282930313233343536 /* 网页可见区域宽：document.body.clientWidth 网页可见区域高：document.body.clientHeight 网页可见区域宽：document.body.offsetWidth (包括边线的宽) 网页可见区域高：document.body.offsetHeight (包括边线的宽)(注意不是浏览器窗口的高度) dom元素相对于其父定位元素顶部的距离：dom.offsetTop (dom为dom对象的引用)(包括边线的宽) dom元素相对于其父定位元素左边的距离：dom.offsetLeft (dom为dom对象的引用)(包括边线的宽) 网页正文全文宽：document.body.scrollWidth 网页正文全文高：document.body.scrollHeight (注意不是浏览器窗口的高度) 网页被卷去的高：document.body.scrollTop (is_writeable) 网页被卷去的左：document.body.scrollLeft (is_writeable) 网页正文部分上：window.screenTop(相对于桌面的高) 网页正文部分左：window.screenLeft(相对于桌面的左) 屏幕分辨率的高：window.screen.height 屏幕分辨率的宽：window.screen.width 屏幕可用工作区高度：window.screen.availHeight (相对于 屏幕分辨率的高 会把浏览器输入栏的高度去掉) 屏幕可用工作区宽度：window.screen.availWidth (似乎和 window.screen.width 的值一样)*/function Query () &#123; console.log("网页可见区域宽：document.body.clientWidth -&gt;"+document.body.clientWidth) ; console.log("网页可见区域高：document.body.clientHeight -&gt;"+document.body.clientHeight) ; console.log("网页可见区域宽：document.body.offsetWidth (包括边线的宽) -&gt;"+document.body.offsetWidth) ; console.log("网页可见区域高：document.body.offsetHeight (包括边线的宽) -&gt;"+document.body.offsetHeight) ; console.log("网页正文全文宽：document.body.scrollWidth -&gt;"+document.body.scrollWidth) ; console.log("网页正文全文高：document.body.scrollHeight -&gt;"+document.body.scrollHeight) ; console.log("网页被卷去的高：document.body.scrollTop -&gt;"+document.body.scrollTop ) ; console.log("网页被卷去的左：document.body.scrollLeft -&gt;"+document.body.scrollLeft ) ; console.log("网页正文部分上：window.screenTop -&gt;"+window.screenTop ) ; console.log("网页正文部分左：window.screenLeft -&gt;"+window.screenLeft) ; console.log("屏幕分辨率的高：window.screen.height -&gt;"+window.screen.height ) ; console.log("屏幕分辨率的宽：window.screen.width -&gt;"+window.screen.width ) ; console.log("屏幕可用工作区高度：window.screen.availHeight -&gt;"+window.screen.availHeight ) ; console.log("屏幕可用工作区宽度：window.screen.availWidth -&gt;"+window.screen.availWidth ) ;&#125;Query() ;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[通过css样式禁止事件&禁止图标]]></title>
    <url>%2F2017%2F08%2F07%2F%E9%80%9A%E8%BF%87csss%E6%A0%B7%E5%BC%8F%E7%A6%81%E6%AD%A2%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[有时候，我们只想显示页面给用户看，而不想让用户有任何操作，这时候，在css中写入样式 pointer-events:none 就能达到想要的效果 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head lang="en"&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .test1&#123; cursor: not-allowed; &#125; .test2&#123; pointer-events:none; &#125; .test3&#123; cursor: not-allowed; pointer-events:none; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;button class="test1" onclick="con()"&gt;按钮一&lt;/button&gt; &lt;button class="test2" onclick="con()"&gt;按钮二&lt;/button&gt; &lt;button class="test3" onclick="con()"&gt;按钮二&lt;/button&gt; &lt;br&gt; &lt;input class='test1' type='text' onclick="con()"/&gt; &lt;input class='test2' type='text' onclick="con()"/&gt; &lt;input class='test3' type='text' onclick="con()"/&gt; &lt;/body&gt; &lt;script&gt; function con()&#123; alert("show here!") ; &#125; &lt;/script&gt;&lt;/html&gt; 不过需要注意的是，由于设置了 pointer-events:none 把所有点击事件全部禁掉了，所有的 cursor 也没有了,所以原本可以通过 cursor: not-allowed 显示的禁止图标也不会再显示了]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>CSS</tag>
        <tag>前端备忘</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用闭包或者setInterval实现一个计时器]]></title>
    <url>%2F2017%2F08%2F07%2F%E7%94%A8%E9%97%AD%E5%8C%85%E6%88%96%E8%80%85setInterval%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E8%AE%A1%E6%97%B6%E5%99%A8%2F</url>
    <content type="text"><![CDATA[在开发业务中，有时候需要手机获取验证码，一般情况下，在点击 获取验证码 后，会有一个60秒倒计时的需求，这时候可以用以下两个方法来实现 通过JS中的 闭包 的来实现，代码如下： 12345678910111213function countDown(time)&#123; var time = time||60 ; //默认60s倒计时 var fn = function()&#123; if(time&gt;0)&#123; setTimeout(fn,1000) ; console.log(time--+'s') ; &#125;else&#123; console.log('end') ; &#125; &#125;; return fn ;&#125;countDown()() ; //运行方法 也可以通过JS中的 setInterval 方法来实现，代码如下： 123456789101112function countDown(time)&#123; var time = time||10 ; var fn = setInterval(function()&#123; if(time&gt;0)&#123; console.log(time--+'s') ; &#125;else&#123; console.log('end') ; clearInterval(fn); &#125; &#125;,1000)&#125;countDown() ; //运行方法]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS中查询URL字符串中的参数]]></title>
    <url>%2F2017%2F08%2F03%2FJS%E4%B8%AD%E6%9F%A5%E8%AF%A2URL%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%9A%84%E5%8F%82%E6%95%B0%2F</url>
    <content type="text"><![CDATA[原生JS中的 location.search 可以返回从问号到 URL 末尾的所有内容，但是访问其中的每个字符串参数却很麻烦。这时候，可以创建一个函数，用以解析查询字符串 1234567891011121314151617181920212223242526function getQueryStringArgs()&#123; //取得查询字符串并去掉开头的问号 var qs = (location.search.length &gt; 0 ? location.search.substring(1) : ""), //保存数据的对象 args = &#123;&#125;, //取得每一项 items = qs.length ? qs.split("&amp;") : [], item = null, name = null, value = null, //在 for 循环中使用 i = 0, len = items.length; //逐个将每一项添加到 args 对象中 for (i=0; i &lt; len; i++)&#123; item = items[i].split("="); name = decodeURIComponent(item[0]); value = decodeURIComponent(item[1]); if (name.length) &#123; args[name] = value; &#125; &#125; return args;&#125; 这样getQueryStringArgs()方法就会返回包含所有URL参数的一个对象。 参考文献JavaScript高级程序设计（第3版）P207]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JS</tag>
        <tag>前端备忘</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo设置博文置顶]]></title>
    <url>%2F2017%2F07%2F31%2Fhexo%E8%AE%BE%E7%BD%AE%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%2F</url>
    <content type="text"><![CDATA[有时候我们需要置顶自己的某篇博文，这时候我们可以手动修改node_moudles文件夹下的相关代码 修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为如下所示： 12345678910111213141516171819202122232425262728'use strict';var pagination = require('hexo-pagination');module.exports = function(locals)&#123; var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) &#123; if(a.top &amp;&amp; b.top) &#123; // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 &#125; else if(a.top &amp;&amp; !b.top) &#123; // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; &#125; else if(!a.top &amp;&amp; b.top) &#123; return 1; &#125; else return b.date - a.date; // 都没定义按照文章日期降序排 &#125;); var paginationDir = config.pagination_dir || 'page'; return pagination('', posts, &#123; perPage: config.index_generator.per_page, layout: ['index', 'archive'], format: paginationDir + '/%d/', data: &#123; __index: true &#125; &#125;);&#125;; 在文章中添加相应的 top 值，数值越大文章就会越靠前，如 12345678---title: 解决Charles乱码问题date: 2017-05-22 22:45:48tags: 技巧categories: 技巧copyright: truetop: 100--- 参考文献Moorez的简书]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>转载</tag>
        <tag>博客搭建</tag>
      </tags>
  </entry>
</search>
